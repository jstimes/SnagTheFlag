{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/app/render_settings.ts","webpack:///./node_modules/tslib/tslib.es6.js","webpack:///./src/app/math/point.ts","webpack:///./src/app/controls.ts","webpack:///./src/app/math/direction.ts","webpack:///./src/app/grid.ts","webpack:///./src/app/theme.ts","webpack:///./src/app/game_settings.ts","webpack:///./src/app/level.ts","webpack:///./src/app/math/collision_detection.ts","webpack:///./src/app/shot_info.ts","webpack:///./src/app/actions.ts","webpack:///./src/app/character_settings.ts","webpack:///./src/app/game_objects/particle_system.ts","webpack:///./src/app/game_objects/flag.ts","webpack:///./src/app/game_objects/projectile.ts","webpack:///./src/app/math/lerp.ts","webpack:///./src/app/color.ts","webpack:///./src/app/hud.ts","webpack:///./src/app/game_objects/obstacle.ts","webpack:///./src/app/target_finder.ts","webpack:///./src/app/game_objects/character.ts","webpack:///./src/app/game_state.ts","webpack:///./src/app/logger.ts","webpack:///./src/app/math/random.ts","webpack:///./src/app/ai.ts","webpack:///./src/app/game_objects/spawner.ts","webpack:///./src/app/ui/ui_manager.ts","webpack:///./src/app/ui/text_box.ts","webpack:///./src/app/ui/button.ts","webpack:///./src/app/ui/button_group.ts","webpack:///./src/app/button_panel.ts","webpack:///./src/app/input_manager.ts","webpack:///./src/app/game_manager.ts","webpack:///./src/app/level_creator.ts","webpack:///./src/app/particle_system_theme.ts","webpack:///./src/app/campaign_level.ts","webpack:///./src/app/menus/free_play_menu.ts","webpack:///./src/main.ts","webpack:///./src/app/menus/campaign_menu.ts","webpack:///./src/app/menus/start_menu.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","RENDER_SETTINGS","canvasHeight","canvasWidth","frameRate","msBetweenRenders","__assign","assign","arguments","length","apply","this","__values","iterator","next","done","TypeError","__read","e","ar","push","error","__spread","concat","EventType","KeyPressState","x","y","add","other","Point","subtract","dot","getMagnitude","Math","sqrt","normalize","mag","multiplyScaler","scaler","distanceTo","to","manhattanDistanceTo","abs","getPointRotationRadians","atan2","equals","toString","getNormalVectorClockwise","getNormalVectorCounterclockwise","reflect","normal","containsPoint","points","pointFromSerialized","pt","Key","assignedControls","Map","keyToEventType","keyToKeyPressState","params","set","func","CONTROLS","addAssignedControl","eventType","KeyPress","isKeyDown","NOT_STARTED","READY","remove","removeAssignedControl","delete","clear","keys","check","KeyDown","KeyUp","currentState","DOWN","keyMap","assignedControlMap","mouseCanvasCoords","isMouseDownInternal","hasClickInternal","allKeys","filter","isNaN","Number","document","onkeydown","keyCode","onkeyup","initMouseControls","canvas","onmousemove","event","canvasRect","getBoundingClientRect","canvasCoords","clientX","left","clientY","top","onmousedown","onmouseup","onclick","hasClick","handleClick","Error","getMouseCanvasCoords","isMouseDown","isDown","getStringForKey","action","has","getAssignedControlMap","SHIFT","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","ONE","TWO","THREE","FOUR","FIVE","SIX","SEVEN","EIGHT","NINE","ZERO","SPACE","QUESTION_MARK","LEFT_ARROW","UP_ARROW","RIGHT_ARROW","DOWN_ARROW","numberToKey","numberToOrdinal","UP","LEFT","RIGHT","getCanvasFromTileCoords","tileCoords","Grid","TILE_SIZE","getTileFromCanvasCoords","floor","inbounds","TILES_WIDE","TILES_TALL","getAdjacentTiles","result","upAdjacent","downAdjacent","leftAdjacent","rightAdjacent","BUTTON_PANE_WIDTH","BUTTON_PANE_HEIGHT","GAME_WIDTH","GAME_HEIGHT","HALF_TILE","bfs","startTile","maxDepth","isAvailable","canGoThrough","availableTiles","queue","map","tile","depth","coords","queuedTile","shift","adjacentTile","values","find","MatchType","AiDifficulty","THEME","LEVELS","data","redFlag","blueFlag","obstacles","aiSpawner","PLAYER_VS_PLAYER_LOCAL","WEAK","DEFAULT_GAME_SETTINGS","startPt","direction","pointAtDistance","distance","endPt","b","from","p1","p2","Line","isVertical","isFinite","getYvalueAtX","detectRayLineSegmentCollision","ray","lineSegment","v","dNormal","vToP1","vToP2","a","isZero","haveOppositeSigns","isCollision","intersectionPt","rayLine","segmentLine","intersectionX","intersectionY","vToIntersection","collisionPt","ProjectileDetailsType","ProjectileShapeType","ActionType","CharacterAbilityType","ClassType","ParticleShape","LIGHT_HEAL","abilityType","HEAL","healAmount","maxUses","cooldownTurns","isFree","MEDIUM_HEAL","FULL_HEAL","LIGHT_GRENADE","THROW_GRENADE","splashDamage","type","SPLASH","numRicochets","damage","damageManhattanDistanceRadius","tilesAwayDamageReduction","projectileSpeed","color","shape","CIRCLE","radius","maxManhattanDistance","MEDIUM_GRENADE","SHOTGUN","canFireAfterMoving","projectileDetails","BULLET","aimIndicatorLength","spray","projectiles","offsetAngleRadians","PI","ASSAULT_RIFLE","SNIPER_RIFLE","RECTANGLE","size","MISSILE_LAUNCHER","SCOUT_CHARACTER_SETTINGS","SCOUT","maxHealth","maxMovesPerTurn","maxSight","gun","extraActions","Set","ASSAULT_CHARACTER_SETTINGS","ASSAULT","CHARACTER_CLASSES","SNIPER","DEMOLITION","teamIndex","startTileCoords","setIsTaken","getTileTopLeft","isTaken","isAtStart","returnToStart","setDropped","undefined","getCurrentTile","update","elapsedMs","render","context","tileCanvasTopLeft","topMargin","leftMargin","flagPoleWidth","fillStyle","fillRect","rightMargin","height","MAX_TRAIL_DISTANCE","TWO_PI","targets","setNewTargets","animationState","currentTarget","trails","maxDistance","fromTeamIndex","timesRicocheted","isDead","positionUpdate","movementSpeedMs","distanceUpdate","isAnimating","currentCenterCanvas","remainingTargets","isAtFinalTarget","firstTarget","getCurrentTarget","getNumRicochetsLeft","setIsDead","isTrailGone","every","trail","projecileLength","bacwardsDirection","overshotDistance","trailGradientStartPointCanvas","trailRenderStartPointCanvas","trailDistance","min","trailFadePointCanvas","gradient","createLinearGradient","fullColor","fadedColor","addColorStop","strokeStyle","beginPath","moveTo","lineTo","closePath","stroke","currentPointCanvas","arc","fill","directionNormal","leftOffset","rightOffset","topOffset","bottomOffset","topLeft","topRight","bottomRight","bottomLeft","lerp","hexStringToColor","hex","alpha","parseInt","substring","g","colorToString","Duration","TextType","particles","isAlive","startPositionCanvas","c1","c2","deltaTheta","particleCount","theta","cos","sin","speed","minParticleSpeed","maxParticleSpeed","random","lifetimeMs","minLifetimeMs","maxLifetimeMs","colorA","colorB","minRadius","maxRadius","rotationRadians","ELLIPSE","canvasPosition","deltaPositionPerMs","isAnyParticleAlive","forEach","particle","particleCenter","LINE","lineWidth","halfLineOffset","start","end","xRadius","yRadius","ellipse","PLUS","halfThickness","horizontalStart","verticalStart","durationToMs","SHORT","LONG","textTypeToRenderSettings","TITLE","fontSize","SUBTITLE","TOAST","isShowingControlMap","titleMsLeft","subtitleMsLeft","toastMsLeft","titleText","renderText","titleDuration","subtitleText","subtitleDuration","toastText","toastDuration","setText","text","textType","duration","ms","clearText","textRenderSettings","percentTimeLeft","font","textWidth","measureText","width","textCanvasPosition","fillText","getEdges","topLeftCorner","topRightCorner","bottomLeftCorner","bottomRightCorner","LineSegment","getRayForShot","shotInfo","Ray","fromCanvasCoords","aimAngleRadiansClockwise","getProjectileTargetsPath","startingTileCoords","characters","pathsLeft","currentTileCoords","currentRay","hasHitCharacter","isTargetEnemyCharacter","target","character","getProjectileTarget","newDirection","isTargetGridBorder","gridBorderTarget","topLeftCanvas","topRightCanvas","bottomLeftCanvas","bottomRightCanvas","leftBorderSegment","topBorderSegment","rightBorderSegment","bottomBorderSegment","borders","gridBorderCollisionPt","gridBorderCollisionTile","borderNormal","border","collisionResult","offset","hitCorner","corner","inset","getGridBorderTarget","tileTarget","stepSize","curDistance","currentTileString","checkedTilesStringSet","closestCollisionPt","closestCollisionTile","closestCollisionDistance","closestTargetNormal","potentialTargetLocations","obstacle","curTile","tilesToCheck","edges","edge","getTileTarget","GamePhase","SelectedCharacterState","CHARACTER_CIRCLE_RADIUS","gameDelegate","startCoords","index","settings","health","hasMoved","characterAbilityTypeToAbilityState","extraAction","actionState","cooldownTurnsLeft","usesLeft","isAiming","calculateTargetPath","resetTurnState","tileTopLeftCanvas","tileCenterCanvas","getCharacterColor","tileBottomLeftCanvas","margins","healthBarHeight","healthBarWidth","fractionHealthLeft","healthBarTopLeft","remainingHealthWidth","ankleWidth","ankleHeight","toeWidth","toeHeight","topLeftBoot","drawPathFrom","offsets","topArrowStart","bottomArrowStart","horizontalTopLeft","verticalTopLeft","flameStart","drawFlameFrom","aimLength","aimPath","newDistance","isMaxLength","targetsPath","isFinishedWithTurn","checkAndSetTurnOver","skipAnimation","finalTargetIndex","finalTarget","startAiming","canShoot","cancelAiming","setAim","angle","getAim","getCurrentAimPath","getCurrentShotInfo","shoot","hasShot","extraAbilities","ability","tileCenter","shotInfos","fromTileCoords","offsetDirection","aimAngle","getGrenadeAbility","grenadeAbility","useAbility","extraAbility","regenHealth","amount","isTurnOver","setTurnOver","state","some","LogType","gamePhase","CHARACTER_PLACEMENT","flags","currentTeamIndex","selectableTiles","isFogOfWarOn","hasFogOfWar","isTileVisibleByTeamIndex","getCharactersForTeamIndex","getFlagForTeamIndex","getTilesVisibleByTeamIndex","visibleTiles","getFirstCharacterIndex","squad","getActiveSquad","getGameInfo","getAliveCharacters","getActiveTeamName","getEnemyTeamName","getEnemyCharacters","getActiveTeamFlag","flag","getEnemyFlag","tileHasObstacle","enemyHasFlag","teamFlagCoords","teamHasFlag","enemyFlagCoords","getPath","isObstacleFree","endTile","pathedTiles","parent","hasFoundEnd","alreadyVisitedAdjacentTile","alreadyQueued","pathed","getPathedTile","pathedTile","current","path","reverse","pathTo","isSquadMemberAtTile","squadMember","selectedCharacter","randomElement","xs","Priority","LOGGER","logTypeToIsLogging","TARGET_FINDING","AI","ACTIONS","logTypeToLogs","log","console","WEAK_AI_SETTINGS","randomizeMovement","maxAngleRandomization","ignoresFogOfWar","characterClass","heals","MEDIUM_AI_SETTINGS","STRONG_AI_SETTINGS","difficultyToSettings","MEDIUM","STRONG","difficulty","actionQueue","characterIndexToPriority","getNextAction","gameState","getActionsForGameState","nextActionProducer","nextAction","JSON","stringify","placeCharacter","selectedCharacterState","assignPriority","getActionsForFlagCarrrier","getHasntMovedNorShot","characterCenter","getTileCenterCanvas","possibleShots","getEnemyTargetsInDirectSight","getShootSequence","getBestShot","END_CHARACTER_TURN","characterIndex","priority","SELECT_CHARACTER_CLASS","class","optimalTiles","DEFEND","getClosestSelectableTileToLocationWithFewestDirectHits","selection","SELECT_TILE","currentCharacterCenterCanvas","characterMoveTargetTile","ELIMINATE","enemies","getVisibleEnemies","best","enemy","score","dist","hp","safeMove","getSafeMoveTowardsLocation","SELECT_CHARACTER_STATE","MOVING","characterIsFullyHealed","tileAndDirectHits","selectableTile","directHitDetails","directHits","bestTileAndHits","tileAndHit","obj","targetTile","enemiesInSight","possibleTiles","teamFlagTile","tileLocation","bestTiles","bestTile","pathToLocation","getPathToLocation","fromTile","shots","shot","enemyCharacters","targetCharacter","targetHealth","shotDetails","AIMING","randomAimAdjustment","aim","aimAngleClockwiseRadians","AIM","SHOOT","fromCanvas","visibleEnemies","getNextPriority","startingTeamSize","teamIndexToSquadSize","desiredDefenders","desiredSnaggers","SNAG","message","turnsBetweenSpawns","turnsSinceLastSpawn","advanceTurn","checkAndHandleRespawn","tileCanvasCenter","radiansThick","radiansOffset","elements","addElement","element","removeAll","removeElement","splice","indexOf","onMouseMove","uiCoords","getUiCoords","onClick","dimensions","style","getCanvasCoords","sizeCanvas","textColor","boxCenterCanvas","getBoxCenter","getFillColor","buttonCenterCanvas","getButtonCenter","isSelected","selectedBorderColor","strokeRect","isInButton","onClickCallback","isHovered","hoverColor","selectedColor","setIsSelected","isX","isY","buttons","onButtonClicked","currentlySelectedIndex","onChangeCallback","buttonParam","buttonStyle","initialSelectionIndex","select","borderWidth","leftEdgeCanvas","leftUiCoord","widthUi","horizontalMargins","maxWidth","maxWidthUi","descriptionFontSize","buttonOffsetY","buttonSize","headerSize","headerStyle","uiManager","mouseMove","mouseCanvas","tryClick","clickCanvas","selectIndex","buttonGroup","clearBottomButtons","clearDescription","configurePanel","headerTextLines","buttonInfos","isButtonGroup","rows","row","header","buttonIndex","topLeftY","button","dimension","lastButton","buttonGroupBottomMargin","setDescription","textLines","descriptionStyle","descriptionTextBoxes","textBox","setBottomButtons","topY","param","bottomButtons","PAUSE_KEY","QUIT_KEY","RESTART_KEY","MOVE_KEY","TOGGLE_AIM_KEY","AIM_COUNTERCLOCKWISE_KEY","AIM_CLOCKWISE_KEY","SLOWER_AIM","SHOOT_KEY","HEAL_KEY","TOGGLE_THROW_GRENADE_KEY","END_TURN_KEY","KEYS_TO_CHARACTER_CLASS_TYPE","delegate","gameClickHandler","controlMap","buttonPanel","mouseTileCoords","initDefaultControls","addDefaultControls","initForCharacterPlacement","tryPlacingCharacter","addCharacterClassControls","initGameOverControls","addQuitAndRestartControls","quitKeyString","restartKey","setToastText","initForSelectedCharacterState","getGameState","addSwitchSquadMemberControls","lines","AIM_ANGLE_RADIANS_DELTA","AWAITING","onAction","healAction","THROWING_GRENADE","tryMovingSelectedCharacter","aimOffset","newAim","aimAction","fireAction","tryThrowingGrenade","getCharacterClassForType","round","getDescriptionForGun","line","typeToState","extraAbilityType","extraAbilityDescription","getExtraAbilityDescription","getDescriptionsForExtraAbilityStates","placeCharacterAction","trySelectingCharacter","squadMemeberAtTile","selectCharacterAction","SELECT_CHARACTER","selectTileAction","characterNumber","togglePause","isGameOver","onRestart","onQuit","characterClassType","selectCharacterClassAction","classIndex","findIndex","clasz","description","getDescriptionForClass","isNowPaused","isPaused","onTogglePause","getDescriptionsForExtraActions","sprayDetails","PlacementMode","onAnimationDone","visibleEnemyCharacters","onProjectileAnimationOver","checkGameOver","checkCharacterTurnOver","resetGame","destroy","gameSettings","loadLevel","winningTeamIndex","selectedCharacterSettings","particleSystems","ais","teamIndexToIsAi","matchType","numTeams","isAi","AI_VS_AI","aiDifficulty","hud","inputManager","onExitGameCallback","nextTurn","levelIndex","animatable","particleSystem","projectile","updateProjectile","shouldSkipAnimation","isAiTurn","getCurrentTurnAi","hitPositionCanvas","getGrenadeBurstParticleSystemParams","hitTiles","hitTile","manhattanDistance","damageReduction","pow","getBulletParticleSystemParams","otherOtherProjectile","otherProjectile","newTargets","clearRect","availableTile","shouldRenderCharacter","spawners","shouldRenderObjectAtTile","renderFogOfWar","animatingCharacterTile","PLAYER_VS_AI","visibleTile","canvasTopLeft","activeSquad","fireShot","addOnAnimationDoneCallback","onCharacterTurnOver","COMBAT","handleCharacterMovement","grenadeDetails","throwGrenade","squadIndex","teamMaxSquadSize","setSelectedCharacter","setSelectedCharacterState","throwBadAction","winningTeam","setGameOver","activeSquadMember","initCharacterPlacementTurn","advanceToNextCombatTurn","getAvailableTilesForCharacterPlacement","teamName","spawner","newCharacterIndex","ai","callback","toTile","tilePath","tileToCanvas","curCanvas","nextTile","nextCanvas","mapTilePathToTargetsPath","enemyFlag","activeTeamFlag","characterHasEnemyFlag","subtitle","details","targetCanvasCoords","proj","flagCoords","maxDistFromFlag","maxSpawnDistanceFromFlag","isTileOccupied","getAvailableTilesForCharacterMovement","ownFlag","ownFlagCoords","currentCoords","maxMoves","getAvailableTilesForThrowingGrenade","maxDist","potentialObstacle","potentialCharacter","potentialSpawner","level","serializedPt","hasSpawners","aiDifficultyToSpawnDelays","saveLevel","placementMode","OBSTACLE","setPlacementMode","BLUE_FLAG","RED_FLAG","ERASE","clickCoords","removeObjectInTile","endX","startX","startY","endY","fillColor","renderControls","renderTop","CAMPAIGN_LEVELS","levelName","isUnlocked","getLastUnlocked","storedValue","window","localStorage","getItem","lastUnlockedCampaignLevelIndex","checkUnlocked","GameState","callbacks","onSelectLevel","onBack","initSettingsElements","initLevelElements","initButtons","elapsedTime","clickCanvasCoords","renderTitleText","backButtonLeft","backButton","startButtonLeft","startButton","selectedTeamSizeMap","selectedMatchType","selectedAiDifficulty","selectedLevelIndex","settingsTopMargin","buttonGroupOffsetY","labelStyle","settingsHeader","createSettingRowElements","labelSize","labelLeftMargin","headerText","buttonLeftMargin","buttonTexts","column","topLeftX","onButtonChangeCallback","initialButtonIndex","teamSizeIndexToTeamSizeMap","teamSizeIndexToString","teamSizeTopY","matchTypeTopY","aiDifficultyTopY","fogOfWarTopY","spawnersTopY","teamSizeElements","difficulties","aiDifficultyElements","matchTypes","matchTypeElements","previousMatchType","fogOfWarOptions","fogOfWarElements","spawnersOptions","spawnerElements","levelElementSize","buttonTopMargin","levelButtonsLeftMargin","levelHeaderLeftMargin","levelHeader","levelDimensions","onLevelChangeCallback","initLevelMenu","elementSize","lockedTextBoxStyle","middleColumnLeftMargin","leftColumnLeftMargin","rightColumnLeftMargin","columnSize","campaignLevelIndex","campaignLevel","onFreePlay","onCampaign","onCreateLevel","initMenu","buttonMetadatas","buttonMetadata","lastRenderTime","START_MENU","onSelectFreePlayLevel","initGame","tearDownCurrentGameState","initFreePlayMenu","onSelectCampaignLevel","nextCampaignLevelIndex","setItem","initCampaignMenu","initStartMenu","createElement","body","appendChild","backgroundColor","setAttribute","getContext","requestAnimationFrame","timestamp","gameLoop","gameStateManager","initLevelCreator","GAME","FREE_PLAY_MENU","CAMPAIGN_MENU","LEVEL_CREATOR","isInitialized","onreadystatechange","readyState"],"mappings":"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Z,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,GACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,GAAIC,EAAG,GACZ,CAAED,EAAG,GAAIC,EAAG,GACZ,CAAED,EAAG,GAAIC,EAAG,GACZ,CAAED,EAAG,GAAIC,EAAG,GACZ,CAAED,EAAG,GAAIC,EAAG,GACZ,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,GAAIC,EAAG,GACZ,CAAED,EAAG,GAAIC,EAAG,GACZ,CAAED,EAAG,GAAIC,EAAG,GACZ,CAAED,EAAG,GAAIC,EAAG,GACZ,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,GAAIC,EAAG,GACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,GACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,GAAIC,EAAG,IACZ,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,GACX,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,EAAGC,EAAG,IACX,CAAED,EAAG,GAAIC,EAAG,GACZ,CAAED,EAAG,GAAIC,EAAG,GACZ,CAAED,EAAG,GAAIC,EAAG,GACZ,CAAED,EAAG,GAAIC,EAAG,KAEpBuL,UAAW,CAAE,EAAK,EAAG,EAAK,KAGJ,CACtB1O,KAAM,aACNsO,KAAM,CAAE,QAAW,CAAE,EAAK,GAAI,EAAK,IAAM,SAAY,CAAE,EAAK,EAAG,EAAK,GAAK,UAAa,CAAC,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,KAE3wDI,UAAW,CAAE,EAAK,GAAI,EAAK,KAGV,CACjB1O,KAAM,QACNsO,KAAM,CAAE,QAAW,CAAE,EAAK,EAAG,EAAK,IAAM,SAAY,CAAE,EAAK,GAAI,EAAK,GAAK,UAAa,CAAC,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM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AAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,KAEr2FI,UAAW,CAAE,EAAK,EAAG,EAAK,KAGP,CACnB1O,KAAM,UACNsO,KAAM,CAAE,QAAW,CAAE,EAAK,EAAG,EAAK,IAAM,SAAY,CAAE,EAAK,GAAI,EAAK,GAAK,UAAa,CAAC,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,KAE5kGI,UAAW,CAAE,EAAK,EAAG,EAAK,KAGP,CACnB1O,KAAM,UACNsO,KAAM,CAAE,QAAW,CAAE,EAAK,EAAG,EAAK,IAAM,SAAY,CAAE,EAAK,GAAI,EAAK,GAAK,UAAa,CAAC,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,MAE//EI,UAAW,CAAE,EAAK,EAAG,EAAK,KAGP,CACnB1O,KAAM,UACNsO,KAAM,CAAE,QAAW,CAAE,EAAK,EAAG,EAAK,IAAM,SAAY,CAAE,EAAK,GAAI,EAAK,GAAK,UAAa,CAAC,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,MAE/qEI,UAAW,CAAE,EAAK,EAAG,EAAK,KAGP,CACnB1O,KAAM,UACNsO,KAAM,CAAE,QAAW,CAAE,EAAK,EAAG,EAAK,IAAM,SAAY,CAAE,EAAK,GAAI,EAAK,GAAK,UAAa,CAAC,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,KAEzhFI,UAAW,CAAE,EAAK,EAAG,EAAK,KAGR,CAClB1O,KAAM,SACNsO,KAAM,CAAE,QAAW,CAAE,EAAK,EAAG,EAAK,IAAM,SAAY,CAAE,EAAK,GAAI,EAAK,GAAK,UAAa,CAAC,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,MAE79DI,UAAW,CAAE,EAAK,EAAG,EAAK,KAGP,CACnB1O,KAAM,UACNsO,KAAM,CAAE,QAAW,CAAE,EAAK,GAAI,EAAK,IAAM,SAAY,CAAE,EAAK,GAAI,EAAK,GAAK,UAAa,CAAC,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,KAEx1EI,UAAW,CAAE,EAAK,GAAI,EAAK,KAGX,CAChB1O,KAAM,OACNsO,KAAM,CAAE,QAAW,CAAE,EAAK,EAAG,EAAK,IAAM,SAAY,CAAE,EAAK,EAAG,EAAK,IAAM,UAAa,CAAC,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,MAE78FI,UAAW,CAAE,EAAK,EAAG,EAAK,KAGT,CACjB1O,KAAM,QACNsO,KAAM,CAAE,QAAW,CAAE,EAAK,EAAG,EAAK,IAAM,SAAY,CAAE,EAAK,GAAI,EAAK,GAAK,UAAa,CAAC,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,EAAG,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,EAAG,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,GAAK,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CAAE,EAAK,GAAI,EAAK,IAAM,CA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","file":"app.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export interface RenderSettings {\n    readonly canvasHeight: number;\n    readonly canvasWidth: number;\n    /** Frames per second. */\n    readonly frameRate: number;\n    readonly msBetweenRenders: number;\n}\n\nfunction createDefaultRenderSettings(): RenderSettings {\n    const canvasHeight = 800;\n    const canvasWidth = 1040;\n    const frameRate = 60;\n    const msBetweenRenders = 1000 / frameRate;\n    return {\n        canvasHeight,\n        canvasWidth,\n        frameRate,\n        msBetweenRenders,\n    }\n}\n\nexport const RENDER_SETTINGS = createDefaultRenderSettings();\n\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export class Point {\n\n    readonly x: number;\n    readonly y: number;\n\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n\n    add(other: Point): Point {\n        return new Point(this.x + other.x, this.y + other.y);\n    }\n\n    subtract(other: Point): Point {\n        return new Point(this.x - other.x, this.y - other.y);\n    }\n\n    dot(other: Point): number {\n        return this.x * other.x + this.y * other.y;\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.dot(this));\n    }\n\n    normalize(): Point {\n        const mag = this.getMagnitude();\n        return new Point(this.x / mag, this.y / mag);\n    }\n\n    multiplyScaler(scaler: number): Point {\n        return new Point(this.x * scaler, this.y * scaler);\n    }\n\n    distanceTo(to: Point): number {\n        return to.subtract(this).getMagnitude();\n    }\n\n    manhattanDistanceTo(other: Point): number {\n        return Math.abs(this.x - other.x) + Math.abs(this.y - other.y);\n    }\n\n    getPointRotationRadians(): number {\n        return Math.atan2(this.y, this.x);\n    }\n\n    equals(other: Point): boolean {\n        return this.x === other.x && this.y === other.y;\n    }\n\n    toString(): string {\n        return `(${this.x}, ${this.y})`;\n    }\n\n    getNormalVectorClockwise(): Point {\n        return new Point(this.y, -this.x);\n    }\n\n    getNormalVectorCounterclockwise(): Point {\n        return new Point(-this.y, this.x);\n    }\n\n    /** Assumes this point is incoming vector. */\n    reflect(normal: Point): Point {\n        return this.subtract(normal.multiplyScaler(2 * this.dot(normal)));\n    }\n}\n\nexport function containsPoint(x: Point, points: Point[]): boolean {\n    for (let i = 0; i < points.length; i++) {\n        if (x.equals(points[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport function pointFromSerialized(pt: { x: number; y: number }): Point {\n    return new Point(pt.x, pt.y);\n}","import { Point } from 'src/app/math/point';\nimport { RENDER_SETTINGS } from 'src/app/render_settings';\n\nexport enum EventType {\n    KeyDown,\n    KeyUp,\n    KeyPress,\n}\n\nenum KeyPressState {\n    NOT_STARTED,\n    READY,\n    DOWN,\n}\n\nexport interface ControlParams {\n    readonly key: Key;\n    readonly func: () => void;\n    readonly name: string;\n    readonly eventType: EventType;\n}\n\nexport class ControlMap {\n    assignedControls: Map<Key, () => void> = new Map();\n    keyToEventType: Map<Key, EventType> = new Map();\n\n    keyToKeyPressState: Map<Key, KeyPressState> = new Map();\n\n    add(params: ControlParams) {\n        this.assignedControls.set(params.key, params.func);\n        CONTROLS.addAssignedControl(params.key, params.name);\n        this.keyToEventType.set(params.key, params.eventType);\n\n        if (params.eventType === EventType.KeyPress) {\n            this.keyToKeyPressState.set(\n                params.key,\n                CONTROLS.isKeyDown(params.key) ? KeyPressState.NOT_STARTED\n                    : KeyPressState.READY);\n        }\n    }\n\n    remove(key: Key): void {\n        CONTROLS.removeAssignedControl(key);\n        this.assignedControls.delete(key);\n        this.keyToEventType.delete(key);\n    }\n\n    clear(): void {\n        for (let key of this.assignedControls.keys()) {\n            CONTROLS.removeAssignedControl(key);\n        }\n        this.assignedControls.clear();\n        this.keyToEventType.clear();\n    }\n\n    check(): void {\n        for (let key of this.assignedControls.keys()) {\n            const eventType = this.keyToEventType.get(key);\n            const isKeyDown = CONTROLS.isKeyDown(key);\n            if (eventType === EventType.KeyDown && isKeyDown\n                || eventType === EventType.KeyUp && !isKeyDown) {\n                this.assignedControls.get(key)!();\n            } else if (eventType === EventType.KeyPress) {\n                const currentState = this.keyToKeyPressState.get(key);\n                if (isKeyDown) {\n                    if (currentState === KeyPressState.READY) {\n                        this.keyToKeyPressState.set(key, KeyPressState.DOWN);\n                    }\n                } else {\n                    switch (currentState) {\n                        case KeyPressState.DOWN:\n                            this.assignedControls.get(key)!();\n                            this.keyToKeyPressState.set(\n                                key, KeyPressState.READY);\n                            break;\n                        case KeyPressState.NOT_STARTED:\n                            this.keyToKeyPressState.set(\n                                key, KeyPressState.READY);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nclass Controls {\n\n    /** Value is true if Key is pressed. */\n    private readonly keyMap: Map<Key, boolean> = new Map();\n\n    /** Key to action it's bound to. */\n    private readonly assignedControlMap: Map<Key, string> = new Map();\n\n    private mouseCanvasCoords: Point = new Point(0, 0);\n    private isMouseDownInternal: boolean = false;\n    private hasClickInternal: boolean = false;\n\n    constructor() {\n        const allKeys = Object.keys(Key)\n            .filter((key) => !isNaN(Number(Key[key])));\n        for (const key of allKeys) {\n            this.keyMap.set(Key[key], false);\n        }\n        document.onkeydown = (e: KeyboardEvent) => {\n            this.keyMap.set(e.keyCode, true);\n        };\n        document.onkeyup = (e: KeyboardEvent) => {\n            this.keyMap.set(e.keyCode, false);\n        };\n    }\n\n    initMouseControls(canvas: HTMLCanvasElement): void {\n        const isPointInCanvas = (pt: Point): boolean => {\n            return pt.x >= 0 && pt.x <= RENDER_SETTINGS.canvasWidth\n                && pt.y >= 0 && pt.y <= RENDER_SETTINGS.canvasHeight;\n        };\n        canvas.onmousemove = (event: MouseEvent) => {\n            const canvasRect = canvas.getBoundingClientRect();\n            const canvasCoords = new Point(\n                event.clientX - canvasRect.left,\n                event.clientY - canvasRect.top);\n            if (isPointInCanvas(canvasCoords)) {\n                this.mouseCanvasCoords = canvasCoords;\n            }\n        };\n        canvas.onmousedown = (event: MouseEvent) => {\n            this.isMouseDownInternal = true;\n        };\n        canvas.onmouseup = (event: MouseEvent) => {\n            this.isMouseDownInternal = false;\n        };\n        canvas.onclick = (event: MouseEvent) => {\n            this.hasClickInternal = true;\n        };\n    }\n\n    hasClick(): boolean {\n        return this.hasClickInternal;\n    }\n\n    handleClick(): Point {\n        if (!this.hasClick()) {\n            throw new Error(\n                `Must check hasClick before handleClick, ` +\n                `or click already handled.`);\n        }\n        this.hasClickInternal = false;\n        return this.mouseCanvasCoords;\n    }\n\n    getMouseCanvasCoords(): Point {\n        return this.mouseCanvasCoords;\n    }\n\n    isMouseDown(): boolean {\n        return this.isMouseDownInternal;\n    }\n\n    isKeyDown(key: Key): boolean {\n        const isDown = this.keyMap.get(key);\n        if (isDown == null) {\n            throw new Error(\n                `Called isKeyDown for unmapped key: ` +\n                `${this.getStringForKey(key)}`);\n        }\n        return isDown;\n    }\n\n    addAssignedControl(key: Key, action: string): void {\n        if (this.assignedControlMap.has(key)) {\n            throw new Error(`Double-bound a control: ${key}`);\n        }\n        this.assignedControlMap.set(key, action);\n        if (!this.keyMap.has(key)) {\n            this.keyMap.set(key, false);\n        }\n    }\n\n    removeAssignedControl(key: Key): void {\n        if (!this.assignedControlMap.has(key)) {\n            throw new Error('Removing unassigned control');\n        }\n        this.assignedControlMap.delete(key);\n    }\n\n    getAssignedControlMap(): Map<Key, string> {\n        return this.assignedControlMap;\n    }\n\n    getStringForKey(key: Key): string {\n        switch (key) {\n            case Key.SHIFT:\n                return 'Shift';\n            case Key.A:\n                return 'A';\n            case Key.B:\n                return 'B';\n            case Key.C:\n                return 'C';\n            case Key.D:\n                return 'D';\n            case Key.E:\n                return 'E';\n            case Key.F:\n                return 'F';\n            case Key.G:\n                return 'G';\n            case Key.H:\n                return 'H';\n            case Key.I:\n                return 'I';\n            case Key.J:\n                return 'J';\n            case Key.K:\n                return 'K';\n            case Key.L:\n                return 'L';\n            case Key.M:\n                return 'M';\n            case Key.N:\n                return 'N';\n            case Key.O:\n                return 'O';\n            case Key.P:\n                return 'P';\n            case Key.Q:\n                return 'Q';\n            case Key.R:\n                return 'R';\n            case Key.S:\n                return 'S';\n            case Key.T:\n                return 'T';\n            case Key.U:\n                return 'U';\n            case Key.V:\n                return 'V';\n            case Key.W:\n                return 'W';\n            case Key.X:\n                return 'X';\n            case Key.Y:\n                return 'Y';\n            case Key.Z:\n                return 'Z';\n            case Key.ONE:\n                return '1';\n            case Key.TWO:\n                return '2';\n            case Key.THREE:\n                return '3';\n            case Key.FOUR:\n                return '4';\n            case Key.FIVE:\n                return '5';\n            case Key.SIX:\n                return '6';\n            case Key.SEVEN:\n                return '7';\n            case Key.EIGHT:\n                return '8';\n            case Key.NINE:\n                return '9';\n            case Key.ZERO:\n                return '0';\n            case Key.SPACE:\n                return 'Space';\n            case Key.QUESTION_MARK:\n                return '?';\n            case Key.LEFT_ARROW:\n                return 'Left arrow';\n            case Key.UP_ARROW:\n                return 'Up arrow';\n            case Key.RIGHT_ARROW:\n                return 'Right arrow';\n            case Key.DOWN_ARROW:\n                return 'Down arrow';\n            default:\n                throw new Error(\"Need to add string for Key\");\n        }\n    }\n}\n\nexport enum Key {\n    ENTER = 13,\n    SHIFT = 16,\n    SPACE = 32,\n\n    LEFT_ARROW = 37,\n    UP_ARROW = 38,\n    RIGHT_ARROW = 39,\n    DOWN_ARROW = 40,\n\n    ONE = 49,\n    TWO = 50,\n    THREE = 51,\n    FOUR = 52,\n    FIVE = 53,\n    SIX = 54,\n    SEVEN = 55,\n    EIGHT = 56,\n    NINE = 57,\n    ZERO = 58,\n\n    A = 65,\n    B = 66,\n    C = 67,\n    D = 68,\n    E = 69,\n    F = 70,\n    G = 71,\n    H = 72,\n    I = 73,\n    J = 74,\n    K = 75,\n    L = 76,\n    M = 77,\n    N = 78,\n    O = 79,\n    P = 80,\n    Q = 81,\n    R = 82,\n    S = 83,\n    T = 84,\n    U = 85,\n    V = 86,\n    W = 87,\n    X = 88,\n    Y = 89,\n    Z = 90,\n\n    // TODO - this is actually backwards slash...\n    QUESTION_MARK = 191,\n}\n\nexport const numberToKey = new Map<number, Key>([\n    [1, Key.ONE],\n    [2, Key.TWO],\n    [3, Key.THREE],\n    [4, Key.FOUR],\n    [5, Key.FIVE],\n    [6, Key.SIX],\n    [7, Key.SEVEN],\n    [8, Key.EIGHT],\n    [9, Key.NINE],\n]);\n\nexport const numberToOrdinal = new Map<number, string>([\n    [1, '1st'],\n    [2, '2nd'],\n    [3, '3rd'],\n    [4, '4th'],\n    [5, '5th'],\n    [6, '6th'],\n    [7, '7th'],\n    [8, '8th'],\n    [9, '9th'],\n]);\n\nexport const CONTROLS = new Controls();","import { Point } from './point';\n\nexport const UP: Point = new Point(0, -1);\nexport const DOWN: Point = new Point(0, 1);\nexport const LEFT: Point = new Point(-1, 0);\nexport const RIGHT: Point = new Point(1, 0);\n\nexport function rotateClockwise(direction: Point): Point {\n    switch (direction) {\n        case UP:\n            return RIGHT;\n        case RIGHT:\n            return DOWN;\n        case DOWN:\n            return LEFT;\n        case LEFT:\n            return UP;\n    }\n    throw new Error(`This is a 2d game template, not 3d!`);\n}\n\nexport function rotateCounterClockwise(direction: Point): Point {\n    switch (direction) {\n        case UP:\n            return LEFT;\n        case LEFT:\n            return DOWN;\n        case DOWN:\n            return RIGHT;\n        case RIGHT:\n            return UP;\n    }\n    throw new Error(`This is a 2d game template, not 3d!`);\n}","import { Point } from 'src/app/math/point';\nimport { UP, DOWN, LEFT, RIGHT } from 'src/app/math/direction';\nimport { RENDER_SETTINGS } from 'src/app/render_settings';\n\n/** \n * Constants and utilities for a grid of tiles. \n * Does not/should not store 'map' data (state).\n */\nexport class Grid {\n\n    static readonly BUTTON_PANE_WIDTH = 240;\n    static readonly BUTTON_PANE_HEIGHT = RENDER_SETTINGS.canvasHeight;\n    static readonly GAME_WIDTH =\n        RENDER_SETTINGS.canvasWidth - Grid.BUTTON_PANE_WIDTH;\n    static readonly GAME_HEIGHT = RENDER_SETTINGS.canvasHeight;\n    static readonly TILE_SIZE = 40;\n    static readonly TILES_WIDE = Grid.GAME_WIDTH / Grid.TILE_SIZE;\n    static readonly TILES_TALL = Grid.GAME_HEIGHT / Grid.TILE_SIZE;\n    static readonly HALF_TILE =\n        new Point(Grid.TILE_SIZE / 2, Grid.TILE_SIZE / 2);\n\n    static getCanvasFromTileCoords(tileCoords: Point): Point {\n        return new Point(\n            tileCoords.x * Grid.TILE_SIZE,\n            tileCoords.y * Grid.TILE_SIZE);\n    }\n\n    static getTileFromCanvasCoords(canvasCoords: Point): Point {\n        return new Point(\n            Math.floor(canvasCoords.x / Grid.TILE_SIZE),\n            Math.floor(canvasCoords.y / Grid.TILE_SIZE));\n    }\n\n    static inbounds(tileCoords: Point): boolean {\n        return tileCoords.x >= 0 && tileCoords.x < Grid.TILES_WIDE &&\n            tileCoords.y >= 0 && tileCoords.y < Grid.TILES_TALL;\n    }\n\n    static getAdjacentTiles(tileCoords: Point): Point[] {\n        const result: Point[] = [];\n\n        const upAdjacent = tileCoords.add(UP);\n        const downAdjacent = tileCoords.add(DOWN);\n        const leftAdjacent = tileCoords.add(LEFT);\n        const rightAdjacent = tileCoords.add(RIGHT);\n\n        if (Grid.inbounds(upAdjacent)) result.push(upAdjacent);\n        if (Grid.inbounds(downAdjacent)) result.push(downAdjacent);\n        if (Grid.inbounds(leftAdjacent)) result.push(leftAdjacent);\n        if (Grid.inbounds(rightAdjacent)) result.push(rightAdjacent);\n\n        return result;\n    }\n}\n\ninterface QueuedTile {\n    depth: number;\n    coords: Point;\n}\n\nexport function bfs(params: {\n    startTile: Point;\n    maxDepth: number;\n    isAvailable: (tile: Point) => boolean;\n    canGoThrough: (tile: Point) => boolean;\n}): Point[] {\n\n    const { startTile, maxDepth, isAvailable, canGoThrough } = params;\n    const availableTiles: Map<string, Point> = new Map();\n    const queue: QueuedTile[] =\n        Grid.getAdjacentTiles(startTile)\n            .concat(startTile)\n            .map((tile) => {\n                return {\n                    depth: 1,\n                    coords: tile,\n                };\n            });\n    while (queue.length) {\n        const queuedTile = queue.shift()!;\n        if (queuedTile.depth > maxDepth || !canGoThrough(queuedTile.coords)) {\n            continue;\n        }\n        if (isAvailable(queuedTile.coords)) {\n            availableTiles.set(queuedTile.coords.toString(), queuedTile.coords);\n        }\n        for (const adjacentTile of Grid.getAdjacentTiles(queuedTile.coords)) {\n            if ([...availableTiles.values()]\n                .find((tile) => tile.equals(adjacentTile))) continue;\n            queue.push({\n                depth: queuedTile.depth + 1,\n                coords: adjacentTile,\n            });\n        }\n    }\n\n    return [...availableTiles.values()];\n}\n\ninterface PathedTile {\n    parent: Point;\n    coords: Point;\n}\n\nexport function pathTo(params: {\n    startTile: Point;\n    endTile: Point;\n    isAvailable: (tile: Point) => boolean;\n    canGoThrough: (tile: Point) => boolean;\n}): Point[] {\n\n    const { startTile, endTile, isAvailable, canGoThrough } = params;\n    const pathedTiles: Map<string, PathedTile> = new Map();\n    const queue: PathedTile[] =\n        [startTile]\n            .map((tile) => {\n                return {\n                    parent: startTile,\n                    coords: tile,\n                };\n            });\n    let hasFoundEnd = false;\n    while (!hasFoundEnd) {\n        const queuedTile = queue.shift()!;\n        if (!canGoThrough(queuedTile.coords)) {\n            continue;\n        }\n        if (isAvailable(queuedTile.coords)\n            && !pathedTiles.has(queuedTile.coords.toString())) {\n            pathedTiles.set(queuedTile.coords.toString(), queuedTile);\n        }\n        if (queuedTile.coords.equals(endTile)) {\n            hasFoundEnd = true;\n            break;\n        }\n        for (const adjacentTile of Grid.getAdjacentTiles(queuedTile.coords)) {\n            const alreadyVisitedAdjacentTile =\n                pathedTiles.has(adjacentTile.toString());\n            const alreadyQueued =\n                queue.find((pathed) => pathed.coords.equals(adjacentTile)) != null;\n            if (!alreadyVisitedAdjacentTile\n                && !alreadyQueued && isAvailable(adjacentTile)) {\n                queue.push({\n                    parent: queuedTile.coords,\n                    coords: adjacentTile,\n                });\n            }\n        }\n    }\n\n    const getPathedTile = (tile: Point): PathedTile => {\n        return [...pathedTiles.values()].find((pathedTile: PathedTile) => {\n            return pathedTile.coords.equals(tile);\n        })!;\n    };\n    const endPathedTile = getPathedTile(endTile);\n    let current = endPathedTile;\n    const path: Point[] = [];\n    while (!current.coords.equals(startTile)) {\n        path.push(current.coords);\n        current = getPathedTile(current.parent);\n    }\n    return path.reverse();\n}\n\n/** \n * Returns tile coordinates that are intersected by the line \n * from the center of tile A to the center of tile b, excluding A and B. \n * If a and b are adjacent (manhattanDistance(a, b) == 1), returns [].\n * If a=(0, 0) and b=(2, 1), returns [(0, 1), (1, 1)].\n */\nexport function getTilesOnLineBetween(a: Point, b: Point): Point[] {\n    // I feel like there's a more direct way of figuring this out...\n    // But I couldn't figure it out. This works though \\_()_/\n\n    let points: Point[] = [];\n\n    // Add .5 to the endpoints because we actually want to go \n    // from tile center to tile center.\n    const halfTileCoord = new Point(.5, .5);\n    const aPlusHalf = a.add(halfTileCoord);\n    const bPlusHalf = b.add(halfTileCoord);\n    const aToBnotNorm = b.subtract(a);\n\n    const aToB = aToBnotNorm.normalize().multiplyScaler(.25);\n    const tileAtPt = (pt: Point) => {\n        return new Point(Math.floor(pt.x), Math.floor(pt.y));\n    };\n\n    // Move from a to b using (half the) normalized direction vector.\n    // Add tiles until b is reached.\n    let curPt = aPlusHalf.add(aToB);\n    const maxIters = Math.max(Grid.TILES_TALL, Grid.TILES_WIDE);\n    let iters = 0;\n    while (!tileAtPt(curPt).equals(b) && iters < maxIters) {\n        points.push(tileAtPt(curPt));\n        curPt = curPt.add(aToB);\n        iters++;\n    }\n\n    const pointsStrSet = new Set();\n    const deduped: Point[] = [];\n\n    // Make sure A and B weren't accidentally included. Mainly A...\n    // And de-dupe in case same tile was added twice in a row.\n    points.forEach((p: Point) => {\n        const pString = p.toString();\n        if (pointsStrSet.has(pString) || p.equals(a) || p.equals(b)) {\n            return;\n        }\n        pointsStrSet.add(pString);\n        deduped.push(p);\n    });\n    return deduped;\n}\n","/** All values expected to be CSS color strings. */\nexport interface Theme {\n    /* Gameplay/level creation colors. */\n    readonly gridBackgroundColor: string;\n    readonly gridLineColor: string;\n    readonly hudTextColor: string;\n    readonly characterTextColor: string;\n    readonly fogColor: string;\n\n    readonly obstacleColor: string;\n    readonly flagPoleColor: string;\n    readonly redFlagColor: string;\n    readonly blueFlagColor: string;\n\n    /** Color for red squad members when they can move/take action. */\n    readonly redCharacterReadyColor: string;\n    /** Color for blue squad members when they can move/take action. */\n    readonly blueCharacterReadyColor: string;\n    /** Color for red squad members when their turn is done. */\n    readonly redCharacterDoneColor: string;\n    /** Color for blue squad members when their turn is done. */\n    readonly blueCharacterDoneColor: string;\n\n    readonly selectedCharacterOutlineColor: string;\n    readonly availableForMovementColor: string;\n    readonly emptyCellHoverColor: string;\n\n    readonly projectileTrailColor: string;\n    readonly remainingHealthBarColor: string;\n    readonly lostHealthBarColor: string;\n\n    /* UI colors. */\n    readonly uiBackgroundColor: string;\n    readonly buttonTextColor: string;\n    readonly buttonBackgroundColor: string;\n}\n\nexport const THEME: Theme = {\n    gridBackgroundColor: '#959aa3',\n    gridLineColor: '#1560e8',\n    characterTextColor: '#614447',\n    hudTextColor: '#edb951',\n    fogColor: '#0a0a0a88',\n\n    obstacleColor: '#4c6e47',\n    flagPoleColor: '#7a5f3e',\n    redFlagColor: '#e34055',\n    blueFlagColor: '#3d7cd4',\n\n    redCharacterReadyColor: '#e34055',\n    blueCharacterReadyColor: '#3d7cd4',\n    redCharacterDoneColor: '#b05662',\n    blueCharacterDoneColor: '#547199',\n\n    selectedCharacterOutlineColor: '#000000',\n    availableForMovementColor: '#b8b6a5',\n    emptyCellHoverColor: '#d9d7bf',\n\n    projectileTrailColor: '#e8e1d8',\n    remainingHealthBarColor: '#00FF00',\n    lostHealthBarColor: '#FF0000',\n\n    uiBackgroundColor: '#959aa3',\n    buttonTextColor: '#1560e8',\n    buttonBackgroundColor: '#f7c25e',\n};\n\nconst a_nice_yellow = '#f7c25e';","export enum MatchType {\n    PLAYER_VS_PLAYER_LOCAL,\n    PLAYER_VS_AI,\n    AI_VS_AI,\n}\n\nexport enum AiDifficulty {\n    WEAK = 'Weak',\n    MEDIUM = 'Medium',\n    STRONG = 'Strong',\n}\n\nexport interface GameSettings {\n    matchType: MatchType;\n    teamIndexToSquadSize: Map<number, number>;\n    aiDifficulty: AiDifficulty\n    /** \n     * Manhattan distance from flag that characters \n     * can be spawned upon game start. \n     */\n    maxSpawnDistanceFromFlag: number;\n    numTeams: number;\n    hasFogOfWar: boolean;\n    hasSpawners: boolean;\n}\n\nconst EQUAL_DEFAULT_SQUAD_SIZE = 4;\n\nexport const DEFAULT_GAME_SETTINGS: GameSettings = {\n    matchType: MatchType.PLAYER_VS_PLAYER_LOCAL,\n    teamIndexToSquadSize: new Map([\n        [0, EQUAL_DEFAULT_SQUAD_SIZE],\n        [1, EQUAL_DEFAULT_SQUAD_SIZE],\n    ]),\n    aiDifficulty: AiDifficulty.WEAK,\n    maxSpawnDistanceFromFlag: 8,\n    numTeams: 2,\n    hasFogOfWar: false,\n    hasSpawners: false,\n}","import { Point } from 'src/app/math/point';\n\ninterface SerializedPoint {\n    x: number;\n    y: number;\n}\n\nexport interface LevelData {\n    redFlag: SerializedPoint;\n    blueFlag: SerializedPoint;\n    obstacles: SerializedPoint[];\n}\n\n// TODO - custom game settings with level\nexport interface Level {\n    name: string;\n    data: LevelData;\n    aiSpawner: SerializedPoint;\n}\n\n\nconst blank: Level = {\n    name: 'Blank',\n    data: { \"redFlag\": { \"x\": 0, \"y\": 8 }, \"blueFlag\": { \"x\": 19, \"y\": 8 }, \"obstacles\": [] },\n    aiSpawner: { \"x\": 0, \"y\": 12 },\n};\n\nconst diagonal: Level = {\n    name: 'Diagonal',\n    data: {\n        redFlag: { x: 0, y: 19 },\n        blueFlag: { x: 19, y: 0 },\n        obstacles: [\n            { x: 16, y: 18 },\n            { x: 16, y: 17 },\n            { x: 16, y: 16 },\n            { x: 17, y: 16 },\n            { x: 18, y: 16 },\n            { x: 1, y: 3 },\n            { x: 2, y: 3 },\n            { x: 3, y: 3 },\n            { x: 3, y: 2 },\n            { x: 3, y: 1 },\n            { x: 0, y: 6 },\n            { x: 1, y: 6 },\n            { x: 2, y: 6 },\n            { x: 3, y: 6 },\n            { x: 6, y: 0 },\n            { x: 6, y: 1 },\n            { x: 6, y: 2 },\n            { x: 6, y: 3 },\n            { x: 6, y: 6 },\n            { x: 6, y: 7 },\n            { x: 6, y: 8 },\n            { x: 6, y: 9 },\n            { x: 7, y: 6 },\n            { x: 8, y: 6 },\n            { x: 9, y: 6 },\n            { x: 13, y: 19 },\n            { x: 13, y: 18 },\n            { x: 13, y: 17 },\n            { x: 13, y: 16 },\n            { x: 19, y: 13 },\n            { x: 18, y: 13 },\n            { x: 17, y: 13 },\n            { x: 16, y: 13 },\n            { x: 13, y: 13 },\n            { x: 13, y: 12 },\n            { x: 13, y: 11 },\n            { x: 13, y: 10 },\n            { x: 12, y: 13 },\n            { x: 11, y: 13 },\n            { x: 10, y: 13 },\n            { x: 10, y: 9 },\n            { x: 10, y: 10 },\n            { x: 9, y: 10 },\n            { x: 9, y: 9 },\n            { x: 13, y: 6 },\n            { x: 13, y: 5 },\n            { x: 13, y: 4 },\n            { x: 14, y: 6 },\n            { x: 15, y: 6 },\n            { x: 6, y: 13 },\n            { x: 6, y: 14 },\n            { x: 6, y: 15 },\n            { x: 5, y: 13 },\n            { x: 4, y: 13 },\n            { x: 3, y: 16 },\n            { x: 2, y: 16 },\n            { x: 2, y: 17 },\n            { x: 3, y: 17 },\n            { x: 16, y: 3 },\n            { x: 16, y: 2 },\n            { x: 17, y: 2 },\n            { x: 17, y: 3 },\n            { x: 3, y: 9 },\n            { x: 3, y: 10 },\n            { x: 9, y: 3 },\n            { x: 10, y: 3 },\n            { x: 10, y: 16 },\n            { x: 9, y: 16 },\n            { x: 16, y: 10 },\n            { x: 16, y: 9 },\n            { x: 17, y: 10 },\n            { x: 10, y: 17 },\n            { x: 2, y: 9 },\n            { x: 9, y: 2 },\n            { x: 6, y: 19 },\n            { x: 6, y: 18 },\n            { x: 1, y: 13 },\n            { x: 0, y: 13 },\n            { x: 13, y: 1 },\n            { x: 13, y: 0 },\n            { x: 18, y: 6 },\n            { x: 19, y: 6 }]\n    },\n    aiSpawner: { \"x\": 1, \"y\": 18 },\n};\n\nconst horizontal: Level = {\n    name: 'Horizontal',\n    data: { \"redFlag\": { \"x\": 10, \"y\": 19 }, \"blueFlag\": { \"x\": 9, \"y\": 0 }, \"obstacles\": [{ \"x\": 2, \"y\": 17 }, { \"x\": 3, \"y\": 17 }, { \"x\": 5, \"y\": 17 }, { \"x\": 6, \"y\": 17 }, { \"x\": 7, \"y\": 17 }, { \"x\": 10, \"y\": 17 }, { \"x\": 13, \"y\": 17 }, { \"x\": 14, \"y\": 17 }, { \"x\": 17, \"y\": 17 }, { \"x\": 8, \"y\": 17 }, { \"x\": 9, \"y\": 17 }, { \"x\": 11, \"y\": 17 }, { \"x\": 12, \"y\": 17 }, { \"x\": 16, \"y\": 17 }, { \"x\": 17, \"y\": 2 }, { \"x\": 16, \"y\": 2 }, { \"x\": 14, \"y\": 2 }, { \"x\": 13, \"y\": 2 }, { \"x\": 12, \"y\": 2 }, { \"x\": 11, \"y\": 2 }, { \"x\": 10, \"y\": 2 }, { \"x\": 9, \"y\": 2 }, { \"x\": 8, \"y\": 2 }, { \"x\": 7, \"y\": 2 }, { \"x\": 6, \"y\": 2 }, { \"x\": 5, \"y\": 2 }, { \"x\": 3, \"y\": 2 }, { \"x\": 2, \"y\": 2 }, { \"x\": 3, \"y\": 5 }, { \"x\": 4, \"y\": 5 }, { \"x\": 5, \"y\": 5 }, { \"x\": 14, \"y\": 5 }, { \"x\": 15, \"y\": 5 }, { \"x\": 16, \"y\": 5 }, { \"x\": 14, \"y\": 15 }, { \"x\": 15, \"y\": 15 }, { \"x\": 16, \"y\": 15 }, { \"x\": 4, \"y\": 15 }, { \"x\": 5, \"y\": 15 }, { \"x\": 3, \"y\": 15 }, { \"x\": 6, \"y\": 15 }, { \"x\": 13, \"y\": 15 }, { \"x\": 13, \"y\": 5 }, { \"x\": 6, \"y\": 5 }, { \"x\": 1, \"y\": 9 }, { \"x\": 1, \"y\": 10 }, { \"x\": 0, \"y\": 9 }, { \"x\": 1, \"y\": 8 }, { \"x\": 19, \"y\": 9 }, { \"x\": 18, \"y\": 9 }, { \"x\": 18, \"y\": 8 }, { \"x\": 18, \"y\": 10 }, { \"x\": 2, \"y\": 8 }, { \"x\": 17, \"y\": 8 }, { \"x\": 18, \"y\": 11 }, { \"x\": 1, \"y\": 11 }, { \"x\": 4, \"y\": 11 }, { \"x\": 5, \"y\": 11 }, { \"x\": 6, \"y\": 11 }, { \"x\": 7, \"y\": 11 }, { \"x\": 8, \"y\": 11 }, { \"x\": 8, \"y\": 12 }, { \"x\": 11, \"y\": 12 }, { \"x\": 11, \"y\": 11 }, { \"x\": 12, \"y\": 11 }, { \"x\": 13, \"y\": 11 }, { \"x\": 15, \"y\": 11 }, { \"x\": 14, \"y\": 11 }, { \"x\": 9, \"y\": 9 }, { \"x\": 10, \"y\": 9 }, { \"x\": 11, \"y\": 9 }, { \"x\": 8, \"y\": 9 }, { \"x\": 9, \"y\": 15 }, { \"x\": 10, \"y\": 15 }, { \"x\": 9, \"y\": 5 }, { \"x\": 10, \"y\": 5 }, { \"x\": 8, \"y\": 7 }, { \"x\": 7, \"y\": 7 }, { \"x\": 6, \"y\": 7 }, { \"x\": 11, \"y\": 7 }, { \"x\": 12, \"y\": 7 }, { \"x\": 13, \"y\": 7 }] },\n\n    aiSpawner: { \"x\": 10, \"y\": 18 },\n};\n\nconst paths: Level = {\n    name: 'Paths',\n    data: { \"redFlag\": { \"x\": 0, \"y\": 19 }, \"blueFlag\": { \"x\": 19, \"y\": 0 }, \"obstacles\": [{ \"x\": 17, \"y\": 1 }, { \"x\": 17, \"y\": 2 }, { \"x\": 18, \"y\": 2 }, { \"x\": 1, \"y\": 17 }, { \"x\": 2, \"y\": 17 }, { \"x\": 2, \"y\": 18 }, { \"x\": 1, \"y\": 16 }, { \"x\": 3, \"y\": 18 }, { \"x\": 16, \"y\": 1 }, { \"x\": 18, \"y\": 3 }, { \"x\": 16, \"y\": 5 }, { \"x\": 15, \"y\": 6 }, { \"x\": 14, \"y\": 7 }, { \"x\": 13, \"y\": 8 }, { \"x\": 14, \"y\": 3 }, { \"x\": 13, \"y\": 4 }, { \"x\": 12, \"y\": 5 }, { \"x\": 11, \"y\": 6 }, { \"x\": 10, \"y\": 7 }, { \"x\": 10, \"y\": 6 }, { \"x\": 11, \"y\": 5 }, { \"x\": 12, \"y\": 4 }, { \"x\": 13, \"y\": 3 }, { \"x\": 14, \"y\": 8 }, { \"x\": 15, \"y\": 7 }, { \"x\": 16, \"y\": 6 }, { \"x\": 13, \"y\": 9 }, { \"x\": 12, \"y\": 9 }, { \"x\": 3, \"y\": 14 }, { \"x\": 5, \"y\": 16 }, { \"x\": 6, \"y\": 16 }, { \"x\": 3, \"y\": 13 }, { \"x\": 4, \"y\": 13 }, { \"x\": 6, \"y\": 15 }, { \"x\": 7, \"y\": 15 }, { \"x\": 7, \"y\": 14 }, { \"x\": 4, \"y\": 12 }, { \"x\": 8, \"y\": 14 }, { \"x\": 8, \"y\": 13 }, { \"x\": 5, \"y\": 12 }, { \"x\": 5, \"y\": 11 }, { \"x\": 6, \"y\": 11 }, { \"x\": 6, \"y\": 10 }, { \"x\": 9, \"y\": 13 }, { \"x\": 9, \"y\": 12 }, { \"x\": 7, \"y\": 10 }, { \"x\": 9, \"y\": 10 }, { \"x\": 9, \"y\": 9 }, { \"x\": 10, \"y\": 9 }, { \"x\": 10, \"y\": 10 }, { \"x\": 16, \"y\": 9 }, { \"x\": 7, \"y\": 7 }, { \"x\": 7, \"y\": 6 }, { \"x\": 6, \"y\": 6 }, { \"x\": 6, \"y\": 5 }, { \"x\": 5, \"y\": 5 }, { \"x\": 12, \"y\": 12 }, { \"x\": 12, \"y\": 13 }, { \"x\": 13, \"y\": 13 }, { \"x\": 13, \"y\": 14 }, { \"x\": 14, \"y\": 14 }, { \"x\": 14, \"y\": 15 }, { \"x\": 15, \"y\": 15 }, { \"x\": 5, \"y\": 4 }, { \"x\": 4, \"y\": 4 }, { \"x\": 15, \"y\": 18 }, { \"x\": 16, \"y\": 18 }, { \"x\": 16, \"y\": 17 }, { \"x\": 17, \"y\": 17 }, { \"x\": 17, \"y\": 16 }, { \"x\": 18, \"y\": 16 }, { \"x\": 18, \"y\": 15 }, { \"x\": 2, \"y\": 2 }, { \"x\": 3, \"y\": 2 }, { \"x\": 3, \"y\": 1 }, { \"x\": 4, \"y\": 1 }, { \"x\": 2, \"y\": 3 }, { \"x\": 1, \"y\": 3 }, { \"x\": 1, \"y\": 4 }, { \"x\": 16, \"y\": 10 }, { \"x\": 17, \"y\": 11 }, { \"x\": 16, \"y\": 12 }, { \"x\": 16, \"y\": 13 }, { \"x\": 3, \"y\": 6 }, { \"x\": 3, \"y\": 7 }, { \"x\": 2, \"y\": 8 }, { \"x\": 3, \"y\": 9 }, { \"x\": 3, \"y\": 10 }, { \"x\": 18, \"y\": 9 }, { \"x\": 19, \"y\": 9 }, { \"x\": 19, \"y\": 8 }, { \"x\": 0, \"y\": 10 }, { \"x\": 1, \"y\": 10 }, { \"x\": 1, \"y\": 11 }, { \"x\": 8, \"y\": 4 }, { \"x\": 7, \"y\": 3 }, { \"x\": 10, \"y\": 3 }, { \"x\": 11, \"y\": 2 }, { \"x\": 12, \"y\": 1 }, { \"x\": 6, \"y\": 2 }, { \"x\": 11, \"y\": 15 }, { \"x\": 12, \"y\": 16 }, { \"x\": 13, \"y\": 17 }, { \"x\": 9, \"y\": 16 }, { \"x\": 8, \"y\": 17 }, { \"x\": 7, \"y\": 18 }, { \"x\": 9, \"y\": 0 }, { \"x\": 10, \"y\": 19 }] },\n\n    aiSpawner: { \"x\": 1, \"y\": 18 },\n};\n\nconst symmetry: Level = {\n    name: 'Symmetry',\n    data: { \"redFlag\": { \"x\": 0, \"y\": 19 }, \"blueFlag\": { \"x\": 19, \"y\": 0 }, \"obstacles\": [{ \"x\": 16, \"y\": 1 }, { \"x\": 16, \"y\": 2 }, { \"x\": 16, \"y\": 3 }, { \"x\": 17, \"y\": 3 }, { \"x\": 18, \"y\": 3 }, { \"x\": 13, \"y\": 0 }, { \"x\": 13, \"y\": 1 }, { \"x\": 13, \"y\": 3 }, { \"x\": 13, \"y\": 2 }, { \"x\": 15, \"y\": 6 }, { \"x\": 16, \"y\": 6 }, { \"x\": 17, \"y\": 6 }, { \"x\": 18, \"y\": 6 }, { \"x\": 19, \"y\": 6 }, { \"x\": 12, \"y\": 7 }, { \"x\": 13, \"y\": 8 }, { \"x\": 11, \"y\": 6 }, { \"x\": 11, \"y\": 5 }, { \"x\": 11, \"y\": 4 }, { \"x\": 11, \"y\": 3 }, { \"x\": 11, \"y\": 2 }, { \"x\": 14, \"y\": 8 }, { \"x\": 15, \"y\": 8 }, { \"x\": 16, \"y\": 8 }, { \"x\": 17, \"y\": 8 }, { \"x\": 19, \"y\": 10 }, { \"x\": 17, \"y\": 10 }, { \"x\": 18, \"y\": 10 }, { \"x\": 16, \"y\": 10 }, { \"x\": 14, \"y\": 10 }, { \"x\": 15, \"y\": 10 }, { \"x\": 13, \"y\": 10 }, { \"x\": 10, \"y\": 9 }, { \"x\": 10, \"y\": 10 }, { \"x\": 9, \"y\": 10 }, { \"x\": 9, \"y\": 9 }, { \"x\": 7, \"y\": 12 }, { \"x\": 8, \"y\": 13 }, { \"x\": 8, \"y\": 14 }, { \"x\": 8, \"y\": 15 }, { \"x\": 8, \"y\": 16 }, { \"x\": 8, \"y\": 17 }, { \"x\": 6, \"y\": 11 }, { \"x\": 5, \"y\": 11 }, { \"x\": 4, \"y\": 11 }, { \"x\": 2, \"y\": 11 }, { \"x\": 3, \"y\": 11 }, { \"x\": 0, \"y\": 13 }, { \"x\": 1, \"y\": 13 }, { \"x\": 2, \"y\": 13 }, { \"x\": 3, \"y\": 13 }, { \"x\": 4, \"y\": 13 }, { \"x\": 6, \"y\": 15 }, { \"x\": 6, \"y\": 16 }, { \"x\": 6, \"y\": 17 }, { \"x\": 6, \"y\": 18 }, { \"x\": 6, \"y\": 19 }, { \"x\": 3, \"y\": 16 }, { \"x\": 2, \"y\": 16 }, { \"x\": 1, \"y\": 16 }, { \"x\": 3, \"y\": 17 }, { \"x\": 3, \"y\": 18 }, { \"x\": 10, \"y\": 13 }, { \"x\": 10, \"y\": 14 }, { \"x\": 10, \"y\": 15 }, { \"x\": 10, \"y\": 16 }, { \"x\": 10, \"y\": 17 }, { \"x\": 10, \"y\": 18 }, { \"x\": 10, \"y\": 19 }, { \"x\": 11, \"y\": 11 }, { \"x\": 12, \"y\": 12 }, { \"x\": 13, \"y\": 13 }, { \"x\": 14, \"y\": 14 }, { \"x\": 12, \"y\": 13 }, { \"x\": 13, \"y\": 12 }, { \"x\": 13, \"y\": 14 }, { \"x\": 14, \"y\": 13 }, { \"x\": 13, \"y\": 15 }, { \"x\": 13, \"y\": 16 }, { \"x\": 14, \"y\": 16 }, { \"x\": 15, \"y\": 16 }, { \"x\": 15, \"y\": 15 }, { \"x\": 16, \"y\": 16 }, { \"x\": 16, \"y\": 15 }, { \"x\": 16, \"y\": 14 }, { \"x\": 15, \"y\": 14 }, { \"x\": 15, \"y\": 13 }, { \"x\": 16, \"y\": 13 }, { \"x\": 14, \"y\": 15 }, { \"x\": 16, \"y\": 17 }, { \"x\": 17, \"y\": 17 }, { \"x\": 17, \"y\": 16 }, { \"x\": 8, \"y\": 8 }, { \"x\": 7, \"y\": 7 }, { \"x\": 6, \"y\": 7 }, { \"x\": 6, \"y\": 6 }, { \"x\": 7, \"y\": 6 }, { \"x\": 6, \"y\": 5 }, { \"x\": 6, \"y\": 4 }, { \"x\": 6, \"y\": 3 }, { \"x\": 5, \"y\": 3 }, { \"x\": 4, \"y\": 3 }, { \"x\": 3, \"y\": 3 }, { \"x\": 3, \"y\": 4 }, { \"x\": 3, \"y\": 5 }, { \"x\": 3, \"y\": 6 }, { \"x\": 4, \"y\": 6 }, { \"x\": 5, \"y\": 6 }, { \"x\": 5, \"y\": 4 }, { \"x\": 4, \"y\": 4 }, { \"x\": 5, \"y\": 5 }, { \"x\": 4, \"y\": 5 }, { \"x\": 3, \"y\": 2 }, { \"x\": 2, \"y\": 3 }, { \"x\": 2, \"y\": 2 }, { \"x\": 0, \"y\": 0 }, { \"x\": 19, \"y\": 19 }, { \"x\": 13, \"y\": 19 }, { \"x\": 19, \"y\": 13 }, { \"x\": 6, \"y\": 0 }, { \"x\": 0, \"y\": 6 }, { \"x\": 6, \"y\": 9 }, { \"x\": 5, \"y\": 9 }, { \"x\": 4, \"y\": 9 }, { \"x\": 3, \"y\": 9 }, { \"x\": 1, \"y\": 9 }, { \"x\": 2, \"y\": 9 }, { \"x\": 0, \"y\": 9 }, { \"x\": 9, \"y\": 6 }, { \"x\": 9, \"y\": 5 }, { \"x\": 9, \"y\": 4 }, { \"x\": 9, \"y\": 3 }, { \"x\": 9, \"y\": 2 }, { \"x\": 9, \"y\": 1 }, { \"x\": 9, \"y\": 0 }] },\n\n    aiSpawner: { \"x\": 2, \"y\": 17 },\n};\n\nconst squares: Level = {\n    name: 'Squares',\n    data: { \"redFlag\": { \"x\": 0, \"y\": 19 }, \"blueFlag\": { \"x\": 19, \"y\": 0 }, \"obstacles\": [{ \"x\": 17, \"y\": 2 }, { \"x\": 16, \"y\": 2 }, { \"x\": 16, \"y\": 3 }, { \"x\": 17, \"y\": 3 }, { \"x\": 12, \"y\": 7 }, { \"x\": 8, \"y\": 10 }, { \"x\": 8, \"y\": 11 }, { \"x\": 9, \"y\": 11 }, { \"x\": 1, \"y\": 17 }, { \"x\": 2, \"y\": 18 }, { \"x\": 2, \"y\": 17 }, { \"x\": 16, \"y\": 1 }, { \"x\": 17, \"y\": 1 }, { \"x\": 18, \"y\": 2 }, { \"x\": 18, \"y\": 3 }, { \"x\": 1, \"y\": 16 }, { \"x\": 2, \"y\": 16 }, { \"x\": 3, \"y\": 16 }, { \"x\": 3, \"y\": 17 }, { \"x\": 3, \"y\": 18 }, { \"x\": 5, \"y\": 14 }, { \"x\": 5, \"y\": 13 }, { \"x\": 5, \"y\": 12 }, { \"x\": 6, \"y\": 12 }, { \"x\": 7, \"y\": 12 }, { \"x\": 7, \"y\": 13 }, { \"x\": 7, \"y\": 14 }, { \"x\": 6, \"y\": 14 }, { \"x\": 6, \"y\": 13 }, { \"x\": 10, \"y\": 8 }, { \"x\": 11, \"y\": 9 }, { \"x\": 11, \"y\": 8 }, { \"x\": 12, \"y\": 6 }, { \"x\": 13, \"y\": 7 }, { \"x\": 13, \"y\": 6 }, { \"x\": 13, \"y\": 5 }, { \"x\": 14, \"y\": 5 }, { \"x\": 14, \"y\": 6 }, { \"x\": 14, \"y\": 7 }, { \"x\": 12, \"y\": 5 }, { \"x\": 12, \"y\": 12 }, { \"x\": 12, \"y\": 13 }, { \"x\": 12, \"y\": 14 }, { \"x\": 13, \"y\": 14 }, { \"x\": 14, \"y\": 14 }, { \"x\": 14, \"y\": 13 }, { \"x\": 14, \"y\": 12 }, { \"x\": 13, \"y\": 12 }, { \"x\": 13, \"y\": 13 }, { \"x\": 13, \"y\": 9 }, { \"x\": 13, \"y\": 10 }, { \"x\": 14, \"y\": 10 }, { \"x\": 14, \"y\": 9 }, { \"x\": 9, \"y\": 13 }, { \"x\": 9, \"y\": 14 }, { \"x\": 10, \"y\": 14 }, { \"x\": 10, \"y\": 13 }, { \"x\": 15, \"y\": 12 }, { \"x\": 15, \"y\": 13 }, { \"x\": 15, \"y\": 14 }, { \"x\": 15, \"y\": 15 }, { \"x\": 14, \"y\": 15 }, { \"x\": 13, \"y\": 15 }, { \"x\": 12, \"y\": 15 }, { \"x\": 13, \"y\": 17 }, { \"x\": 14, \"y\": 17 }, { \"x\": 14, \"y\": 18 }, { \"x\": 13, \"y\": 18 }, { \"x\": 17, \"y\": 13 }, { \"x\": 17, \"y\": 14 }, { \"x\": 18, \"y\": 14 }, { \"x\": 18, \"y\": 13 }, { \"x\": 17, \"y\": 17 }, { \"x\": 17, \"y\": 18 }, { \"x\": 18, \"y\": 18 }, { \"x\": 18, \"y\": 17 }, { \"x\": 7, \"y\": 7 }, { \"x\": 7, \"y\": 6 }, { \"x\": 7, \"y\": 5 }, { \"x\": 7, \"y\": 4 }, { \"x\": 4, \"y\": 4 }, { \"x\": 4, \"y\": 5 }, { \"x\": 4, \"y\": 6 }, { \"x\": 4, \"y\": 7 }, { \"x\": 5, \"y\": 7 }, { \"x\": 6, \"y\": 7 }, { \"x\": 6, \"y\": 6 }, { \"x\": 5, \"y\": 6 }, { \"x\": 6, \"y\": 5 }, { \"x\": 5, \"y\": 5 }, { \"x\": 5, \"y\": 4 }, { \"x\": 6, \"y\": 4 }, { \"x\": 5, \"y\": 9 }, { \"x\": 6, \"y\": 9 }, { \"x\": 6, \"y\": 10 }, { \"x\": 5, \"y\": 10 }, { \"x\": 9, \"y\": 6 }, { \"x\": 10, \"y\": 6 }, { \"x\": 10, \"y\": 5 }, { \"x\": 9, \"y\": 5 }, { \"x\": 6, \"y\": 2 }, { \"x\": 6, \"y\": 1 }, { \"x\": 5, \"y\": 1 }, { \"x\": 5, \"y\": 2 }, { \"x\": 2, \"y\": 5 }, { \"x\": 1, \"y\": 5 }, { \"x\": 1, \"y\": 6 }, { \"x\": 2, \"y\": 6 }, { \"x\": 2, \"y\": 2 }, { \"x\": 1, \"y\": 2 }, { \"x\": 1, \"y\": 1 }, { \"x\": 2, \"y\": 1 }, { \"x\": 9, \"y\": 2 }, { \"x\": 10, \"y\": 2 }, { \"x\": 10, \"y\": 1 }, { \"x\": 9, \"y\": 1 }, { \"x\": 17, \"y\": 9 }, { \"x\": 17, \"y\": 10 }, { \"x\": 18, \"y\": 10 }, { \"x\": 18, \"y\": 9 }, { \"x\": 2, \"y\": 9 }, { \"x\": 1, \"y\": 9 }, { \"x\": 1, \"y\": 10 }, { \"x\": 2, \"y\": 10 }, { \"x\": 9, \"y\": 17 }, { \"x\": 10, \"y\": 17 }, { \"x\": 10, \"y\": 18 }, { \"x\": 9, \"y\": 18 }, { \"x\": 16, \"y\": 5 }, { \"x\": 17, \"y\": 6 }, { \"x\": 18, \"y\": 7 }, { \"x\": 12, \"y\": 1 }, { \"x\": 13, \"y\": 2 }, { \"x\": 14, \"y\": 3 }, { \"x\": 1, \"y\": 12 }, { \"x\": 2, \"y\": 13 }, { \"x\": 3, \"y\": 14 }, { \"x\": 5, \"y\": 16 }, { \"x\": 6, \"y\": 17 }, { \"x\": 7, \"y\": 18 }, { \"x\": 5, \"y\": 19 }, { \"x\": 0, \"y\": 14 }, { \"x\": 19, \"y\": 5 }, { \"x\": 14, \"y\": 0 }, { \"x\": 9, \"y\": 10 }, { \"x\": 10, \"y\": 9 }] },\n\n    aiSpawner: { \"x\": 1, \"y\": 18 },\n};\n\nconst corners: Level = {\n    name: 'Corners',\n    data: { \"redFlag\": { \"x\": 0, \"y\": 19 }, \"blueFlag\": { \"x\": 19, \"y\": 0 }, \"obstacles\": [{ \"x\": 17, \"y\": 1 }, { \"x\": 18, \"y\": 2 }, { \"x\": 14, \"y\": 1 }, { \"x\": 15, \"y\": 1 }, { \"x\": 15, \"y\": 2 }, { \"x\": 18, \"y\": 4 }, { \"x\": 17, \"y\": 4 }, { \"x\": 18, \"y\": 5 }, { \"x\": 15, \"y\": 4 }, { \"x\": 14, \"y\": 4 }, { \"x\": 15, \"y\": 5 }, { \"x\": 12, \"y\": 7 }, { \"x\": 11, \"y\": 7 }, { \"x\": 12, \"y\": 8 }, { \"x\": 4, \"y\": 14 }, { \"x\": 4, \"y\": 15 }, { \"x\": 5, \"y\": 15 }, { \"x\": 1, \"y\": 17 }, { \"x\": 2, \"y\": 18 }, { \"x\": 1, \"y\": 15 }, { \"x\": 1, \"y\": 14 }, { \"x\": 2, \"y\": 15 }, { \"x\": 4, \"y\": 18 }, { \"x\": 4, \"y\": 17 }, { \"x\": 5, \"y\": 18 }, { \"x\": 7, \"y\": 12 }, { \"x\": 7, \"y\": 11 }, { \"x\": 8, \"y\": 12 }, { \"x\": 9, \"y\": 9 }, { \"x\": 10, \"y\": 10 }, { \"x\": 15, \"y\": 16 }, { \"x\": 16, \"y\": 15 }, { \"x\": 18, \"y\": 19 }, { \"x\": 19, \"y\": 18 }, { \"x\": 16, \"y\": 16 }, { \"x\": 19, \"y\": 19 }, { \"x\": 3, \"y\": 3 }, { \"x\": 3, \"y\": 4 }, { \"x\": 4, \"y\": 3 }, { \"x\": 0, \"y\": 1 }, { \"x\": 0, \"y\": 0 }, { \"x\": 1, \"y\": 0 }, { \"x\": 19, \"y\": 16 }, { \"x\": 18, \"y\": 16 }, { \"x\": 19, \"y\": 15 }, { \"x\": 15, \"y\": 19 }, { \"x\": 16, \"y\": 19 }, { \"x\": 16, \"y\": 18 }, { \"x\": 0, \"y\": 3 }, { \"x\": 0, \"y\": 4 }, { \"x\": 1, \"y\": 3 }, { \"x\": 3, \"y\": 6 }, { \"x\": 3, \"y\": 7 }, { \"x\": 4, \"y\": 7 }, { \"x\": 15, \"y\": 12 }, { \"x\": 16, \"y\": 12 }, { \"x\": 16, \"y\": 13 }, { \"x\": 13, \"y\": 16 }, { \"x\": 12, \"y\": 16 }, { \"x\": 12, \"y\": 15 }, { \"x\": 13, \"y\": 18 }, { \"x\": 12, \"y\": 18 }, { \"x\": 12, \"y\": 19 }, { \"x\": 18, \"y\": 13 }, { \"x\": 18, \"y\": 12 }, { \"x\": 19, \"y\": 12 }, { \"x\": 3, \"y\": 1 }, { \"x\": 3, \"y\": 0 }, { \"x\": 4, \"y\": 0 }, { \"x\": 0, \"y\": 7 }, { \"x\": 1, \"y\": 7 }, { \"x\": 1, \"y\": 6 }, { \"x\": 6, \"y\": 1 }, { \"x\": 7, \"y\": 1 }, { \"x\": 7, \"y\": 0 }, { \"x\": 7, \"y\": 3 }, { \"x\": 6, \"y\": 3 }, { \"x\": 7, \"y\": 4 }, { \"x\": 7, \"y\": 6 }, { \"x\": 6, \"y\": 7 }, { \"x\": 12, \"y\": 13 }, { \"x\": 13, \"y\": 12 }, { \"x\": 6, \"y\": 6 }, { \"x\": 13, \"y\": 13 }, { \"x\": 15, \"y\": 10 }, { \"x\": 16, \"y\": 10 }, { \"x\": 15, \"y\": 9 }, { \"x\": 18, \"y\": 10 }, { \"x\": 19, \"y\": 10 }, { \"x\": 19, \"y\": 9 }, { \"x\": 0, \"y\": 10 }, { \"x\": 0, \"y\": 9 }, { \"x\": 1, \"y\": 9 }, { \"x\": 3, \"y\": 9 }, { \"x\": 4, \"y\": 9 }, { \"x\": 4, \"y\": 10 }, { \"x\": 7, \"y\": 15 }, { \"x\": 8, \"y\": 15 }, { \"x\": 8, \"y\": 14 }, { \"x\": 7, \"y\": 17 }, { \"x\": 8, \"y\": 17 }, { \"x\": 8, \"y\": 18 }, { \"x\": 12, \"y\": 2 }, { \"x\": 11, \"y\": 2 }, { \"x\": 11, \"y\": 1 }, { \"x\": 11, \"y\": 4 }, { \"x\": 12, \"y\": 4 }, { \"x\": 11, \"y\": 5 }, { \"x\": 16, \"y\": 7 }, { \"x\": 17, \"y\": 7 }, { \"x\": 17, \"y\": 8 }, { \"x\": 2, \"y\": 11 }, { \"x\": 2, \"y\": 12 }, { \"x\": 3, \"y\": 12 }, { \"x\": 10, \"y\": 13 }, { \"x\": 9, \"y\": 6 }, { \"x\": 9, \"y\": 3 }, { \"x\": 10, \"y\": 16 }] },\n\n    aiSpawner: { \"x\": 1, \"y\": 18 },\n};\n\nconst spotted: Level = {\n    name: 'Spotted',\n    data: { \"redFlag\": { \"x\": 0, \"y\": 19 }, \"blueFlag\": { \"x\": 19, \"y\": 0 }, \"obstacles\": [{ \"x\": 1, \"y\": 1 }, { \"x\": 2, \"y\": 2 }, { \"x\": 3, \"y\": 3 }, { \"x\": 9, \"y\": 9 }, { \"x\": 10, \"y\": 10 }, { \"x\": 11, \"y\": 11 }, { \"x\": 17, \"y\": 17 }, { \"x\": 18, \"y\": 18 }, { \"x\": 8, \"y\": 8 }, { \"x\": 16, \"y\": 16 }, { \"x\": 10, \"y\": 9 }, { \"x\": 11, \"y\": 8 }, { \"x\": 9, \"y\": 10 }, { \"x\": 8, \"y\": 11 }, { \"x\": 6, \"y\": 13 }, { \"x\": 5, \"y\": 14 }, { \"x\": 13, \"y\": 6 }, { \"x\": 14, \"y\": 5 }, { \"x\": 16, \"y\": 3 }, { \"x\": 17, \"y\": 2 }, { \"x\": 3, \"y\": 16 }, { \"x\": 2, \"y\": 17 }, { \"x\": 1, \"y\": 17 }, { \"x\": 2, \"y\": 18 }, { \"x\": 18, \"y\": 2 }, { \"x\": 17, \"y\": 1 }, { \"x\": 13, \"y\": 5 }, { \"x\": 14, \"y\": 6 }, { \"x\": 5, \"y\": 13 }, { \"x\": 6, \"y\": 14 }, { \"x\": 8, \"y\": 16 }, { \"x\": 9, \"y\": 17 }, { \"x\": 11, \"y\": 19 }, { \"x\": 3, \"y\": 11 }, { \"x\": 2, \"y\": 10 }, { \"x\": 0, \"y\": 8 }, { \"x\": 0, \"y\": 7 }, { \"x\": 12, \"y\": 19 }, { \"x\": 11, \"y\": 3 }, { \"x\": 10, \"y\": 2 }, { \"x\": 16, \"y\": 8 }, { \"x\": 17, \"y\": 9 }, { \"x\": 19, \"y\": 11 }, { \"x\": 19, \"y\": 12 }, { \"x\": 8, \"y\": 0 }, { \"x\": 7, \"y\": 0 }, { \"x\": 13, \"y\": 13 }, { \"x\": 14, \"y\": 14 }, { \"x\": 6, \"y\": 6 }, { \"x\": 5, \"y\": 5 }, { \"x\": 4, \"y\": 7 }, { \"x\": 3, \"y\": 8 }, { \"x\": 7, \"y\": 4 }, { \"x\": 8, \"y\": 3 }, { \"x\": 8, \"y\": 4 }, { \"x\": 7, \"y\": 3 }, { \"x\": 4, \"y\": 8 }, { \"x\": 3, \"y\": 7 }, { \"x\": 12, \"y\": 15 }, { \"x\": 11, \"y\": 15 }, { \"x\": 11, \"y\": 16 }, { \"x\": 12, \"y\": 16 }, { \"x\": 15, \"y\": 12 }, { \"x\": 16, \"y\": 12 }, { \"x\": 16, \"y\": 11 }, { \"x\": 15, \"y\": 11 }, { \"x\": 13, \"y\": 10 }, { \"x\": 10, \"y\": 13 }, { \"x\": 6, \"y\": 9 }, { \"x\": 9, \"y\": 6 }, { \"x\": 2, \"y\": 1 }, { \"x\": 1, \"y\": 2 }, { \"x\": 2, \"y\": 3 }, { \"x\": 3, \"y\": 2 }, { \"x\": 16, \"y\": 17 }, { \"x\": 17, \"y\": 18 }, { \"x\": 18, \"y\": 17 }, { \"x\": 17, \"y\": 16 }, { \"x\": 1, \"y\": 7 }, { \"x\": 12, \"y\": 18 }, { \"x\": 18, \"y\": 12 }, { \"x\": 7, \"y\": 1 }, { \"x\": 5, \"y\": 18 }, { \"x\": 6, \"y\": 19 }, { \"x\": 1, \"y\": 14 }, { \"x\": 0, \"y\": 13 }, { \"x\": 18, \"y\": 5 }, { \"x\": 19, \"y\": 6 }, { \"x\": 13, \"y\": 1 }, { \"x\": 12, \"y\": 0 }, { \"x\": 0, \"y\": 5 }, { \"x\": 0, \"y\": 6 }, { \"x\": 1, \"y\": 6 }, { \"x\": 18, \"y\": 13 }, { \"x\": 19, \"y\": 14 }, { \"x\": 19, \"y\": 13 }, { \"x\": 6, \"y\": 0 }, { \"x\": 6, \"y\": 1 }, { \"x\": 5, \"y\": 0 }, { \"x\": 13, \"y\": 18 }, { \"x\": 13, \"y\": 19 }, { \"x\": 14, \"y\": 19 }] },\n\n    aiSpawner: { \"x\": 1, \"y\": 18 },\n};\n\nconst entropy: Level = {\n    name: 'Entropy',\n    data: { \"redFlag\": { \"x\": 0, \"y\": 19 }, \"blueFlag\": { \"x\": 19, \"y\": 0 }, \"obstacles\": [{ \"x\": 16, \"y\": 3 }, { \"x\": 15, \"y\": 5 }, { \"x\": 16, \"y\": 7 }, { \"x\": 13, \"y\": 5 }, { \"x\": 11, \"y\": 3 }, { \"x\": 5, \"y\": 4 }, { \"x\": 5, \"y\": 7 }, { \"x\": 10, \"y\": 10 }, { \"x\": 11, \"y\": 11 }, { \"x\": 8, \"y\": 3 }, { \"x\": 11, \"y\": 6 }, { \"x\": 14, \"y\": 9 }, { \"x\": 13, \"y\": 10 }, { \"x\": 8, \"y\": 6 }, { \"x\": 7, \"y\": 6 }, { \"x\": 6, \"y\": 11 }, { \"x\": 6, \"y\": 13 }, { \"x\": 3, \"y\": 11 }, { \"x\": 2, \"y\": 5 }, { \"x\": 5, \"y\": 5 }, { \"x\": 9, \"y\": 10 }, { \"x\": 10, \"y\": 14 }, { \"x\": 4, \"y\": 10 }, { \"x\": 3, \"y\": 8 }, { \"x\": 0, \"y\": 10 }, { \"x\": 2, \"y\": 14 }, { \"x\": 6, \"y\": 15 }, { \"x\": 6, \"y\": 18 }, { \"x\": 3, \"y\": 18 }, { \"x\": 1, \"y\": 16 }, { \"x\": 0, \"y\": 17 }, { \"x\": 5, \"y\": 18 }, { \"x\": 4, \"y\": 14 }, { \"x\": 4, \"y\": 13 }, { \"x\": 4, \"y\": 17 }, { \"x\": 12, \"y\": 16 }, { \"x\": 13, \"y\": 13 }, { \"x\": 10, \"y\": 17 }, { \"x\": 8, \"y\": 17 }, { \"x\": 8, \"y\": 13 }, { \"x\": 11, \"y\": 14 }, { \"x\": 11, \"y\": 16 }, { \"x\": 9, \"y\": 19 }, { \"x\": 16, \"y\": 18 }, { \"x\": 14, \"y\": 14 }, { \"x\": 15, \"y\": 16 }, { \"x\": 14, \"y\": 18 }, { \"x\": 18, \"y\": 15 }, { \"x\": 16, \"y\": 12 }, { \"x\": 18, \"y\": 13 }, { \"x\": 15, \"y\": 13 }, { \"x\": 15, \"y\": 11 }, { \"x\": 16, \"y\": 10 }, { \"x\": 10, \"y\": 7 }, { \"x\": 8, \"y\": 8 }, { \"x\": 7, \"y\": 11 }, { \"x\": 7, \"y\": 7 }, { \"x\": 12, \"y\": 8 }, { \"x\": 13, \"y\": 9 }, { \"x\": 15, \"y\": 9 }, { \"x\": 19, \"y\": 7 }, { \"x\": 18, \"y\": 8 }, { \"x\": 17, \"y\": 5 }, { \"x\": 17, \"y\": 2 }, { \"x\": 17, \"y\": 1 }, { \"x\": 13, \"y\": 1 }, { \"x\": 11, \"y\": 2 }, { \"x\": 13, \"y\": 3 }, { \"x\": 11, \"y\": 1 }, { \"x\": 8, \"y\": 1 }, { \"x\": 7, \"y\": 2 }, { \"x\": 4, \"y\": 1 }, { \"x\": 4, \"y\": 0 }, { \"x\": 2, \"y\": 1 }, { \"x\": 2, \"y\": 3 }, { \"x\": 0, \"y\": 4 }, { \"x\": 1, \"y\": 7 }, { \"x\": 1, \"y\": 9 }, { \"x\": 2, \"y\": 10 }, { \"x\": 1, \"y\": 12 }, { \"x\": 6, \"y\": 14 }, { \"x\": 12, \"y\": 14 }, { \"x\": 14, \"y\": 17 }, { \"x\": 8, \"y\": 16 }, { \"x\": 7, \"y\": 13 }, { \"x\": 10, \"y\": 11 }, { \"x\": 4, \"y\": 6 }, { \"x\": 3, \"y\": 9 }, { \"x\": 5, \"y\": 8 }, { \"x\": 6, \"y\": 4 }, { \"x\": 12, \"y\": 5 }, { \"x\": 17, \"y\": 3 }, { \"x\": 19, \"y\": 6 }, { \"x\": 19, \"y\": 8 }, { \"x\": 18, \"y\": 14 }, { \"x\": 19, \"y\": 14 }, { \"x\": 17, \"y\": 18 }, { \"x\": 15, \"y\": 18 }, { \"x\": 13, \"y\": 18 }, { \"x\": 1, \"y\": 13 }, { \"x\": 0, \"y\": 0 }, { \"x\": 13, \"y\": 0 }, { \"x\": 7, \"y\": 8 }, { \"x\": 8, \"y\": 9 }, { \"x\": 9, \"y\": 9 }, { \"x\": 11, \"y\": 12 }, { \"x\": 13, \"y\": 14 }, { \"x\": 15, \"y\": 12 }, { \"x\": 15, \"y\": 14 }, { \"x\": 16, \"y\": 11 }, { \"x\": 16, \"y\": 9 }, { \"x\": 10, \"y\": 6 }, { \"x\": 11, \"y\": 5 }, { \"x\": 14, \"y\": 16 }, { \"x\": 10, \"y\": 16 }, { \"x\": 3, \"y\": 10 }, { \"x\": 0, \"y\": 9 }, { \"x\": 2, \"y\": 9 }, { \"x\": 3, \"y\": 6 }] },\n\n    aiSpawner: { \"x\": 1, \"y\": 18 },\n};\n\nconst sliced: Level = {\n    name: 'Sliced',\n    data: { \"redFlag\": { \"x\": 0, \"y\": 19 }, \"blueFlag\": { \"x\": 19, \"y\": 0 }, \"obstacles\": [{ \"x\": 17, \"y\": 2 }, { \"x\": 16, \"y\": 3 }, { \"x\": 14, \"y\": 5 }, { \"x\": 15, \"y\": 4 }, { \"x\": 2, \"y\": 17 }, { \"x\": 3, \"y\": 16 }, { \"x\": 4, \"y\": 15 }, { \"x\": 5, \"y\": 14 }, { \"x\": 2, \"y\": 13 }, { \"x\": 3, \"y\": 12 }, { \"x\": 4, \"y\": 11 }, { \"x\": 5, \"y\": 10 }, { \"x\": 13, \"y\": 2 }, { \"x\": 12, \"y\": 3 }, { \"x\": 11, \"y\": 4 }, { \"x\": 10, \"y\": 5 }, { \"x\": 7, \"y\": 12 }, { \"x\": 8, \"y\": 11 }, { \"x\": 9, \"y\": 10 }, { \"x\": 10, \"y\": 9 }, { \"x\": 11, \"y\": 8 }, { \"x\": 12, \"y\": 7 }, { \"x\": 6, \"y\": 17 }, { \"x\": 7, \"y\": 16 }, { \"x\": 8, \"y\": 15 }, { \"x\": 9, \"y\": 14 }, { \"x\": 17, \"y\": 6 }, { \"x\": 16, \"y\": 7 }, { \"x\": 15, \"y\": 8 }, { \"x\": 14, \"y\": 9 }, { \"x\": 6, \"y\": 6 }, { \"x\": 5, \"y\": 7 }, { \"x\": 4, \"y\": 8 }, { \"x\": 3, \"y\": 9 }, { \"x\": 7, \"y\": 5 }, { \"x\": 8, \"y\": 4 }, { \"x\": 9, \"y\": 3 }, { \"x\": 13, \"y\": 13 }, { \"x\": 14, \"y\": 12 }, { \"x\": 15, \"y\": 11 }, { \"x\": 16, \"y\": 10 }, { \"x\": 12, \"y\": 14 }, { \"x\": 11, \"y\": 15 }, { \"x\": 10, \"y\": 16 }, { \"x\": 11, \"y\": 11 }, { \"x\": 11, \"y\": 12 }, { \"x\": 12, \"y\": 11 }, { \"x\": 7, \"y\": 8 }, { \"x\": 8, \"y\": 8 }, { \"x\": 8, \"y\": 7 }, { \"x\": 10, \"y\": 19 }, { \"x\": 11, \"y\": 18 }, { \"x\": 12, \"y\": 17 }, { \"x\": 13, \"y\": 16 }, { \"x\": 15, \"y\": 14 }, { \"x\": 16, \"y\": 13 }, { \"x\": 17, \"y\": 12 }, { \"x\": 18, \"y\": 11 }, { \"x\": 9, \"y\": 0 }, { \"x\": 8, \"y\": 1 }, { \"x\": 7, \"y\": 2 }, { \"x\": 6, \"y\": 3 }, { \"x\": 4, \"y\": 5 }, { \"x\": 3, \"y\": 6 }, { \"x\": 2, \"y\": 7 }, { \"x\": 1, \"y\": 8 }, { \"x\": 15, \"y\": 17 }, { \"x\": 16, \"y\": 16 }, { \"x\": 4, \"y\": 2 }, { \"x\": 3, \"y\": 3 }, { \"x\": 3, \"y\": 0 }, { \"x\": 2, \"y\": 1 }, { \"x\": 1, \"y\": 2 }, { \"x\": 16, \"y\": 19 }, { \"x\": 17, \"y\": 18 }, { \"x\": 18, \"y\": 17 }, { \"x\": 0, \"y\": 12 }, { \"x\": 1, \"y\": 11 }, { \"x\": 18, \"y\": 9 }, { \"x\": 19, \"y\": 8 }, { \"x\": 6, \"y\": 19 }, { \"x\": 2, \"y\": 19 }, { \"x\": 17, \"y\": 0 }, { \"x\": 13, \"y\": 0 }, { \"x\": 0, \"y\": 6 }, { \"x\": 1, \"y\": 5 }, { \"x\": 18, \"y\": 14 }, { \"x\": 19, \"y\": 13 }, { \"x\": 19, \"y\": 5 }, { \"x\": 18, \"y\": 4 }, { \"x\": 1, \"y\": 15 }, { \"x\": 0, \"y\": 14 }] },\n\n    aiSpawner: { \"x\": 1, \"y\": 18 },\n};\n\nconst pockets: Level = {\n    name: 'Pockets',\n    data: { \"redFlag\": { \"x\": 10, \"y\": 19 }, \"blueFlag\": { \"x\": 10, \"y\": 0 }, \"obstacles\": [{ \"x\": 7, \"y\": 1 }, { \"x\": 7, \"y\": 2 }, { \"x\": 7, \"y\": 3 }, { \"x\": 7, \"y\": 4 }, { \"x\": 8, \"y\": 4 }, { \"x\": 9, \"y\": 4 }, { \"x\": 10, \"y\": 4 }, { \"x\": 11, \"y\": 4 }, { \"x\": 12, \"y\": 4 }, { \"x\": 13, \"y\": 4 }, { \"x\": 13, \"y\": 3 }, { \"x\": 13, \"y\": 2 }, { \"x\": 13, \"y\": 1 }, { \"x\": 7, \"y\": 17 }, { \"x\": 7, \"y\": 18 }, { \"x\": 7, \"y\": 16 }, { \"x\": 7, \"y\": 15 }, { \"x\": 8, \"y\": 15 }, { \"x\": 9, \"y\": 15 }, { \"x\": 10, \"y\": 15 }, { \"x\": 12, \"y\": 15 }, { \"x\": 11, \"y\": 15 }, { \"x\": 13, \"y\": 15 }, { \"x\": 13, \"y\": 16 }, { \"x\": 13, \"y\": 17 }, { \"x\": 13, \"y\": 18 }, { \"x\": 7, \"y\": 8 }, { \"x\": 6, \"y\": 8 }, { \"x\": 5, \"y\": 8 }, { \"x\": 4, \"y\": 8 }, { \"x\": 5, \"y\": 13 }, { \"x\": 5, \"y\": 12 }, { \"x\": 5, \"y\": 11 }, { \"x\": 6, \"y\": 11 }, { \"x\": 7, \"y\": 11 }, { \"x\": 8, \"y\": 11 }, { \"x\": 9, \"y\": 11 }, { \"x\": 9, \"y\": 12 }, { \"x\": 9, \"y\": 13 }, { \"x\": 12, \"y\": 11 }, { \"x\": 12, \"y\": 13 }, { \"x\": 12, \"y\": 12 }, { \"x\": 13, \"y\": 11 }, { \"x\": 14, \"y\": 11 }, { \"x\": 15, \"y\": 11 }, { \"x\": 16, \"y\": 11 }, { \"x\": 16, \"y\": 12 }, { \"x\": 16, \"y\": 13 }, { \"x\": 3, \"y\": 11 }, { \"x\": 2, \"y\": 11 }, { \"x\": 1, \"y\": 11 }, { \"x\": 3, \"y\": 12 }, { \"x\": 3, \"y\": 13 }, { \"x\": 3, \"y\": 14 }, { \"x\": 3, \"y\": 15 }, { \"x\": 3, \"y\": 16 }, { \"x\": 3, \"y\": 17 }, { \"x\": 2, \"y\": 17 }, { \"x\": 1, \"y\": 17 }, { \"x\": 17, \"y\": 2 }, { \"x\": 18, \"y\": 2 }, { \"x\": 16, \"y\": 2 }, { \"x\": 16, \"y\": 3 }, { \"x\": 16, \"y\": 4 }, { \"x\": 16, \"y\": 5 }, { \"x\": 16, \"y\": 6 }, { \"x\": 16, \"y\": 7 }, { \"x\": 16, \"y\": 8 }, { \"x\": 17, \"y\": 8 }, { \"x\": 18, \"y\": 8 }, { \"x\": 14, \"y\": 6 }, { \"x\": 14, \"y\": 7 }, { \"x\": 14, \"y\": 8 }, { \"x\": 13, \"y\": 8 }, { \"x\": 12, \"y\": 8 }, { \"x\": 11, \"y\": 8 }, { \"x\": 10, \"y\": 8 }, { \"x\": 10, \"y\": 7 }, { \"x\": 10, \"y\": 6 }, { \"x\": 7, \"y\": 7 }, { \"x\": 7, \"y\": 6 }, { \"x\": 3, \"y\": 8 }, { \"x\": 3, \"y\": 7 }, { \"x\": 3, \"y\": 6 }, { \"x\": 18, \"y\": 18 }, { \"x\": 17, \"y\": 18 }, { \"x\": 16, \"y\": 18 }, { \"x\": 16, \"y\": 17 }, { \"x\": 16, \"y\": 16 }, { \"x\": 16, \"y\": 15 }, { \"x\": 17, \"y\": 15 }, { \"x\": 18, \"y\": 15 }, { \"x\": 3, \"y\": 4 }, { \"x\": 4, \"y\": 4 }, { \"x\": 4, \"y\": 1 }, { \"x\": 3, \"y\": 1 }, { \"x\": 2, \"y\": 1 }, { \"x\": 2, \"y\": 4 }, { \"x\": 4, \"y\": 2 }, { \"x\": 4, \"y\": 3 }, { \"x\": 1, \"y\": 1 }, { \"x\": 1, \"y\": 4 }, { \"x\": 0, \"y\": 7 }, { \"x\": 0, \"y\": 8 }, { \"x\": 19, \"y\": 11 }, { \"x\": 19, \"y\": 12 }, { \"x\": 19, \"y\": 13 }, { \"x\": 0, \"y\": 6 }, { \"x\": 0, \"y\": 19 }, { \"x\": 19, \"y\": 0 }] },\n\n    aiSpawner: { \"x\": 10, \"y\": 16 },\n};\n\nconst raid: Level = {\n    name: 'Raid',\n    data: { \"redFlag\": { \"x\": 1, \"y\": 14 }, \"blueFlag\": { \"x\": 5, \"y\": 18 }, \"obstacles\": [{ \"x\": 2, \"y\": 15 }, { \"x\": 3, \"y\": 15 }, { \"x\": 3, \"y\": 16 }, { \"x\": 3, \"y\": 17 }, { \"x\": 3, \"y\": 18 }, { \"x\": 2, \"y\": 19 }, { \"x\": 2, \"y\": 18 }, { \"x\": 2, \"y\": 17 }, { \"x\": 2, \"y\": 16 }, { \"x\": 1, \"y\": 16 }, { \"x\": 0, \"y\": 17 }, { \"x\": 1, \"y\": 17 }, { \"x\": 1, \"y\": 18 }, { \"x\": 0, \"y\": 19 }, { \"x\": 4, \"y\": 15 }, { \"x\": 3, \"y\": 14 }, { \"x\": 4, \"y\": 14 }, { \"x\": 4, \"y\": 16 }, { \"x\": 3, \"y\": 13 }, { \"x\": 4, \"y\": 13 }, { \"x\": 3, \"y\": 12 }, { \"x\": 4, \"y\": 12 }, { \"x\": 3, \"y\": 11 }, { \"x\": 4, \"y\": 11 }, { \"x\": 5, \"y\": 11 }, { \"x\": 5, \"y\": 12 }, { \"x\": 5, \"y\": 13 }, { \"x\": 6, \"y\": 14 }, { \"x\": 5, \"y\": 14 }, { \"x\": 5, \"y\": 15 }, { \"x\": 5, \"y\": 16 }, { \"x\": 4, \"y\": 17 }, { \"x\": 6, \"y\": 15 }, { \"x\": 6, \"y\": 16 }, { \"x\": 7, \"y\": 14 }, { \"x\": 8, \"y\": 14 }, { \"x\": 9, \"y\": 14 }, { \"x\": 9, \"y\": 15 }, { \"x\": 9, \"y\": 16 }, { \"x\": 7, \"y\": 16 }, { \"x\": 8, \"y\": 16 }, { \"x\": 8, \"y\": 15 }, { \"x\": 7, \"y\": 15 }, { \"x\": 0, \"y\": 18 }, { \"x\": 1, \"y\": 19 }, { \"x\": 4, \"y\": 10 }, { \"x\": 5, \"y\": 10 }, { \"x\": 5, \"y\": 9 }, { \"x\": 10, \"y\": 15 }, { \"x\": 10, \"y\": 14 }, { \"x\": 11, \"y\": 14 }, { \"x\": 10, \"y\": 12 }, { \"x\": 11, \"y\": 11 }, { \"x\": 12, \"y\": 10 }, { \"x\": 13, \"y\": 9 }, { \"x\": 10, \"y\": 11 }, { \"x\": 11, \"y\": 10 }, { \"x\": 12, \"y\": 9 }, { \"x\": 7, \"y\": 9 }, { \"x\": 8, \"y\": 8 }, { \"x\": 9, \"y\": 7 }, { \"x\": 10, \"y\": 6 }, { \"x\": 9, \"y\": 8 }, { \"x\": 8, \"y\": 9 }, { \"x\": 10, \"y\": 7 }, { \"x\": 11, \"y\": 6 }, { \"x\": 11, \"y\": 5 }, { \"x\": 14, \"y\": 8 }, { \"x\": 13, \"y\": 8 }, { \"x\": 7, \"y\": 12 }, { \"x\": 7, \"y\": 13 }, { \"x\": 6, \"y\": 13 }, { \"x\": 6, \"y\": 12 }, { \"x\": 13, \"y\": 6 }, { \"x\": 13, \"y\": 5 }, { \"x\": 14, \"y\": 6 }, { \"x\": 15, \"y\": 4 }, { \"x\": 15, \"y\": 3 }, { \"x\": 16, \"y\": 4 }, { \"x\": 16, \"y\": 1 }, { \"x\": 17, \"y\": 2 }, { \"x\": 18, \"y\": 3 }, { \"x\": 18, \"y\": 2 }, { \"x\": 17, \"y\": 1 }, { \"x\": 12, \"y\": 3 }, { \"x\": 13, \"y\": 3 }, { \"x\": 13, \"y\": 2 }, { \"x\": 12, \"y\": 2 }, { \"x\": 16, \"y\": 6 }, { \"x\": 16, \"y\": 7 }, { \"x\": 17, \"y\": 7 }, { \"x\": 17, \"y\": 6 }, { \"x\": 3, \"y\": 7 }, { \"x\": 4, \"y\": 6 }, { \"x\": 5, \"y\": 5 }, { \"x\": 6, \"y\": 4 }, { \"x\": 7, \"y\": 3 }, { \"x\": 8, \"y\": 2 }, { \"x\": 3, \"y\": 10 }, { \"x\": 4, \"y\": 9 }, { \"x\": 5, \"y\": 8 }, { \"x\": 3, \"y\": 6 }, { \"x\": 4, \"y\": 5 }, { \"x\": 5, \"y\": 4 }, { \"x\": 6, \"y\": 3 }, { \"x\": 7, \"y\": 2 }, { \"x\": 14, \"y\": 15 }, { \"x\": 15, \"y\": 14 }, { \"x\": 16, \"y\": 13 }, { \"x\": 17, \"y\": 12 }, { \"x\": 13, \"y\": 16 }, { \"x\": 12, \"y\": 16 }, { \"x\": 13, \"y\": 15 }, { \"x\": 14, \"y\": 14 }, { \"x\": 15, \"y\": 13 }, { \"x\": 16, \"y\": 12 }, { \"x\": 17, \"y\": 11 }, { \"x\": 2, \"y\": 3 }, { \"x\": 2, \"y\": 2 }, { \"x\": 2, \"y\": 1 }, { \"x\": 3, \"y\": 1 }, { \"x\": 4, \"y\": 1 }, { \"x\": 3, \"y\": 2 }, { \"x\": 1, \"y\": 4 }, { \"x\": 1, \"y\": 3 }, { \"x\": 1, \"y\": 2 }, { \"x\": 1, \"y\": 1 }, { \"x\": 18, \"y\": 18 }, { \"x\": 17, \"y\": 18 }, { \"x\": 16, \"y\": 18 }, { \"x\": 15, \"y\": 18 }, { \"x\": 18, \"y\": 17 }, { \"x\": 18, \"y\": 16 }, { \"x\": 18, \"y\": 15 }, { \"x\": 17, \"y\": 16 }, { \"x\": 16, \"y\": 17 }, { \"x\": 17, \"y\": 17 }, { \"x\": 8, \"y\": 11 }, { \"x\": 7, \"y\": 11 }, { \"x\": 8, \"y\": 12 }] },\n\n    aiSpawner: { \"x\": 1, \"y\": 13 },\n};\n\nconst arena: Level = {\n    name: 'Arena',\n    data: { \"redFlag\": { \"x\": 0, \"y\": 19 }, \"blueFlag\": { \"x\": 19, \"y\": 0 }, \"obstacles\": [{ \"x\": 1, \"y\": 14 }, { \"x\": 2, \"y\": 14 }, { \"x\": 2, \"y\": 15 }, { \"x\": 3, \"y\": 15 }, { \"x\": 3, \"y\": 16 }, { \"x\": 4, \"y\": 16 }, { \"x\": 4, \"y\": 17 }, { \"x\": 5, \"y\": 17 }, { \"x\": 5, \"y\": 18 }, { \"x\": 0, \"y\": 9 }, { \"x\": 1, \"y\": 9 }, { \"x\": 1, \"y\": 10 }, { \"x\": 2, \"y\": 10 }, { \"x\": 2, \"y\": 11 }, { \"x\": 10, \"y\": 19 }, { \"x\": 10, \"y\": 18 }, { \"x\": 9, \"y\": 18 }, { \"x\": 9, \"y\": 17 }, { \"x\": 8, \"y\": 17 }, { \"x\": 16, \"y\": 3 }, { \"x\": 16, \"y\": 4 }, { \"x\": 15, \"y\": 3 }, { \"x\": 17, \"y\": 4 }, { \"x\": 17, \"y\": 5 }, { \"x\": 18, \"y\": 5 }, { \"x\": 15, \"y\": 2 }, { \"x\": 14, \"y\": 2 }, { \"x\": 14, \"y\": 1 }, { \"x\": 17, \"y\": 8 }, { \"x\": 17, \"y\": 9 }, { \"x\": 18, \"y\": 9 }, { \"x\": 18, \"y\": 10 }, { \"x\": 19, \"y\": 10 }, { \"x\": 11, \"y\": 2 }, { \"x\": 10, \"y\": 2 }, { \"x\": 10, \"y\": 1 }, { \"x\": 9, \"y\": 1 }, { \"x\": 9, \"y\": 0 }, { \"x\": 6, \"y\": 9 }, { \"x\": 6, \"y\": 12 }, { \"x\": 9, \"y\": 6 }, { \"x\": 12, \"y\": 6 }, { \"x\": 7, \"y\": 13 }, { \"x\": 13, \"y\": 7 }, { \"x\": 14, \"y\": 14 }, { \"x\": 15, \"y\": 15 }, { \"x\": 16, \"y\": 16 }, { \"x\": 17, \"y\": 17 }, { \"x\": 5, \"y\": 5 }, { \"x\": 4, \"y\": 4 }, { \"x\": 3, \"y\": 3 }, { \"x\": 2, \"y\": 2 }, { \"x\": 10, \"y\": 13 }, { \"x\": 13, \"y\": 10 }] },\n\n    aiSpawner: { \"x\": 1, \"y\": 18 },\n};\n\nexport const LEVELS: Level[] = [\n    // TEST\n    // blank,\n\n    // 0\n    diagonal,\n    // 1\n    horizontal,\n    // 2\n    paths,\n    // 3\n    symmetry,\n    // 4\n    squares,\n    // 5\n    corners,\n    // 6\n    spotted,\n    // 7\n    entropy,\n    // 8\n    sliced,\n    // 9\n    pockets,\n    // 10\n    raid,\n    // 11\n    arena,\n];","import { Point } from 'src/app/math/point';\n\nexport class Ray {\n\n    // TODO - expects direction to be normalized.\n    constructor(readonly startPt: Point, readonly direction: Point) { }\n\n    pointAtDistance(distance: number): Point {\n        return this.startPt.add(this.direction.multiplyScaler(distance));\n    }\n}\n\nexport class LineSegment {\n    constructor(\n        readonly startPt: Point,\n        readonly endPt: Point,\n        readonly normal: Point) { }\n}\n\ninterface RayLineSegmentCollisionResult {\n    isCollision: boolean;\n    collisionPt?: Point;\n}\n\nfunction old_detectRayLineSegmentCollision(ray: Ray, lineSegment: LineSegment):\n    RayLineSegmentCollisionResult {\n    // startPt + time * direction = startPt + k * (endPt - startPt)\n    // V + t * D = P1 + k * (P2 - P1)\n    const d = ray.direction;\n    const v = ray.startPt;\n    const p1 = lineSegment.startPt;\n    const p2 = lineSegment.endPt;\n    const dxOverDy = d.x / d.y;\n\n    if (isNaN(dxOverDy)) {\n        return detectRayLineSegmentCollision(ray, lineSegment);\n    }\n\n    // k = a / b ...\n    const a = p1.y * dxOverDy - v.y * dxOverDy - p1.x + v.x;\n    const b = (p2.x - p1.x) - dxOverDy * (p2.y - p1.y);\n    const k = a / b;\n\n    // TODO <= >= ?\n    if (k < 0 || k > 1) {\n        return { isCollision: false };\n    }\n\n    // Plug k into startPt + k * (endPt - startPt) to get intersection.\n    const collisionPt = p1.add(p2.subtract(p1).multiplyScaler(k));\n\n    return {\n        isCollision: true,\n        collisionPt,\n    };\n}\n\nclass Line {\n\n    readonly m: number;\n    readonly b: number;\n\n    constructor(m: number, b: number) {\n        this.m = m;\n        this.b = b;\n    }\n\n    static from(p1: Point, p2: Point): Line {\n        const m = (p2.y - p1.y) / (p2.x - p1.x);\n        const b = (-m * p1.x) + p1.y;\n        return new Line(m, b);\n    }\n\n    isVertical(): boolean {\n        return !isFinite(this.m);\n    }\n\n    getYvalueAtX(x: number): number {\n        return this.m * x + this.b;\n    }\n}\n\nexport function detectRayLineSegmentCollision(\n    ray: Ray, lineSegment: LineSegment): RayLineSegmentCollisionResult {\n    const v = ray.startPt;\n    const d = ray.direction;\n    const dNormal = d.getNormalVectorClockwise();\n    const p1 = lineSegment.startPt;\n    const p2 = lineSegment.endPt;\n\n    const vToP1 = p1.subtract(v);\n    const vToP2 = p2.subtract(v);\n    const normalDotP1 = dNormal.dot(vToP1);\n    const normalDotP2 = dNormal.dot(vToP2);\n    if (!haveOppositeSigns(normalDotP1, normalDotP2)) {\n        return { isCollision: false };\n    }\n\n    const rayLine = Line.from(ray.startPt, ray.startPt.add(ray.direction));\n    const segmentLine = Line.from(lineSegment.startPt, lineSegment.endPt);\n\n    let intersectionPt;\n    if (segmentLine.isVertical()) {\n        // Find point on ray where x = lineSegment.startPt.x\n        const y = rayLine.getYvalueAtX(p1.x);\n        intersectionPt = new Point(p1.x, y);\n    } else if (rayLine.isVertical()) {\n        // Find point on lineSegment where y = ray.startPt.y\n        const y = segmentLine.getYvalueAtX(v.x);\n        intersectionPt = new Point(v.x, y);\n    } else {\n        // Neither lines are vertical, solve normally for intersection \n        // point of two lines.\n        // y1 = m1 x1 + b1, y2 = m2 x2 + b2\n        // At intersection, y1 = y2, x1 = x2:\n        // m1 x + b1 = m2 x + b2\n        // (m1 - m2) x = b2 - b1\n        // x = (b2 - b1) / (m1 - m2)\n        const intersectionX =\n            (segmentLine.b - rayLine.b) / (rayLine.m - segmentLine.m);\n        const intersectionY = rayLine.getYvalueAtX(intersectionX);\n        intersectionPt = new Point(intersectionX, intersectionY);\n    }\n\n    // Ensure intersection point is forwards from ray start.\n    const vToIntersection = intersectionPt.subtract(v);\n    if (d.dot(vToIntersection) < 0) {\n        return { isCollision: false };\n    }\n\n    return {\n        isCollision: true,\n        collisionPt: intersectionPt,\n    }\n}\n\nfunction haveOppositeSigns(a: number, b: number): boolean {\n    const strictly = (a > 0 && b < 0) || (a < 0 && b > 0);\n    if (strictly) {\n        return true;\n    }\n    return (isZero(a) && !isZero(b)) || (isZero(b) && !isZero(a));\n}\n\n// TODO - constants.\nconst epsilon = .000001;\nfunction isZero(n: number): boolean {\n    return Math.abs(n) < epsilon;\n}","import { Point } from 'src/app/math/point';\n\n\nexport enum ProjectileDetailsType {\n    BULLET,\n    SPLASH,\n}\n\nexport enum ProjectileShapeType {\n    CIRCLE = 'Circle',\n    RECTANGLE = 'Rectangle',\n}\n\ninterface Circle {\n    readonly type: ProjectileShapeType.CIRCLE;\n    readonly radius: number;\n}\n\ninterface Rectangle {\n    readonly type: ProjectileShapeType.RECTANGLE;\n    readonly size: Point;\n}\n\nexport type ProjectileShape = Circle | Rectangle;\n\ninterface BaseProjectileDetails {\n    readonly numRicochets: number;\n    readonly shape: ProjectileShape;\n    readonly projectileSpeed: number;\n    readonly color: string;\n}\n\nexport interface Bullet extends BaseProjectileDetails {\n    readonly type: ProjectileDetailsType.BULLET;\n    readonly damage: number;\n}\n\nexport interface SplashDamage extends BaseProjectileDetails {\n    readonly type: ProjectileDetailsType.SPLASH;\n    readonly numRicochets: 0;\n    readonly damage: number;\n    /** Tiles away from target that will be hit by grenade. */\n    readonly damageManhattanDistanceRadius: number;\n    /** \n     * If a target is within damageManhattanDistanceRadius from the grenade's \n     * target tile, the damange dealt to the target is \n     * (damage - pow(tilesAwayDamageReduction, <tiles_away>)).\n     * Should be in range (0, 1).\n     */\n    readonly tilesAwayDamageReduction: number;\n}\n\nexport type ProjectileDetails = Bullet | SplashDamage;\n\nexport interface Spray {\n    readonly projectiles: number;\n    readonly offsetAngleRadians: number;\n}\n\nexport interface Gun {\n    readonly projectileDetails: ProjectileDetails;\n    readonly aimIndicatorLength: number;\n    /** \n     * Whether the character is allowed to shoot after moving. \n     * If true, shooting ends character turn without option to move.\n     * TODO - add canMoveAfterShooting ?\n     */\n    readonly canFireAfterMoving: boolean;\n\n    readonly spray?: Spray;\n}\n\nexport interface ShotInfo {\n    // TODO friendly fire?\n    readonly fromTeamIndex: number;\n    readonly fromCanvasCoords: Point;\n    readonly fromTileCoords: Point;\n    readonly aimAngleRadiansClockwise: number;\n    readonly projectileDetails: ProjectileDetails;\n}","import { Point } from 'src/app/math/point';\nimport { SplashDamage } from 'src/app/shot_info';\nimport { SelectedCharacterState } from 'src/app/game_state';\nimport { CharacterSettings } from 'src/app/character_settings';\n\nexport enum ActionType {\n    SELECT_CHARACTER_CLASS = 'SELECT_CHARACTER_CLASS',\n    SELECT_TILE = 'SELECT_TILE',\n    SELECT_CHARACTER = 'SELECT_CHARACTER',\n    SELECT_CHARACTER_STATE = 'SELECT_CHARACTER_STATE',\n    AIM = 'AIM',\n    SHOOT = 'SHOOT',\n    HEAL = 'HEAL',\n    END_CHARACTER_TURN = 'END_CHARACTER_TURN',\n}\n\n\nexport interface SelectCharacterClassAction {\n    readonly type: ActionType.SELECT_CHARACTER_CLASS;\n    readonly class: CharacterSettings;\n}\n\nexport interface SelectTileAction {\n    readonly type: ActionType.SELECT_TILE;\n    readonly tile: Point;\n}\n\nexport interface SelectCharacterAction {\n    readonly type: ActionType.SELECT_CHARACTER;\n    readonly characterIndex: number;\n}\n\nexport interface SelectCharacterStateAction {\n    readonly type: ActionType.SELECT_CHARACTER_STATE;\n    readonly state: SelectedCharacterState;\n}\n\nexport interface EndCharacterTurnAction {\n    readonly type: ActionType.END_CHARACTER_TURN;\n}\n\nexport interface AimAction {\n    readonly type: ActionType.AIM;\n    readonly aimAngleClockwiseRadians: number;\n}\n\nexport interface ShootAction {\n    readonly type: ActionType.SHOOT;\n}\n\nexport interface HealAction {\n    readonly type: ActionType.HEAL;\n    readonly healAmount: number;\n}\n\nexport type Action = SelectCharacterClassAction |\n    EndCharacterTurnAction | ShootAction | HealAction |\n    SelectTileAction | SelectCharacterAction |\n    SelectCharacterStateAction | AimAction;\n\n/** Used for exhaustive Action checking. */\nexport function throwBadAction(action: never): never {\n    throw new Error('Action not handled');\n}","import { SplashDamage, ProjectileDetailsType, ProjectileShapeType, Gun } from 'src/app/shot_info';\nimport { Grid } from 'src/app/grid';\nimport { THEME } from './theme';\nimport { Point } from './math/point';\n\nconst GOD_MODE = false;\n\n/** Abilities characters can perform in addition to moving and shooting. */\nexport interface BaseCharacterAbility {\n    /**  Max times this ability can be used. 0 indicates unlimited. */\n    readonly maxUses: number;\n    /** Number of turns after use before ability can be reused. */\n    readonly cooldownTurns: number;\n    /** \n     * Whether the ability can be used in addition to shooting (true)\n     * or is used in place of shooting (false). \n     */\n    readonly isFree: boolean;\n}\n\nexport enum CharacterAbilityType {\n    HEAL,\n    THROW_GRENADE,\n}\n\nexport interface HealAbility extends BaseCharacterAbility {\n    readonly abilityType: CharacterAbilityType.HEAL;\n    readonly healAmount: number;\n}\n\nexport interface ThrowGrenadeAbility extends BaseCharacterAbility {\n    readonly abilityType: CharacterAbilityType.THROW_GRENADE;\n    readonly splashDamage: SplashDamage;\n    readonly maxManhattanDistance: number;\n}\n\nexport type CharacterAbility = HealAbility | ThrowGrenadeAbility;\n\n/** Metadata about CharacterActions. */\nexport interface CharacterAbilityState {\n    /** Remaining number of uses for action, or null if unlimited. */\n    usesLeft?: number;\n    /** Remaining number of turns until this action can be used again. */\n    cooldownTurnsLeft: number;\n}\n\nexport enum ClassType {\n    SCOUT = 'Scout',\n    ASSAULT = 'Assault',\n    SNIPER = 'Sniper',\n    DEMOLITION = 'Demolition',\n}\n\n/** Parameters describing basic character attributes. */\nexport interface CharacterSettings {\n    readonly type: ClassType;\n    /** Starting health. */\n    readonly maxHealth: number;\n    /** Manhattan distance from curent position a character can move */\n    readonly maxMovesPerTurn: number;\n    /** Manhattan distance away a character can see when fog of war is on. */\n    readonly maxSight: number;\n    /** Special abilities a character can use. */\n    readonly extraActions: Set<CharacterAbility>;\n\n    readonly gun: Gun;\n}\n\n\nconst DEFAULT_BULLET_COLOR = '#fff86e';\nconst DEFAULT_GRENADE_COLOR = '#176107';\n\nconst LIGHT_HEAL: HealAbility = {\n    abilityType: CharacterAbilityType.HEAL,\n    healAmount: 3,\n    maxUses: 2,\n    cooldownTurns: 2,\n    isFree: true,\n};\nconst MEDIUM_HEAL: HealAbility = {\n    abilityType: CharacterAbilityType.HEAL,\n    healAmount: 5,\n    maxUses: 2,\n    cooldownTurns: 3,\n    isFree: false,\n};\nconst FULL_HEAL: HealAbility = {\n    abilityType: CharacterAbilityType.HEAL,\n    healAmount: 15,\n    maxUses: 1,\n    cooldownTurns: 0,\n    isFree: false,\n};\n\nconst LIGHT_GRENADE: ThrowGrenadeAbility = {\n    abilityType: CharacterAbilityType.THROW_GRENADE,\n    splashDamage: {\n        type: ProjectileDetailsType.SPLASH,\n        numRicochets: 0,\n        damage: 5,\n        damageManhattanDistanceRadius: 1,\n        tilesAwayDamageReduction: .6,\n        projectileSpeed: Grid.TILE_SIZE / 160,\n        color: DEFAULT_GRENADE_COLOR,\n        shape: {\n            type: ProjectileShapeType.CIRCLE,\n            radius: Grid.TILE_SIZE / 6,\n        },\n    },\n    maxManhattanDistance: 4,\n    maxUses: 1,\n    cooldownTurns: 0,\n    isFree: false,\n};\nconst MEDIUM_GRENADE: ThrowGrenadeAbility = {\n    abilityType: CharacterAbilityType.THROW_GRENADE,\n    splashDamage: {\n        type: ProjectileDetailsType.SPLASH,\n        numRicochets: 0,\n        damage: 8,\n        damageManhattanDistanceRadius: 3,\n        tilesAwayDamageReduction: .5,\n        projectileSpeed: Grid.TILE_SIZE / 160,\n        color: DEFAULT_GRENADE_COLOR,\n        shape: {\n            type: ProjectileShapeType.CIRCLE,\n            radius: Grid.TILE_SIZE / 6,\n        },\n    },\n    maxManhattanDistance: 4,\n    maxUses: 1,\n    cooldownTurns: 0,\n    isFree: false,\n};\n\nconst SHOTGUN: Gun = {\n    canFireAfterMoving: true,\n    projectileDetails: {\n        type: ProjectileDetailsType.BULLET,\n        numRicochets: 1,\n        damage: 3,\n        projectileSpeed: Grid.TILE_SIZE / 80,\n        color: DEFAULT_BULLET_COLOR,\n        shape: {\n            type: ProjectileShapeType.CIRCLE,\n            radius: Grid.TILE_SIZE / 16,\n        },\n    },\n    aimIndicatorLength: .75 * Grid.TILE_SIZE,\n    spray: {\n        projectiles: 3,\n        offsetAngleRadians: Math.PI / 24,\n    }\n};\nconst ASSAULT_RIFLE: Gun = {\n    canFireAfterMoving: true,\n    projectileDetails: {\n        type: ProjectileDetailsType.BULLET,\n        numRicochets: 2,\n        damage: GOD_MODE ? 20 : 6,\n        projectileSpeed: Grid.TILE_SIZE / 80,\n        color: DEFAULT_BULLET_COLOR,\n        shape: {\n            type: ProjectileShapeType.CIRCLE,\n            radius: Grid.TILE_SIZE / 12,\n        },\n    },\n    aimIndicatorLength: 1.5 * Grid.TILE_SIZE,\n};\nconst SNIPER_RIFLE: Gun = {\n    canFireAfterMoving: false,\n    projectileDetails: {\n        type: ProjectileDetailsType.BULLET,\n        numRicochets: 5,\n        damage: 8,\n        projectileSpeed: Grid.TILE_SIZE / 60,\n        color: DEFAULT_BULLET_COLOR,\n        shape: {\n            type: ProjectileShapeType.RECTANGLE,\n            size: new Point(Grid.TILE_SIZE / 4, Grid.TILE_SIZE / 8),\n        },\n    },\n    aimIndicatorLength: 12 * Grid.TILE_SIZE,\n};\nconst MISSILE_LAUNCHER: Gun = {\n    canFireAfterMoving: true,\n    projectileDetails: {\n        type: ProjectileDetailsType.SPLASH,\n        numRicochets: 0,\n        damage: 10,\n        damageManhattanDistanceRadius: 2,\n        tilesAwayDamageReduction: .6,\n        projectileSpeed: Grid.TILE_SIZE / 160,\n        color: '#f2ebeb',\n        shape: {\n            type: ProjectileShapeType.RECTANGLE,\n            size: new Point(Grid.TILE_SIZE / 4, Grid.TILE_SIZE / 8),\n        },\n    },\n    aimIndicatorLength: .75 * Grid.TILE_SIZE,\n};\n\nexport const SCOUT_CHARACTER_SETTINGS: CharacterSettings = {\n    type: ClassType.SCOUT,\n    maxHealth: 8,\n    maxMovesPerTurn: 6,\n    maxSight: 8,\n    gun: SHOTGUN,\n    extraActions: new Set<CharacterAbility>([\n        LIGHT_HEAL,\n        LIGHT_GRENADE,\n    ]),\n};\nexport const ASSAULT_CHARACTER_SETTINGS: CharacterSettings = {\n    type: ClassType.ASSAULT,\n    maxHealth: 12,\n    maxMovesPerTurn: GOD_MODE ? 16 : 4,\n    maxSight: 6,\n    gun: ASSAULT_RIFLE,\n    extraActions: new Set<CharacterAbility>([\n        MEDIUM_HEAL,\n        LIGHT_GRENADE,\n    ]),\n};\nexport const SNIPER_CHARACTER_SETTINGS: CharacterSettings = {\n    type: ClassType.SNIPER,\n    maxHealth: 8,\n    maxSight: 8,\n    maxMovesPerTurn: 3,\n    gun: SNIPER_RIFLE,\n    extraActions: new Set<CharacterAbility>([\n        FULL_HEAL,\n    ]),\n};\nexport const DEMOLITION_CHARACTER_SETTINGS: CharacterSettings = {\n    type: ClassType.DEMOLITION,\n    maxHealth: 12,\n    maxSight: 4,\n    maxMovesPerTurn: 3,\n    gun: MISSILE_LAUNCHER,\n    extraActions: new Set<CharacterAbility>([\n        FULL_HEAL,\n        MEDIUM_GRENADE,\n    ]),\n};\n\nexport const CHARACTER_CLASSES: CharacterSettings[] = [\n    SCOUT_CHARACTER_SETTINGS,\n    ASSAULT_CHARACTER_SETTINGS,\n    SNIPER_CHARACTER_SETTINGS,\n    DEMOLITION_CHARACTER_SETTINGS,\n]","import { Point } from 'src/app/math/point';\nimport { lerp } from 'src/app/math/lerp';\nimport { lerpColors, hexStringToColor, colorToString } from 'src/app/color';\nimport { Grid } from 'src/app/grid';\n\nexport enum ParticleShape {\n    CIRCLE = 'Circle',\n    ELLIPSE = 'Ellipse',\n    LINE = 'Line',\n    PLUS = 'Plus',\n}\n\ninterface Particle {\n    lifetimeMs: number;\n\n    canvasPosition: Point;\n    readonly direction: Point;\n    readonly deltaPositionPerMs: number;\n\n    readonly rotationRadians: number;\n\n    readonly color: string;\n    readonly shape: ParticleShape;\n    readonly radius: number;\n}\n\nconst TWO_PI = Math.PI * 2;\n\n// TODO - add normal direction and max angle deviation.\nexport interface ParticleSystemParams {\n    readonly startPositionCanvas: Point;\n    readonly particleCount: number;\n\n    /** \n     * Particle colors will be radonmly \n     * interpolated between colorA and colorB.\n     */\n    readonly colorA: string;\n\n    /** \n     * Particle colors will be radonmly \n     * interpolated between colorA and colorB.\n     */\n    readonly colorB: string;\n\n    readonly shape: ParticleShape;\n\n    readonly minParticleSpeed: number;\n    readonly maxParticleSpeed: number;\n    readonly minLifetimeMs: number;\n    readonly maxLifetimeMs: number;\n    readonly minRadius: number;\n    readonly maxRadius: number;\n}\n\n/** \n * Emits small particles from a point. \n * Currently just little circles.\n */\nexport class ParticleSystem {\n\n    tileCoords: Point;\n    private readonly particles: Particle[];\n\n    /** True while there are still particles floating around. */\n    isAlive: boolean;\n\n    params: ParticleSystemParams;\n\n    constructor(params: ParticleSystemParams) {\n        this.params = params;\n        this.particles = [];\n\n        // Make the particles. All start at same position, \n        // but have different direction.\n        this.isAlive = true;\n        this.tileCoords =\n            Grid.getTileFromCanvasCoords(params.startPositionCanvas);\n\n        const deltaTheta = TWO_PI / params.particleCount;\n        for (let i = 0; i < params.particleCount; i++) {\n            const theta = i * deltaTheta;\n            const direction =\n                new Point(Math.cos(theta), Math.sin(theta)).normalize();\n            const speed = lerp(\n                params.minParticleSpeed,\n                params.maxParticleSpeed,\n                Math.random());\n            const lifetimeMs = lerp(\n                params.minLifetimeMs,\n                params.maxLifetimeMs,\n                Math.random());\n            const color = lerpColors(\n                hexStringToColor(params.colorA),\n                hexStringToColor(params.colorB),\n                Math.random());\n            const radius =\n                lerp(params.minRadius, params.maxRadius, Math.random());\n            // Only give ellipses a rotation.\n            const rotationRadians = this.params.shape === ParticleShape.ELLIPSE\n                ? direction.getPointRotationRadians()\n                : 0;\n            this.particles.push({\n                canvasPosition: params.startPositionCanvas,\n                direction,\n                lifetimeMs,\n                deltaPositionPerMs: speed,\n                color: colorToString(color),\n                shape: this.params.shape,\n                radius,\n                rotationRadians: rotationRadians,\n            });\n        }\n    }\n\n    update(elapsedMs: number): void {\n        let isAnyParticleAlive = false;\n        this.particles.forEach((particle: Particle) => {\n            particle.lifetimeMs -= elapsedMs;\n            if (particle.lifetimeMs > 0) {\n                isAnyParticleAlive = true;\n                particle.canvasPosition =\n                    particle.canvasPosition.add(\n                        particle.direction.multiplyScaler(\n                            particle.deltaPositionPerMs * elapsedMs));\n            }\n        });\n        this.isAlive = isAnyParticleAlive;\n    }\n\n    render(context: CanvasRenderingContext2D): void {\n        this.particles.forEach((particle: Particle) => {\n            if (particle.lifetimeMs <= 0) {\n                return;\n            }\n            const particleCenter = particle.canvasPosition;\n            switch (particle.shape) {\n                case ParticleShape.CIRCLE:\n                    context.fillStyle = particle.color;\n                    context.beginPath();\n                    context.arc(\n                        particleCenter.x,\n                        particleCenter.y,\n                        particle.radius,\n                        0,\n                        TWO_PI);\n                    context.fill();\n                    break;\n                case ParticleShape.LINE:\n                    context.strokeStyle = particle.color;\n                    context.lineWidth = 1;\n                    context.beginPath();\n                    const halfLineOffset =\n                        particle.direction.multiplyScaler(\n                            particle.radius);\n                    const start =\n                        particleCenter.add(halfLineOffset);\n                    const end = particleCenter.subtract(halfLineOffset);\n                    context.moveTo(start.x, start.y);\n                    context.lineTo(end.x, end.y);\n                    context.stroke();\n                    break;\n                case ParticleShape.ELLIPSE:\n                    context.fillStyle = particle.color;\n                    context.beginPath();\n                    const xRadius = particle.radius;\n                    const yRadius = particle.radius / 2;\n                    context.ellipse(\n                        particleCenter.x,\n                        particleCenter.y,\n                        xRadius,\n                        yRadius,\n                        particle.rotationRadians,\n                        0,\n                        TWO_PI);\n                    context.fill();\n                    break;\n                case ParticleShape.PLUS:\n                    context.fillStyle = particle.color;\n                    const radius = particle.radius;\n                    const halfThickness = radius / 4;\n                    const horizontalStart =\n                        particle.canvasPosition\n                            .subtract(new Point(radius, halfThickness));\n                    context.fillRect(\n                        horizontalStart.x, horizontalStart.y,\n                        radius * 2, halfThickness * 2);\n                    const verticalStart =\n                        particle.canvasPosition\n                            .subtract(new Point(halfThickness, radius));\n                    context.fillRect(\n                        verticalStart.x, verticalStart.y,\n                        halfThickness * 2, radius * 2);\n                    break;\n            }\n\n        });\n\n    }\n}","\nimport { Point } from 'src/app/math/point';\nimport { Grid } from 'src/app/grid';\nimport { THEME } from 'src/app/theme';\n\nexport class Flag {\n    readonly teamIndex: number;\n    tileCoords: Point;\n    readonly startTileCoords: Point;\n\n    private isTaken: boolean;\n    private getTileTopLeft?: () => Point;\n\n    constructor({ tileCoords, teamIndex }:\n        { tileCoords: Point; teamIndex: number }) {\n        this.startTileCoords = tileCoords;\n        this.tileCoords = tileCoords;\n        this.teamIndex = teamIndex;\n    }\n\n    setIsTaken(getTileTopLeft: () => Point): void {\n        this.isTaken = true;\n        this.getTileTopLeft = getTileTopLeft;\n    }\n\n    isAtStart(): boolean {\n        return this.startTileCoords.equals(this.tileCoords);\n    }\n\n    returnToStart(): void {\n        this.setDropped();\n        this.tileCoords = this.startTileCoords;\n    }\n\n    setDropped(): void {\n        this.isTaken = false;\n        this.getTileTopLeft = undefined;\n    }\n\n    getCurrentTile(): Point {\n        if (!this.isTaken) {\n            return this.tileCoords;\n        }\n        const tile = Grid.getTileFromCanvasCoords(this.getTileTopLeft!());\n        return tile;\n    }\n\n    update(elapsedMs: number) {\n\n    }\n\n    render(context: CanvasRenderingContext2D): void {\n        let tileCanvasTopLeft = Grid.getCanvasFromTileCoords(this.tileCoords);\n        if (this.isTaken) {\n            tileCanvasTopLeft = this.getTileTopLeft!();\n        }\n\n        // Flag pole.\n        const topMargin = Grid.TILE_SIZE * .2;\n        const leftMargin = Grid.TILE_SIZE * .1;\n        const flagPoleWidth = leftMargin;\n        context.fillStyle = THEME.flagPoleColor;\n        context.fillRect(\n            tileCanvasTopLeft.x + leftMargin,\n            tileCanvasTopLeft.y + topMargin,\n            flagPoleWidth,\n            Grid.TILE_SIZE - topMargin);\n\n        // Flag.\n        const rightMargin = leftMargin;\n        const height = Grid.TILE_SIZE * .36;\n        context.fillStyle = this.teamIndex === 0\n            ? THEME.blueFlagColor\n            : THEME.redFlagColor;\n        context.fillRect(\n            tileCanvasTopLeft.x + leftMargin + flagPoleWidth,\n            tileCanvasTopLeft.y + topMargin,\n            Grid.TILE_SIZE - leftMargin - flagPoleWidth - rightMargin,\n            height);\n    }\n}","import { Point } from 'src/app/math/point';\nimport { Ray } from 'src/app/math/collision_detection';\nimport { Grid } from 'src/app/grid';\nimport { THEME } from 'src/app/theme';\nimport { ShotInfo, ProjectileDetailsType, ProjectileDetails, ProjectileShapeType } from 'src/app/shot_info';\nimport { hexStringToColor } from 'src/app/color';\nimport { Target } from 'src/app/math/target';\nimport { AnimationState } from 'src/app/animation_state';\n\nconst MAX_TRAIL_DISTANCE = Grid.TILE_SIZE * 3;\n\n// TODO - extract into shared constant\nconst TWO_PI = Math.PI * 2;\n\n// TODO - this is hack-E.\ninterface Trail {\n    ray: Ray;\n    distance: number;\n    maxDistance: number;\n}\n\nexport class Projectile {\n    tileCoords: Point;\n\n    private readonly context: CanvasRenderingContext2D;\n    readonly projectileDetails: ProjectileDetails;\n    readonly fromTeamIndex: number;\n\n    private timesRicocheted: number;\n    private trails: Trail[];\n\n    animationState: AnimationState;\n    isDead: boolean;\n\n    constructor(params: {\n        context: CanvasRenderingContext2D;\n        projectileDetails: ProjectileDetails;\n        targets: Target[];\n        fromTeamIndex: number;\n    }) {\n        this.context = params.context;\n        this.projectileDetails = params.projectileDetails;\n        if (params.targets.length === 0) {\n            throw new Error(`Created a projectile with no targets`);\n        }\n        this.setNewTargets(params.targets);\n        this.tileCoords =\n            Grid.getTileFromCanvasCoords(\n                this.animationState.currentTarget!.ray.startPt);\n        this.trails = [{\n            ray: this.animationState.currentTarget!.ray,\n            distance: 0,\n            maxDistance: this.animationState.currentTarget!.maxDistance,\n        }];\n        this.fromTeamIndex = params.fromTeamIndex;\n        this.timesRicocheted = 0;\n        this.isDead = false;\n    }\n\n    update(elapsedMs: number): void {\n        const currentTarget = this.animationState.currentTarget!;\n        const direction = currentTarget.ray.direction;\n        const positionUpdate =\n            direction.multiplyScaler(\n                this.animationState.movementSpeedMs * elapsedMs);\n        const distanceUpdate = positionUpdate.getMagnitude();\n        for (const trail of this.trails) {\n            trail.distance += distanceUpdate;\n        }\n\n        if (!this.animationState.isAnimating) {\n            return;\n        }\n        this.animationState.currentCenterCanvas =\n            this.animationState.currentCenterCanvas\n                .add(positionUpdate);\n        this.tileCoords =\n            Grid.getTileFromCanvasCoords(\n                this.animationState.currentCenterCanvas);\n        const totalDistanceTravelled = currentTarget.ray.startPt\n            .distanceTo(this.animationState.currentCenterCanvas);\n        if (totalDistanceTravelled < currentTarget.maxDistance) {\n            return;\n        }\n        // Ensure end state is centered in destination tile.\n        this.animationState.currentCenterCanvas =\n            this.animationState.currentTarget!.canvasCoords;\n        if (this.animationState.remainingTargets.length === 0) {\n            this.animationState.isAnimating = false;\n            return;\n        }\n\n        this.animationState.currentTarget =\n            this.animationState.remainingTargets.shift()!;\n        this.trails.push({\n            ray: this.animationState.currentTarget.ray,\n            distance: 0,\n            maxDistance: this.animationState.currentTarget.maxDistance,\n        });\n        this.timesRicocheted += 1;\n    }\n\n    isAtFinalTarget(): boolean {\n        return !this.isDead && !this.animationState.isAnimating;\n    }\n\n    setNewTargets(targets: Target[]): void {\n        const firstTarget = targets.shift()!;\n        const remainingTargets = targets;\n        const currentCenterCanvas = this.animationState != null\n            ? this.animationState.currentCenterCanvas\n            : firstTarget.ray.startPt;\n        this.animationState = {\n            movementSpeedMs: this.projectileDetails.projectileSpeed,\n            currentCenterCanvas,\n            isAnimating: true,\n            currentTarget: firstTarget,\n            remainingTargets,\n        };\n    }\n\n    getCurrentTarget(): Target {\n        return this.animationState.currentTarget!;\n    }\n\n    getNumRicochetsLeft(): number {\n        return this.projectileDetails.type === ProjectileDetailsType.BULLET\n            ? this.projectileDetails.numRicochets - this.timesRicocheted\n            : 0;\n    }\n\n    setIsDead(): void {\n        this.isDead = true;\n    }\n\n    isTrailGone(): boolean {\n        return this.trails\n            .every((trail) => {\n                return trail.distance > trail.maxDistance + MAX_TRAIL_DISTANCE;\n            });\n    }\n\n    render(): void {\n        const context = this.context;\n        const shape = this.projectileDetails.shape;\n        let projecileLength;\n        if (shape.type === ProjectileShapeType.CIRCLE) {\n            projecileLength = shape.radius;\n        } else {\n            projecileLength = shape.size.x;\n        }\n\n        for (const trail of this.trails) {\n            if (trail.distance < projecileLength\n                || trail.distance > trail.maxDistance + MAX_TRAIL_DISTANCE) {\n                continue;\n            }\n            const bacwardsDirection = trail.ray.direction.multiplyScaler(-1);\n            let overshotDistance = 0;\n            const trailGradientStartPointCanvas =\n                trail.ray.pointAtDistance(trail.distance);\n            let trailRenderStartPointCanvas = trailGradientStartPointCanvas;\n            if (trail.distance > trail.maxDistance) {\n                overshotDistance =\n                    MAX_TRAIL_DISTANCE - (trail.distance - trail.maxDistance);\n                trailRenderStartPointCanvas =\n                    trail.ray.pointAtDistance(trail.maxDistance);\n            }\n            let trailDistance = Math.min(\n                MAX_TRAIL_DISTANCE,\n                trail.distance,\n                trail.distance + overshotDistance);\n            const trailFadePointCanvas = trailGradientStartPointCanvas.add(\n                bacwardsDirection.multiplyScaler(trailDistance));\n            const gradient = context.createLinearGradient(\n                trailGradientStartPointCanvas.x,\n                trailGradientStartPointCanvas.y,\n                trailFadePointCanvas.x,\n                trailFadePointCanvas.y);\n            const fullColor = THEME.projectileTrailColor;\n            const fadedColor = `${THEME.projectileTrailColor}00`;\n            gradient.addColorStop(0, fullColor);\n            gradient.addColorStop(1, fadedColor);\n\n            // Draw trail.\n            context.strokeStyle = gradient;\n            context.beginPath();\n            context.moveTo(\n                trailRenderStartPointCanvas.x, trailRenderStartPointCanvas.y);\n            context.lineTo(trailFadePointCanvas.x, trailFadePointCanvas.y);\n            context.closePath();\n            context.stroke();\n        }\n\n        if (this.isDead) {\n            return;\n        }\n\n        const currentPointCanvas = this.animationState.currentCenterCanvas;\n        context.fillStyle = this.projectileDetails.color;\n        switch (shape.type) {\n            case ProjectileShapeType.CIRCLE:\n                const radius = shape.radius;\n                context.beginPath();\n                context.arc(\n                    currentPointCanvas.x,\n                    currentPointCanvas.y,\n                    radius,\n                    0,\n                    TWO_PI);\n                context.closePath();\n                context.fill();\n                break;\n            case ProjectileShapeType.RECTANGLE:\n                const size = shape.size;\n                const direction = this.getCurrentTarget().ray.direction;\n                const directionNormal = direction.getNormalVectorClockwise();\n                const leftOffset = direction.multiplyScaler(-size.x / 2);\n                const rightOffset = direction.multiplyScaler(size.x / 2);\n                const topOffset = directionNormal.multiplyScaler(-size.y / 2);\n                const bottomOffset = directionNormal.multiplyScaler(size.y / 2);\n                const topLeft =\n                    currentPointCanvas.add(leftOffset).add(topOffset);\n                const topRight =\n                    currentPointCanvas.add(rightOffset).add(topOffset);\n                const bottomRight =\n                    currentPointCanvas.add(rightOffset).add(bottomOffset);\n                const bottomLeft =\n                    currentPointCanvas.add(leftOffset).add(bottomOffset);\n                context.beginPath();\n                context.moveTo(topLeft.x, topLeft.y);\n                context.lineTo(topRight.x, topRight.y);\n                context.lineTo(bottomRight.x, bottomRight.y);\n                context.lineTo(bottomLeft.x, bottomLeft.y);\n                context.closePath();\n                context.fill();\n                break;\n            default:\n                throw new Error(\"Unknown projectile shape\");\n        }\n    }\n}","import { Point } from './point';\n\nexport type Lerp = (a: number, b: number, t: number) => number;\n\nexport function lerp(a: number, b: number, t: number): number {\n    return (b - a) * t + a;\n}\n\n/**\n * It's like lerp but it pushes at the end in a cool way. Maybe.\n */\nexport function coolLerp(a: number, b: number, t: number): number {\n    const start = 0.75;\n    return lerp(a, b, Math.max(0, t - start) * 4);\n}\n\nexport function lerpPoints(\n    a: Point, b: Point, t: number, lerpFn?: Lerp): Point {\n\n    lerpFn = lerpFn || lerp;\n    return new Point(lerpFn(a.x, b.x, t), lerpFn(a.y, b.y, t));\n}","import { lerp } from 'src/app/math/lerp';\n\n/** Internal representation useful for lerping colors. */\nexport interface Color {\n    /** Red value from 0 to 255, inclusive. */\n    r: number;\n\n    /** Green value from 0 to 255, inclusive. */\n    g: number;\n\n    /** Blue value from 0 to 255, inclusive. */\n    b: number;\n\n    /** Alpha value from 0 to 1, inclusive. */\n    a: number;\n}\n\n/** \n * Expects parameter to be of format '#RRGGBB' or '#RRGGBBAA'.  \n * Alpha defaults to 1 if not supplied.\n */\nexport function hexStringToColor(hex: string): Color {\n    const alpha = hex.length > 7\n        ? parseInt(hex.substring(7, 9), 16) / 255\n        : 1;\n    return {\n        r: parseInt(hex.substring(1, 3), 16),\n        g: parseInt(hex.substring(3, 5), 16),\n        b: parseInt(hex.substring(5, 7), 16),\n        a: alpha,\n    };\n}\n\nexport function rgbaToColor(r: number, g: number, b: number, a: number): Color {\n    if (r > 255 || g > 255 || b > 255 || a > 1\n        || r < 0 || g < 0 || b < 0 || a < 0) {\n        throw new Error(`Invalid rgbaToColor params: ${r}, ${g}, ${b}, ${a}`);\n    }\n    return { r, g, b, a };\n}\n\n/** Returns a css color string for use with stroke/fill style. */\nexport function colorToString(color: Color): string {\n    return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;\n}\n\nexport function lerpColors(c1: Color, c2: Color, t: number): Color {\n    return {\n        r: lerp(c1.r, c2.r, t),\n        g: lerp(c1.g, c2.g, t),\n        b: lerp(c1.b, c2.b, t),\n        a: lerp(c1.a, c2.a, t),\n    }\n}","import { ControlMap, CONTROLS } from 'src/app/controls';\nimport { THEME } from 'src/app/theme';\nimport { Point } from 'src/app/math/point';\nimport { lerpColors, hexStringToColor, colorToString } from 'src/app/color';\nimport { Grid } from './grid';\n\n/** Determines how long to display titles, subtitles, and toasts. */\nexport enum Duration {\n    SHORT,\n    LONG,\n}\n\nexport enum TextType {\n    TITLE,\n    SUBTITLE,\n    TOAST,\n}\n\ninterface TextRenderSettings {\n    readonly fontSize: number;\n    readonly topMargin: number;\n}\n\nconst durationToMs = new Map<Duration, number>([\n    [Duration.SHORT, 2000],\n    [Duration.LONG, 4000],\n]);\nconst textTypeToRenderSettings = new Map<TextType, TextRenderSettings>([\n    [TextType.TITLE, {\n        fontSize: 72,\n        topMargin: Grid.GAME_HEIGHT / 4,\n    }],\n    [TextType.SUBTITLE, {\n        fontSize: 48,\n        topMargin: Grid.GAME_HEIGHT / 2,\n    }],\n    [TextType.TOAST, {\n        fontSize: 24,\n        topMargin: 7 * Grid.GAME_HEIGHT / 8,\n    }],\n]);\n\nexport class Hud {\n\n    private readonly context: CanvasRenderingContext2D;\n    private isShowingControlMap: boolean;\n\n    private titleText?: string;\n    private titleMsLeft: number;\n    private titleDuration: Duration;\n\n    private subtitleText?: string;\n    private subtitleMsLeft: number;\n    private subtitleDuration: Duration;\n\n    private toastText?: string;\n    private toastMsLeft: number;\n    private toastDuration: Duration;\n\n    constructor(context: CanvasRenderingContext2D) {\n        this.context = context;\n        this.isShowingControlMap = false;\n        this.titleMsLeft = -1;\n        this.subtitleMsLeft = -1;\n        this.toastMsLeft = -1;\n    }\n\n    update(elapsedMs: number): void {\n        if (this.titleMsLeft > 0) {\n            this.titleMsLeft -= elapsedMs;\n        }\n        if (this.subtitleMsLeft > 0) {\n            this.subtitleMsLeft -= elapsedMs;\n        }\n        if (this.toastMsLeft > 0) {\n            this.toastMsLeft -= elapsedMs;\n        }\n    }\n\n    render(): void {\n        if (this.titleMsLeft > 0) {\n            if (!this.titleText) {\n                throw new Error(\n                    `Expected title text to set when titleMsLeft > 0`);\n            }\n            this.renderText(\n                this.titleText,\n                textTypeToRenderSettings.get(TextType.TITLE)!,\n                this.titleMsLeft / durationToMs.get(this.titleDuration)!);\n        }\n        if (this.subtitleMsLeft > 0) {\n            if (!this.subtitleText) {\n                throw new Error(\n                    `Expected subtitle text to set when subtitleMsLeft > 0`);\n            }\n            this.renderText(\n                this.subtitleText,\n                textTypeToRenderSettings.get(TextType.SUBTITLE)!,\n                this.subtitleMsLeft / durationToMs.get(this.subtitleDuration)!);\n        }\n        if (this.toastMsLeft > 0) {\n            if (!this.toastText) {\n                throw new Error\n                    (`Expected toastText text to set when toastMsLeft > 0`);\n            }\n            this.renderText(\n                this.toastText,\n                textTypeToRenderSettings.get(TextType.TOAST)!,\n                this.toastMsLeft / durationToMs.get(this.toastDuration)!);\n        }\n    }\n\n    setText(text: string, textType: TextType, duration: Duration): void {\n        const ms = durationToMs.get(duration)!;\n        switch (textType) {\n            case TextType.TITLE:\n                this.titleText = text;\n                this.titleMsLeft = ms;\n                this.titleDuration = duration;\n                break;\n            case TextType.SUBTITLE:\n                this.subtitleText = text;\n                this.subtitleMsLeft = ms;\n                this.subtitleDuration = duration;\n                break;\n            case TextType.TOAST:\n                this.toastText = text;\n                this.toastMsLeft = ms;\n                this.toastDuration = duration;\n                break;\n        }\n    }\n\n    clearText(textType: TextType): void {\n        switch (textType) {\n            case TextType.TITLE:\n                this.titleText = '';\n                this.titleMsLeft = 0;\n                break;\n            case TextType.SUBTITLE:\n                this.subtitleText = '';\n                this.subtitleMsLeft = 0;\n                break;\n            case TextType.TOAST:\n                this.toastText = '';\n                this.toastMsLeft = 0;\n                break;\n        }\n    }\n\n    private renderText(\n        text: string,\n        textRenderSettings: TextRenderSettings,\n        percentTimeLeft: number): void {\n\n        const fadedColor = hexStringToColor(THEME.hudTextColor);\n        fadedColor.a = percentTimeLeft;\n        this.context.fillStyle = colorToString(fadedColor);\n        this.context.font = `${textRenderSettings.fontSize}px fantasy`;\n        const textWidth = this.context.measureText(text).width;\n        const textCanvasPosition = new Point(\n            Grid.GAME_WIDTH / 2,\n            textRenderSettings.topMargin);\n        this.context.fillText(\n            text,\n            textCanvasPosition.x - textWidth / 2,\n            textCanvasPosition.y - textRenderSettings.fontSize / 2);\n    }\n\n}","import { Point } from 'src/app/math/point';\nimport { Grid } from 'src/app/grid';\nimport { THEME } from 'src/app/theme';\nimport { LineSegment } from 'src/app/math/collision_detection';\n\nexport class Obstacle {\n    tileCoords: Point;\n\n    constructor(tileCoords: Point) {\n        this.tileCoords = tileCoords;\n    }\n\n    update(elapsedMs: number) {\n\n    }\n\n    render(context: CanvasRenderingContext2D): void {\n        const tileCanvasTopLeft = Grid.getCanvasFromTileCoords(this.tileCoords);\n        context.fillStyle = THEME.obstacleColor;\n        context.fillRect(\n            tileCanvasTopLeft.x, tileCanvasTopLeft.y,\n            Grid.TILE_SIZE, Grid.TILE_SIZE);\n    }\n\n    // TODO - cache after first construction.\n    getEdges(): LineSegment[] {\n        const topLeftCorner = Grid.getCanvasFromTileCoords(this.tileCoords);\n        const topRightCorner = topLeftCorner.add(new Point(Grid.TILE_SIZE, 0));\n        const bottomLeftCorner =\n            topLeftCorner.add(new Point(0, Grid.TILE_SIZE));\n        const bottomRightCorner =\n            topLeftCorner.add(new Point(Grid.TILE_SIZE, Grid.TILE_SIZE));\n        const topEdge =\n            new LineSegment(topLeftCorner, topRightCorner, new Point(0, -1));\n        const rightEdge =\n            new LineSegment(topRightCorner, bottomRightCorner, new Point(1, 0));\n        const bottomEdge =\n            new LineSegment(\n                bottomLeftCorner, bottomRightCorner, new Point(0, 1));\n        const leftEdge =\n            new LineSegment(topLeftCorner, bottomLeftCorner, new Point(-1, 0));\n        return [\n            topEdge,\n            rightEdge,\n            bottomEdge,\n            leftEdge,\n        ];\n    }\n}","import { ShotInfo } from 'src/app/shot_info';\nimport { Ray, LineSegment, detectRayLineSegmentCollision } from 'src/app/math/collision_detection';\nimport { Point, containsPoint } from 'src/app/math/point';\nimport { Character } from 'src/app/game_objects/character';\nimport { Obstacle } from 'src/app/game_objects/obstacle';\nimport { Target } from 'src/app/math/target';\nimport { Grid } from 'src/app/grid';\n\nexport function getRayForShot(shotInfo: ShotInfo): Ray {\n    const ray = new Ray(\n        shotInfo.fromCanvasCoords,\n        new Point(\n            Math.cos(shotInfo.aimAngleRadiansClockwise),\n            Math.sin(shotInfo.aimAngleRadiansClockwise)));\n    return ray;\n}\n\nexport function getRayForShot2(\n    fromCanvasCoords: Point, aimAngleRadiansClockwise: number): Ray {\n    return new Ray(\n        fromCanvasCoords,\n        new Point(\n            Math.cos(aimAngleRadiansClockwise),\n            Math.sin(aimAngleRadiansClockwise)));\n}\n\nexport function getProjectileTargetsPath(params: {\n    ray: Ray;\n    startingTileCoords: Point;\n    fromTeamIndex: number;\n    numRicochets: number;\n    characters: Character[];\n    obstacles: Obstacle[];\n}): Target[] {\n    const { ray,\n        fromTeamIndex,\n        startingTileCoords,\n        numRicochets,\n        characters,\n        obstacles } = params;\n    const targets: Target[] = [];\n    let pathsLeft = numRicochets + 1;\n    let currentTileCoords = startingTileCoords;\n    let currentRay = ray;\n    let hasHitCharacter = false;\n    const isTargetEnemyCharacter = (target: Target) => {\n        return characters\n            .filter((character) => {\n                return character.teamIndex !== params.fromTeamIndex;\n            })\n            .find((character) => {\n                return character.tileCoords.equals(target.tile);\n            }) != null;\n    };\n\n    while (pathsLeft > 0 && !hasHitCharacter) {\n        const target = getProjectileTarget({\n            ray: currentRay,\n            startTile: currentTileCoords,\n            fromTeamIndex,\n            obstacles,\n            characters,\n        });\n        targets.push(target);\n        hasHitCharacter = isTargetEnemyCharacter(target);\n        pathsLeft -= 1;\n        const newDirection = currentRay.direction\n            .reflect(target.normal!);\n        currentRay = new Ray(target.canvasCoords, newDirection);\n        currentTileCoords = target.tile;\n        if (target.isTargetGridBorder) {\n            hasHitCharacter = false;\n            currentTileCoords =\n                Grid.getTileFromCanvasCoords(\n                    target.canvasCoords.add(\n                        target.normal!.multiplyScaler(-Grid.TILE_SIZE / 2)));\n        }\n    }\n    return targets;\n}\n\nexport function getProjectileTarget(params: {\n    ray: Ray;\n    startTile: Point;\n    obstacles: Obstacle[];\n    characters: Character[];\n    fromTeamIndex: number;\n}): Target {\n    const { ray, fromTeamIndex, startTile } = params;\n    const gridBorderTarget: Target = getGridBorderTarget(ray);\n    const tileTarget = getTileTarget({\n        startTile,\n        ray,\n        obstacles: params.obstacles,\n        characters: params.characters,\n        maxDistance: ray.startPt.distanceTo(gridBorderTarget.canvasCoords),\n        fromTeamIndex,\n    });\n    const target = tileTarget != null ? tileTarget : gridBorderTarget;\n    return target;\n}\n\nfunction getGridBorderTarget(ray: Ray): Target {\n    // Find which game border the ray intersects.\n    const topLeftCanvas = new Point(0, 0);\n    const topRightCanvas = topLeftCanvas.add(new Point(Grid.GAME_WIDTH, 0));\n    const bottomLeftCanvas = topLeftCanvas.add(new Point(0, Grid.GAME_HEIGHT));\n    const bottomRightCanvas = topRightCanvas.add(bottomLeftCanvas);\n    const leftBorderSegment =\n        new LineSegment(topLeftCanvas, bottomLeftCanvas, new Point(1, 0));\n    const topBorderSegment =\n        new LineSegment(topLeftCanvas, topRightCanvas, new Point(0, 1));\n    const rightBorderSegment =\n        new LineSegment(topRightCanvas, bottomRightCanvas, new Point(-1, 0));\n    const bottomBorderSegment =\n        new LineSegment(bottomLeftCanvas, bottomRightCanvas, new Point(0, -1));\n    const borders = [\n        leftBorderSegment,\n        topBorderSegment,\n        rightBorderSegment,\n        bottomBorderSegment];\n    let gridBorderCollisionPt: Point | null = null;\n    let gridBorderCollisionTile: Point | null = null;\n    let borderNormal: Point | null = null;\n    for (const border of borders) {\n        const collisionResult = detectRayLineSegmentCollision(ray, border);\n        if (collisionResult.isCollision) {\n            borderNormal = border.normal;\n            // Move out from edge a little to accurately get tile.\n            const offset = borderNormal.multiplyScaler(Grid.TILE_SIZE * .05);\n            gridBorderCollisionPt = collisionResult.collisionPt!.add(offset);\n            gridBorderCollisionTile =\n                Grid.getTileFromCanvasCoords(gridBorderCollisionPt);\n            break;\n        }\n    }\n    if (gridBorderCollisionPt == null) {\n        debugger;\n        const a = detectRayLineSegmentCollision(ray, bottomBorderSegment);\n        const b = detectRayLineSegmentCollision(ray, rightBorderSegment);\n\n        throw new Error(`Shot ray does not intersect with any Grid`);\n    }\n    const hitCorner = (corner: Point): boolean => {\n        return Math.abs(corner.x - gridBorderCollisionPt!.x) < Grid.TILE_SIZE * .1\n            && Math.abs(corner.y - gridBorderCollisionPt!.y) < Grid.TILE_SIZE * .1;\n    };\n    // Ensure projectile stays in Grid bounds.\n    const inset = Grid.TILE_SIZE * .05;\n    if (hitCorner(topLeftCanvas)) {\n        gridBorderCollisionPt =\n            gridBorderCollisionPt.add(new Point(inset, inset));\n    } else if (hitCorner(topRightCanvas)) {\n        gridBorderCollisionPt =\n            gridBorderCollisionPt.add(new Point(-inset, inset));\n    } else if (hitCorner(bottomLeftCanvas)) {\n        gridBorderCollisionPt =\n            gridBorderCollisionPt.add(new Point(inset, -inset));\n    } else if (hitCorner(bottomRightCanvas)) {\n        gridBorderCollisionPt =\n            gridBorderCollisionPt.add(new Point(-inset, -inset));\n    }\n    const target: Target = {\n        normal: borderNormal!,\n        ray,\n        isTargetGridBorder: true,\n        canvasCoords: gridBorderCollisionPt!,\n        tile: gridBorderCollisionTile!,\n        maxDistance: ray.startPt.distanceTo(gridBorderCollisionPt!),\n    };\n    return target;\n}\n\nexport function mapTilePathToTargetsPath(\n    startTile: Point, tilePath: Point[]): Target[] {\n    const targets: Target[] = [];\n    let curTile = startTile;\n    const tileToCanvas = (tile: Point) =>\n        Grid.getCanvasFromTileCoords(tile).add(Grid.HALF_TILE);\n    let curCanvas = tileToCanvas(curTile);\n    for (const nextTile of tilePath) {\n        const nextCanvas = tileToCanvas(nextTile);\n        const direction = nextCanvas.subtract(curCanvas).normalize();\n        const target: Target = {\n            ray: new Ray(curCanvas, direction),\n            canvasCoords: nextCanvas,\n            tile: nextTile,\n            maxDistance: curCanvas.distanceTo(nextCanvas),\n        };\n        curTile = nextTile;\n        curCanvas = nextCanvas;\n        targets.push(target);\n    }\n    return targets;\n}\n\n/** Assumes only alive characters are passed in. */\nfunction getTileTarget(\n    params: {\n        startTile: Point;\n        ray: Ray;\n        obstacles: Obstacle[];\n        characters: Character[];\n        maxDistance: number;\n        fromTeamIndex: number;\n    }): Target | null {\n\n    const stepSize = 3 * Grid.TILE_SIZE / 4;\n    let curDistance = stepSize;\n    const currentTileString = params.startTile.toString();\n    const checkedTilesStringSet: Set<string> = new Set([currentTileString]);\n    let closestCollisionPt: Point | null = null;\n    let closestCollisionTile: Point | null = null;\n    let closestCollisionDistance = params.maxDistance;\n    let closestTargetNormal: Point | null = null;\n    const ray = params.ray;\n    const potentialTargetLocations =\n        params.obstacles\n            .map((obstacle) => obstacle.tileCoords)\n            .concat(params.characters.map((character) => character.tileCoords));\n    while (curDistance < params.maxDistance) {\n        const curTile = Grid.getTileFromCanvasCoords(\n            params.ray.pointAtDistance(curDistance));\n        const tilesToCheck =\n            [curTile]\n                .concat(Grid.getAdjacentTiles(curTile))\n                .filter((tile: Point) => !checkedTilesStringSet.has(tile.toString()));\n\n        for (const tile of tilesToCheck) {\n            checkedTilesStringSet.add(tile.toString());\n            if (!containsPoint(tile, potentialTargetLocations)) {\n                continue;\n            }\n            // Either an obstacle or player in tile.\n            const obstacle = params.obstacles\n                .find((obstacle) => obstacle.tileCoords.equals(tile));\n            if (obstacle) {\n                // Omit edges on opposite side of obstacle.\n                const edges = obstacle.getEdges()\n                    .filter((edge) => edge.normal.dot(ray.direction) <= 0);\n                for (const edge of edges) {\n                    const collisionResult =\n                        detectRayLineSegmentCollision(ray, edge);\n                    if (collisionResult.isCollision) {\n                        const distance =\n                            ray.startPt\n                                .distanceTo(collisionResult.collisionPt!);\n                        if (distance < closestCollisionDistance) {\n                            closestCollisionDistance = distance;\n                            closestCollisionTile = tile;\n                            closestCollisionPt = collisionResult.collisionPt!;\n                            closestTargetNormal = edge.normal;\n                        }\n                    }\n                }\n            } else {\n                const character = params.characters\n                    .find((character) => character.tileCoords.equals(tile));\n                if (!character) {\n                    throw new Error(\n                        `Tile is occupied but no obstacle or character...`);\n                }\n                if (character.teamIndex === params.fromTeamIndex) {\n                    // TODO - allow friendly fire?\n                    continue;\n                }\n                // Approximate with bounding box for now.\n                for (const edge of character.getEdges()) {\n                    const collisionResult =\n                        detectRayLineSegmentCollision(ray, edge);\n                    if (collisionResult.isCollision) {\n                        const distance =\n                            ray.startPt\n                                .distanceTo(collisionResult.collisionPt!);\n                        if (distance < closestCollisionDistance) {\n                            closestCollisionDistance = distance;\n                            closestCollisionTile = tile;\n                            closestCollisionPt = collisionResult.collisionPt!;\n                            closestTargetNormal = edge.normal;\n                        }\n                    }\n                }\n            }\n        }\n        if (closestCollisionPt != null) {\n            break;\n        }\n        curDistance += stepSize;\n    }\n    if (closestCollisionTile != null) {\n        const target: Target = {\n            normal: closestTargetNormal!,\n            isTargetGridBorder: false,\n            ray,\n            tile: closestCollisionTile!,\n            canvasCoords: closestCollisionPt!,\n            maxDistance: closestCollisionDistance,\n        };\n        return target;\n    }\n    return null;\n}","import { Point } from 'src/app/math/point';\nimport { Grid } from 'src/app/grid';\nimport { THEME } from 'src/app/theme';\nimport { LineSegment, Ray } from 'src/app/math/collision_detection';\nimport { ShotInfo, ProjectileDetailsType } from 'src/app/shot_info';\nimport { ActionType } from 'src/app/actions';\nimport { CharacterAbility, CharacterSettings, CharacterAbilityState, ThrowGrenadeAbility, ClassType, CharacterAbilityType } from 'src/app/character_settings';\nimport { AnimationState } from 'src/app/animation_state';\nimport { getProjectileTargetsPath, getRayForShot } from 'src/app/target_finder';\nimport { Target } from 'src/app/math/target';\n\nconst TWO_PI = Math.PI * 2;\n\nconst CHARACTER_CIRCLE_RADIUS = Grid.TILE_SIZE / 4;\n\ninterface GameDelegate {\n    getCurrentAimPath(params: {\n        ray: Ray;\n        startingTileCoords: Point;\n        fromTeamIndex: number;\n        numRicochets: number;\n    }): Target[];\n}\n\n/** Represents one squad member on a team. */\nexport class Character {\n    readonly teamIndex: number;\n    readonly settings: CharacterSettings;\n    readonly index: number;\n\n    // Turn-state.\n    hasMoved: boolean;\n    hasShot: boolean;\n    extraAbilities: CharacterAbility[];\n    isFinishedWithTurn: boolean;\n\n    private isAiming: boolean;\n    private aimAngleRadiansClockwise: number;\n    private aimPath: Target[];\n\n    // Game-state.\n    health: number;\n    tileCoords: Point;\n    characterAbilityTypeToAbilityState:\n        Map<CharacterAbilityType, CharacterAbilityState>;\n    animationState: AnimationState;\n    gameDelegate: GameDelegate;\n\n    constructor(params: {\n        startCoords: Point;\n        teamIndex: number;\n        index: number;\n        settings: CharacterSettings;\n        gameDelegate: GameDelegate;\n    }) {\n        this.gameDelegate = params.gameDelegate;\n        this.tileCoords = params.startCoords;\n        this.animationState = {\n            movementSpeedMs: Grid.TILE_SIZE * .005,\n            isAnimating: false,\n            remainingTargets: [],\n            currentCenterCanvas:\n                Grid.getCanvasFromTileCoords(this.tileCoords)\n                    .add(Grid.HALF_TILE),\n        }\n        this.teamIndex = params.teamIndex;\n        this.index = params.index;\n\n        this.settings = params.settings;\n\n        this.health = this.settings.maxHealth;\n        this.hasMoved = false;\n        this.characterAbilityTypeToAbilityState = new Map();\n        for (const extraAction of this.settings.extraActions) {\n            const actionState: CharacterAbilityState = {\n                cooldownTurnsLeft: 0,\n            };\n            if (extraAction.maxUses !== 0) {\n                actionState.usesLeft = extraAction.maxUses;\n            }\n            this.characterAbilityTypeToAbilityState\n                .set(extraAction.abilityType, actionState);\n        }\n        this.isAiming = false;\n        this.aimAngleRadiansClockwise = 0;\n        this.calculateTargetPath();\n\n        this.resetTurnState();\n    }\n\n    render(context: CanvasRenderingContext2D): void {\n        const tileTopLeftCanvas =\n            this.animationState.currentCenterCanvas.subtract(Grid.HALF_TILE);\n        const tileCenterCanvas = this.animationState.currentCenterCanvas;\n\n        context.fillStyle = this.getCharacterColor();\n        context.beginPath();\n        context.arc(\n            tileCenterCanvas.x,\n            tileCenterCanvas.y,\n            CHARACTER_CIRCLE_RADIUS,\n            0,\n            TWO_PI);\n        context.closePath();\n        context.fill();\n\n        // Character number.\n        const tileBottomLeftCanvas =\n            tileTopLeftCanvas.add(new Point(0, Grid.TILE_SIZE));\n        const text = `${this.index + 1}`;\n        context.fillStyle = THEME.characterTextColor;\n        const fontSize = 12;\n        const margins = new Point(Grid.TILE_SIZE / 12, Grid.TILE_SIZE / 12);\n        context.font = `${fontSize}px fantasy`;\n        context.fillText(\n            text,\n            tileBottomLeftCanvas.x + margins.x,\n            tileBottomLeftCanvas.y - margins.y);\n\n        // Health bar.\n        const healthBarHeight = Grid.TILE_SIZE / 10;\n        const healthBarWidth = 2 * CHARACTER_CIRCLE_RADIUS + healthBarHeight;\n        const fractionHealthLeft = this.health / this.settings.maxHealth;\n        const healthBarTopLeft = tileCenterCanvas\n            .add(new Point(\n                -healthBarWidth / 2,\n                -CHARACTER_CIRCLE_RADIUS - healthBarHeight * 2));\n        const remainingHealthWidth = healthBarWidth * fractionHealthLeft;\n        context.fillStyle = THEME.remainingHealthBarColor;\n        context.fillRect(\n            healthBarTopLeft.x, healthBarTopLeft.y,\n            remainingHealthWidth, healthBarHeight);\n        if (this.health !== this.settings.maxHealth) {\n            context.fillStyle = THEME.lostHealthBarColor;\n            context.fillRect(\n                healthBarTopLeft.x + remainingHealthWidth,\n                healthBarTopLeft.y,\n                healthBarWidth - remainingHealthWidth,\n                healthBarHeight);\n        }\n\n        // Class Symbol.\n        switch (this.settings.type) {\n            case ClassType.SCOUT:\n                // Boots.\n                const ankleWidth = CHARACTER_CIRCLE_RADIUS * .75;\n                const ankleHeight = CHARACTER_CIRCLE_RADIUS * .75;\n                const toeWidth = CHARACTER_CIRCLE_RADIUS * .75;\n                const toeHeight = ankleHeight / 2;\n                const topLeftBoot =\n                    tileCenterCanvas\n                        .add(new Point(-ankleWidth, -ankleHeight / 2));\n                context.fillStyle = '#804526';\n                context.fillRect(\n                    topLeftBoot.x, topLeftBoot.y,\n                    ankleWidth, ankleHeight);\n                context.fillRect(\n                    tileCenterCanvas.x,\n                    tileCenterCanvas.y,\n                    toeWidth, toeHeight);\n                break;\n\n            case ClassType.ASSAULT:\n                // Up-arrows.\n                context.fillStyle = '#e8d100';\n                const arrowWidth = CHARACTER_CIRCLE_RADIUS * .6;\n                const arrowHeight = CHARACTER_CIRCLE_RADIUS * .4;\n                const drawPathFrom = (start: Point) => {\n                    context.beginPath();\n                    context.moveTo(start.x, start.y);\n                    const offsets: Point[] = [\n                        new Point(0, -arrowHeight / 2),\n                        new Point(arrowWidth / 2, -arrowHeight),\n                        new Point(arrowWidth, -arrowHeight / 2),\n                        new Point(arrowWidth, 0),\n                        new Point(arrowWidth / 2, -arrowHeight / 2),\n                    ];\n                    for (const offset of offsets) {\n                        const pt = start.add(offset);\n                        context.lineTo(pt.x, pt.y);\n                    }\n                    context.closePath();\n                    context.fill();\n                };\n                const topArrowStart = tileCenterCanvas\n                    .add(new Point(-arrowWidth / 2, 0));\n                const bottomArrowStart = topArrowStart\n                    .add(new Point(0, arrowHeight * 1.5));\n                drawPathFrom(topArrowStart);\n                drawPathFrom(bottomArrowStart);\n                break;\n\n            case ClassType.SNIPER:\n                // Crosshair.\n                context.strokeStyle = '#1d1570';\n                context.fillStyle = '#1d1570';\n\n                // Plus.\n                const radius = CHARACTER_CIRCLE_RADIUS * .7;\n                const width = radius * 2;\n                const height = CHARACTER_CIRCLE_RADIUS * .2;\n                const horizontalTopLeft = tileCenterCanvas\n                    .add(new Point(-width / 2, -height / 2));\n                context.fillRect(\n                    horizontalTopLeft.x, horizontalTopLeft.y,\n                    width, height);\n                const verticalTopLeft = tileCenterCanvas\n                    .add(new Point(-height / 2, -width / 2));\n                context.fillRect(\n                    verticalTopLeft.x, verticalTopLeft.y,\n                    height, width);\n\n                // Circle.\n                context.beginPath();\n                context.arc(\n                    tileCenterCanvas.x, tileCenterCanvas.y, radius, 0, TWO_PI);\n                context.closePath();\n                context.stroke();\n                break;\n\n            case ClassType.DEMOLITION:\n\n                // Draw flame.\n                const flameWidth = CHARACTER_CIRCLE_RADIUS * .75;\n                const flameHeight = CHARACTER_CIRCLE_RADIUS * .85;\n                const drawFlameFrom = (start: Point) => {\n                    context.beginPath();\n                    context.moveTo(start.x, start.y);\n                    const offsets: Point[] = [\n                        new Point(flameWidth / 4, -flameHeight / 4),\n                        new Point(flameWidth / 2, -flameHeight / 2),\n                        new Point(flameWidth, -flameHeight / 4),\n                        new Point(flameWidth, 0),\n                        new Point(3 * flameWidth / 4, flameHeight / 2),\n                        new Point(flameWidth / 4, flameHeight / 2),\n                    ];\n                    for (const offset of offsets) {\n                        const pt = start.add(offset);\n                        context.lineTo(pt.x, pt.y);\n                    }\n                    context.closePath();\n                    context.fill();\n                };\n                const flameStart = tileCenterCanvas\n                    .add(new Point(-flameWidth / 2, 0));\n                const gradient = context.createLinearGradient(\n                    flameStart.x, flameStart.y - flameHeight,\n                    flameStart.x + flameWidth, flameStart.y);\n                const fullColor = '#f74d40';\n                const fadedColor = `#e8ba3c`;\n                gradient.addColorStop(0, fullColor);\n                gradient.addColorStop(1, fadedColor);\n                context.fillStyle = gradient;\n                drawFlameFrom(flameStart);\n                break;\n        }\n\n        // Aim indicator.\n        if (!this.isAiming) {\n            return;\n        }\n\n        context.strokeStyle = '#80585fbb';\n        const aimLength = this.settings.gun.aimIndicatorLength;\n        let startPt = tileCenterCanvas;\n        let distance = 0;\n        context.beginPath();\n        context.moveTo(startPt.x, startPt.y);\n        for (const target of this.aimPath) {\n            let endPt = target.canvasCoords;\n            const newDistance = startPt.distanceTo(endPt);\n            const isMaxLength = newDistance + distance > aimLength;\n            if (isMaxLength) {\n                const offset = endPt.subtract(startPt)\n                    .normalize()\n                    .multiplyScaler(aimLength - distance);\n                endPt = startPt.add(offset);\n            }\n            context.lineTo(endPt.x, endPt.y);\n            startPt = endPt;\n            distance += newDistance;\n            if (isMaxLength) {\n                break;\n            }\n        }\n        context.stroke();\n    }\n\n    getCurrentTile(): Point {\n        if (!this.animationState.isAnimating) {\n            return this.tileCoords;\n        }\n        return Grid.getTileFromCanvasCoords(\n            this.animationState.currentCenterCanvas);\n    }\n\n    moveTo(tileCoords: Point, targetsPath: Target[]): void {\n        if (this.isFinishedWithTurn || this.hasMoved) {\n            throw new Error(`Already moved.`);\n        }\n        this.animationState.currentCenterCanvas =\n            Grid.getCanvasFromTileCoords(this.tileCoords).add(Grid.HALF_TILE);\n        this.animationState.currentTarget = targetsPath.shift()!;\n        this.tileCoords = tileCoords;\n        this.animationState.remainingTargets = targetsPath;\n        this.animationState.isAnimating = true;\n        this.hasMoved = true;\n        this.checkAndSetTurnOver();\n    }\n\n    // TODO - look into sharing the animation update logic.\n    update(elapsedMs: number): void {\n        if (this.isAiming) {\n            this.calculateTargetPath();\n        }\n        if (!this.animationState.isAnimating) {\n            return;\n        }\n        const currentTarget = this.animationState.currentTarget!;\n        const direction = currentTarget.ray.direction;\n        const positionUpdate = direction\n            .multiplyScaler(this.animationState.movementSpeedMs * elapsedMs);\n        const distanceUpdate = positionUpdate.getMagnitude();\n\n        this.animationState.currentCenterCanvas =\n            this.animationState.currentCenterCanvas\n                .add(positionUpdate);\n        const totalDistanceTravelled = currentTarget.ray.startPt\n            .distanceTo(this.animationState.currentCenterCanvas);\n        if (totalDistanceTravelled < currentTarget.maxDistance) {\n            return;\n        }\n        // Ensure end state is centered in destination tile.\n        this.animationState.currentCenterCanvas = currentTarget.canvasCoords;\n        if (this.animationState.remainingTargets.length === 0) {\n            this.animationState.isAnimating = false;\n            return;\n        }\n\n        this.animationState.currentTarget =\n            this.animationState.remainingTargets.shift()!;\n    }\n\n    skipAnimation(): void {\n        const remainingTargets = this.animationState.remainingTargets;\n        const finalTargetIndex = remainingTargets.length - 1;\n        const finalTarget = remainingTargets.length > 0\n            ? this.animationState.remainingTargets[finalTargetIndex]\n            : this.animationState.currentTarget!;\n        this.animationState.currentCenterCanvas = finalTarget.canvasCoords;\n        this.animationState.remainingTargets = [];\n        this.animationState.isAnimating = false;\n    }\n\n    isAlive(): boolean {\n        return this.health > 0;\n    }\n\n    startAiming(): void {\n        if (!this.canShoot()) {\n            throw new Error(`Already shot or used non-free action.`);\n        }\n        this.isAiming = true;\n    }\n\n    cancelAiming(): void {\n        this.isAiming = false;\n    }\n\n    setAim(angle: number): void {\n        this.aimAngleRadiansClockwise = angle;\n    }\n\n    getAim(): number {\n        return this.aimAngleRadiansClockwise;\n    }\n\n    private calculateTargetPath(): void {\n        this.aimPath = this.gameDelegate.getCurrentAimPath({\n            ray: getRayForShot(this.getCurrentShotInfo()[0]),\n            startingTileCoords: this.tileCoords,\n            fromTeamIndex: this.teamIndex,\n            numRicochets: this.settings.gun.projectileDetails.numRicochets,\n        });\n    }\n\n    shoot(): ShotInfo[] {\n        if (!this.canShoot()) {\n            throw new Error(`Already shot or used non - free action.`);\n        }\n        this.isAiming = false;\n        this.hasShot = true;\n        this.extraAbilities = this.extraAbilities\n            .filter((ability: CharacterAbility) => {\n                return ability.isFree;\n            });\n        this.checkAndSetTurnOver();\n\n        return this.getCurrentShotInfo();\n    }\n\n    // TODO - shouldn't be public\n    getCurrentShotInfo(): ShotInfo[] {\n        // Shoot from center of tile.\n        const tileCenter =\n            Grid.getCanvasFromTileCoords(this.tileCoords).add(Grid.HALF_TILE);\n        const straightShotInfo: ShotInfo = {\n            fromTeamIndex: this.teamIndex,\n            fromTileCoords: this.tileCoords,\n            fromCanvasCoords: tileCenter,\n            aimAngleRadiansClockwise: this.aimAngleRadiansClockwise,\n            projectileDetails: this.settings.gun.projectileDetails,\n        };\n        const shotInfos: ShotInfo[] = [straightShotInfo];\n        if (this.settings.gun.spray) {\n            const spray = this.settings.gun.spray;\n            while (shotInfos.length < spray.projectiles) {\n                const offsetDirection = shotInfos.length % 2 === 0 ? 1 : -1;\n                const aimAngle =\n                    this.aimAngleRadiansClockwise\n                    + spray.offsetAngleRadians * offsetDirection;\n                shotInfos.push({\n                    fromTeamIndex: this.teamIndex,\n                    fromTileCoords: this.tileCoords,\n                    fromCanvasCoords: tileCenter,\n                    aimAngleRadiansClockwise: aimAngle,\n                    projectileDetails: this.settings.gun.projectileDetails,\n                });\n            }\n        }\n        return shotInfos;\n    }\n\n    getGrenadeAbility(): ThrowGrenadeAbility {\n        const grenadeAbility =\n            this.extraAbilities\n                .find((ability) => {\n                    return ability.abilityType ===\n                        CharacterAbilityType.THROW_GRENADE;\n                });\n        if (grenadeAbility == null) {\n            throw new Error(\n                `Trying to getGrenadeAction but character does not have ` +\n                `that action`);\n        }\n        return grenadeAbility as ThrowGrenadeAbility;\n    }\n\n    useAbility(abilityType: CharacterAbilityType): void {\n        const action = this.extraAbilities\n            .find((extraAbility) => extraAbility.abilityType === abilityType);\n        if (action == null) {\n            throw new Error(\n                `Character doesn't have ability for ActionType: ` +\n                `${abilityType}`);\n        }\n        this.extraAbilities = this.extraAbilities\n            .filter((extraAbility) => extraAbility.abilityType !== abilityType);\n        const actionState =\n            this.characterAbilityTypeToAbilityState.get(abilityType)!;\n        if (actionState.usesLeft) {\n            actionState.usesLeft -= 1;\n        }\n        actionState.cooldownTurnsLeft =\n            [...this.settings.extraActions]\n                .find((extraAction) => {\n                    return extraAction.abilityType === action.abilityType;\n                })!.cooldownTurns;\n        if (!action.isFree) {\n            // Character can't shoot and use non-free actions in same turn.\n            this.hasShot = true;\n            this.extraAbilities = this.extraAbilities\n                .filter((ability: CharacterAbility) => {\n                    return ability.isFree;\n                });\n        }\n        this.checkAndSetTurnOver();\n    }\n\n    regenHealth(amount: number): void {\n        this.health = Math.min(this.health + amount, this.settings.maxHealth);\n    }\n\n    // TODO - cache after first construction.\n    getEdges(): LineSegment[] {\n        const tileTopLeftCanvas = Grid.getCanvasFromTileCoords(this.tileCoords);\n        const tileCenterCanvas = tileTopLeftCanvas.add(Grid.HALF_TILE);\n        const topLeftCorner =\n            tileCenterCanvas.subtract(\n                new Point(CHARACTER_CIRCLE_RADIUS, CHARACTER_CIRCLE_RADIUS));\n        const topRightCorner =\n            topLeftCorner.add(new Point(CHARACTER_CIRCLE_RADIUS * 2, 0));\n        const bottomLeftCorner =\n            topLeftCorner.add(new Point(0, CHARACTER_CIRCLE_RADIUS * 2));\n        const bottomRightCorner =\n            topLeftCorner\n                .add(new Point(\n                    CHARACTER_CIRCLE_RADIUS * 2,\n                    CHARACTER_CIRCLE_RADIUS * 2));\n        const topEdge =\n            new LineSegment(topLeftCorner, topRightCorner, new Point(0, -1));\n        const rightEdge =\n            new LineSegment(topRightCorner, bottomRightCorner, new Point(1, 0));\n        const bottomEdge =\n            new LineSegment(\n                bottomLeftCorner, bottomRightCorner, new Point(0, 1));\n        const leftEdge =\n            new LineSegment(topLeftCorner, bottomLeftCorner, new Point(-1, 0));\n        return [\n            topEdge,\n            rightEdge,\n            bottomEdge,\n            leftEdge,\n        ];\n    }\n\n    isTurnOver(): boolean {\n        return this.isFinishedWithTurn;\n    }\n\n    setTurnOver(): void {\n        this.isFinishedWithTurn = true;\n        this.isAiming = false;\n    }\n\n    resetTurnState(): void {\n        this.hasMoved = false;\n        this.hasShot = false;\n        this.extraAbilities = [];\n        for (const extraAbility of this.settings.extraActions) {\n            const state =\n                this.characterAbilityTypeToAbilityState\n                    .get(extraAbility.abilityType);\n            if (!state) {\n                throw new Error(\n                    `Didn't initialize characterActionsToState for ` +\n                    `${extraAbility.abilityType}`);\n            }\n            if (state.usesLeft !== 0 && state.cooldownTurnsLeft <= 0) {\n                this.extraAbilities.push(extraAbility);\n            }\n            state.cooldownTurnsLeft -= 1;\n        }\n        this.isFinishedWithTurn = false;\n    }\n\n    private checkAndSetTurnOver(): void {\n        if (this.isFinishedWithTurn) {\n            return;\n        }\n        if (this.extraAbilities.some((extraAbility) => extraAbility.isFree)) {\n            // If free actions available, need to explicitly call setTurnOver.\n            return;\n        }\n        if (this.hasMoved\n            && (this.hasShot || !this.settings.gun.canFireAfterMoving)) {\n            this.setTurnOver();\n            return;\n        }\n        if (this.hasShot && !this.settings.gun.canFireAfterMoving) {\n            this.setTurnOver();\n            return;\n        }\n    }\n\n    private getCharacterColor(): string {\n        if (this.isFinishedWithTurn) {\n            return this.teamIndex === 0 ?\n                THEME.blueCharacterDoneColor : THEME.redCharacterDoneColor;\n        }\n        return this.teamIndex === 0 ?\n            THEME.blueCharacterReadyColor : THEME.redCharacterReadyColor;\n    }\n\n    canShoot(): boolean {\n        if (this.isFinishedWithTurn) {\n            return false;\n        }\n        if (!this.settings.gun.canFireAfterMoving && this.hasMoved) {\n            return false;\n        }\n        return !this.hasShot;\n    }\n}","import { Point } from 'src/app/math/point';\nimport { Flag } from 'src/app/game_objects/flag';\nimport { Obstacle } from 'src/app/game_objects/obstacle';\nimport { Character } from 'src/app/game_objects/character';\nimport { pathTo, Grid } from 'src/app/grid';\nimport { GameSettings } from './game_settings';\nimport { Spawner } from './game_objects/spawner';\n\nexport enum GamePhase {\n    // Setup.\n    CHARACTER_PLACEMENT,\n    // Main game.\n    COMBAT,\n}\n\nexport enum SelectedCharacterState {\n    AWAITING = 'AWAITING',\n    MOVING = 'MOVING',\n    AIMING = 'AIMING',\n    THROWING_GRENADE = 'THROWING_GRENADE',\n}\n\n\nconst DEFAULT_FLAG_VISIBILITY = 2;\n\nexport class GameState {\n    readonly settings: GameSettings;\n    gamePhase: GamePhase;\n    obstacles: Obstacle[];\n    characters: Character[];\n    spawners: Spawner[];\n    flags: Flag[];\n    currentTeamIndex: number;\n    selectableTiles: Point[];\n    selectedCharacter?: Character;\n    selectedCharacterState?: SelectedCharacterState;\n\n    constructor(settings: GameSettings) {\n        this.gamePhase = GamePhase.CHARACTER_PLACEMENT;\n        this.settings = settings;\n        this.obstacles = [];\n        this.characters = [];\n        this.flags = [];\n        this.currentTeamIndex = 0;\n        this.selectableTiles = [];\n    }\n\n    isFogOfWarOn(): boolean {\n        return this.settings.hasFogOfWar != null\n            && this.settings.hasFogOfWar === true;\n    }\n\n    isTileVisibleByTeamIndex(tile: Point, teamIndex: number): boolean {\n        for (const character of this.getCharactersForTeamIndex(teamIndex)) {\n            if (character.getCurrentTile().manhattanDistanceTo(tile)\n                <= character.settings.maxSight) {\n                return true;\n            }\n        }\n        const distToTeamFlag =\n            this.getFlagForTeamIndex(teamIndex).getCurrentTile()\n                .manhattanDistanceTo(tile);\n        if (distToTeamFlag <= DEFAULT_FLAG_VISIBILITY) {\n            return true;\n        }\n        return false;\n    }\n\n    getTilesVisibleByTeamIndex(teamIndex: number): Point[] {\n        const visibleTiles: Point[] = [];\n        for (let x = 0; x < Grid.TILES_WIDE; x++) {\n            for (let y = 0; y < Grid.TILES_TALL; y++) {\n                const tile = new Point(x, y);\n                if (this.isTileVisibleByTeamIndex(tile, teamIndex)) {\n                    visibleTiles.push(tile);\n                }\n            }\n        }\n        return visibleTiles;\n    }\n\n    getFirstCharacterIndex(): number {\n        const squad = this.getActiveSquad()\n            .filter((character) => !character.isTurnOver());\n        if (squad.length === 0) {\n            throw new Error(`No more characters alive - should be game over?`);\n        }\n        return squad[0].index;\n    }\n\n    getGameInfo(): { characters: Character[]; obstacles: Obstacle[] } {\n        return {\n            characters: this.getAliveCharacters(),\n            obstacles: this.obstacles,\n        }\n    }\n\n    getAliveCharacters(): Character[] {\n        return this.characters.filter((character) => character.isAlive());\n    }\n\n    getActiveTeamName(): string {\n        switch (this.currentTeamIndex) {\n            case 0:\n                return 'Blue';\n            case 1:\n                return 'Red';\n            default:\n                throw new Error(\n                    `Unsupported number of teams: ${this.currentTeamIndex}`);\n        }\n    }\n\n    getEnemyTeamName(): string {\n        switch (this.currentTeamIndex) {\n            case 1:\n                return 'Blue';\n            case 0:\n                return 'Red';\n            default:\n                throw new Error(\n                    `Unsupported number of teams: ${this.currentTeamIndex}`);\n        }\n    }\n\n    getActiveSquad(): Character[] {\n        return this.getAliveCharacters()\n            .filter((character) => character.teamIndex === this.currentTeamIndex);\n    }\n\n    getEnemyCharacters(): Character[] {\n        return this.getAliveCharacters()\n            .filter((character) => character.teamIndex !== this.currentTeamIndex);\n    }\n\n    getActiveTeamFlag(): Flag {\n        return this.flags\n            .find((flag) => flag.teamIndex === this.currentTeamIndex)!;\n    }\n\n    getEnemyFlag(): Flag {\n        return this.flags\n            .find((flag) => flag.teamIndex !== this.currentTeamIndex)!;\n    }\n\n    tileHasObstacle(tile: Point): boolean {\n        return this.obstacles\n            .find((obstacle) => obstacle.tileCoords.equals(tile)) != null;\n    }\n\n    enemyHasFlag(): boolean {\n        const teamFlagCoords = this.getActiveTeamFlag().tileCoords;\n        return this.getEnemyCharacters()\n            .find((character) => character.tileCoords.equals(teamFlagCoords)) != null;\n    }\n\n\n    teamHasFlag(): boolean {\n        const enemyFlagCoords = this.getEnemyFlag().tileCoords;\n        return this.getActiveSquad()\n            .find((character) => character.tileCoords.equals(enemyFlagCoords)) != null;\n    }\n\n    getPath({ from, to }: { from: Point; to: Point }): Point[] {\n        const isObstacleFree = (tile: Point): boolean => {\n            return !this.tileHasObstacle(tile);\n        };\n        return pathTo({\n            startTile: from,\n            endTile: to,\n            isAvailable: isObstacleFree,\n            canGoThrough: isObstacleFree,\n        });\n    }\n\n    isSquadMemberAtTile(tile: Point): boolean {\n        const squad = this.getActiveSquad();\n        return squad.find((squadMember: Character) => {\n            return squadMember.isAlive()\n                && squadMember.tileCoords.equals(tile)\n                && squadMember !== this.selectedCharacter;\n        }) != null;\n    }\n\n    getCharactersForTeamIndex(teamIndex: number): Character[] {\n        return this.getAliveCharacters().filter((character) => {\n            return character.teamIndex === teamIndex;\n        });\n    }\n\n    getFlagForTeamIndex(teamIndex: number): Flag {\n        return this.flags[teamIndex];\n    }\n}","\nexport enum LogType {\n    TARGET_FINDING = 'Targets',\n    AI = 'AI',\n    ACTIONS = 'Actions',\n}\n\nclass Logger {\n    logTypeToIsLogging: Map<LogType, boolean> = new Map([\n        [LogType.TARGET_FINDING, false],\n        [LogType.AI, true],\n        [LogType.ACTIONS, false],\n    ]);\n    logTypeToLogs: Map<LogType, string[]>;\n\n    constructor() {\n        this.logTypeToLogs = new Map([\n            [LogType.ACTIONS, []],\n            [LogType.AI, []],\n            [LogType.TARGET_FINDING, []],\n        ]);\n    }\n\n    log(type: LogType, log: string): void {\n        this.logTypeToLogs.get(type)!.push(log);\n        if (this.logTypeToIsLogging.get(type)!) {\n            console.log(log);\n        }\n    }\n}\n\nexport const LOGGER = new Logger();","\nexport function randomElement<T>(xs: T[]): T {\n    const index = Math.floor(Math.random() * xs.length);\n    return xs[index];\n}\n\n/** \n * @param probability expected to be in range [0, 1). \n * @return whether the event represented by the probability occurred.\n */\nexport function simulateProbability(probability: number): boolean {\n    return Math.random() <= probability;\n}","import { Action, ActionType, EndCharacterTurnAction, ShootAction, SelectCharacterStateAction, SelectTileAction, AimAction, SelectCharacterClassAction, HealAction } from 'src/app/actions';\nimport { Point } from 'src/app/math/point';\nimport { GameState, GamePhase, SelectedCharacterState } from 'src/app/game_state';\nimport { Character } from 'src/app/game_objects/character';\nimport { Grid, pathTo } from 'src/app/grid';\nimport { getProjectileTarget, getRayForShot, getRayForShot2 } from 'src/app/target_finder';\nimport { Target } from './math/target';\nimport { CharacterSettings, ASSAULT_CHARACTER_SETTINGS, SCOUT_CHARACTER_SETTINGS, CharacterAbilityType, HealAbility } from './character_settings';\nimport { AiDifficulty } from './game_settings';\nimport { randomElement } from './math/random';\nimport { LOGGER, LogType } from 'src/app/logger';\n\ninterface AiSettings {\n    /** If true, simply chooses any optimal tile instead of always the first. */\n    readonly randomizeMovement: boolean;\n    readonly maxAngleRandomization: number;\n\n    // Just delete... ?\n    readonly ignoresFogOfWar: boolean;\n    readonly characterClass: CharacterSettings;\n    readonly heals: boolean;\n}\n\nconst WEAK_AI_SETTINGS: AiSettings = {\n    randomizeMovement: false,\n    maxAngleRandomization: Math.PI / 18,\n    ignoresFogOfWar: false,\n    characterClass: SCOUT_CHARACTER_SETTINGS,\n    heals: false,\n};\n\nconst MEDIUM_AI_SETTINGS: AiSettings = {\n    randomizeMovement: true,\n    maxAngleRandomization: Math.PI / 24,\n    ignoresFogOfWar: false,\n    characterClass: ASSAULT_CHARACTER_SETTINGS,\n    heals: false,\n};\n\nconst STRONG_AI_SETTINGS: AiSettings = {\n    randomizeMovement: true,\n    maxAngleRandomization: 0,\n    ignoresFogOfWar: false,\n    characterClass: ASSAULT_CHARACTER_SETTINGS,\n    heals: false,\n};\n\nconst difficultyToSettings: Map<AiDifficulty, AiSettings> = new Map([\n    [AiDifficulty.WEAK, WEAK_AI_SETTINGS],\n    [AiDifficulty.MEDIUM, MEDIUM_AI_SETTINGS],\n    [AiDifficulty.STRONG, STRONG_AI_SETTINGS],\n])\n\ninterface ShotDetails {\n    readonly aimAngleClockwiseRadians: number;\n    readonly target: Target;\n}\n\ntype OnGetNextAction = (gameState: GameState) => Action;\n\nenum Priority {\n    /** Stays close to flag until detects enemy in direct sight. */\n    DEFEND = 'DEFEND',\n    /**\n     *  Moves in general direction of enemy flag, but prioritizes enemy \n     * characters whenever spotted.\n     */\n    ELIMINATE = 'ELIMINATE',\n    /** Goes for enemy flag, but also engages enemies along the way. */\n    SNAG = 'SNAG',\n}\n\nconst POST_ANIMATION_DELAY = 500;\n\nexport class Ai {\n\n    readonly difficulty: AiDifficulty;\n    readonly settings: AiSettings;\n    readonly teamIndex: number;\n    private actionQueue: OnGetNextAction[];\n    private characterIndexToPriority: Map<number, Priority>;\n\n    constructor({ teamIndex, difficulty }: { teamIndex: number; difficulty: AiDifficulty; }) {\n        this.teamIndex = teamIndex;\n        this.difficulty = difficulty;\n        this.log(`AI created on ${difficulty} difficulty`);\n        this.settings = difficultyToSettings.get(difficulty)!;\n        this.actionQueue = [];\n        this.characterIndexToPriority = new Map();\n    }\n\n    getNextAction(gameState: GameState): Action {\n        if (this.actionQueue.length === 0) {\n            this.actionQueue = this.getActionsForGameState(gameState);\n        }\n        const nextActionProducer = this.actionQueue.shift();\n        if (nextActionProducer == null) {\n            throw new Error(`AI couldn't get action to perform`);\n        }\n        const nextAction = nextActionProducer(gameState);\n        if (gameState.selectedCharacter != null) {\n            this.log(`selected character index - ` +\n                `${gameState.selectedCharacter!.index}`);\n        }\n        this.log(`AI: Taking action: ${JSON.stringify(nextAction)}`);\n        return nextAction;\n    }\n\n    private getActionsForGameState(gameState: GameState): OnGetNextAction[] {\n        if (gameState.gamePhase === GamePhase.CHARACTER_PLACEMENT) {\n            return this.placeCharacter(gameState);\n        }\n        if (gameState.selectedCharacter == null\n            || gameState.selectedCharacterState == null) {\n            throw new Error('Expected a selected character and state');\n        }\n        const selectedCharacter = gameState.selectedCharacter;\n        if (!this.characterIndexToPriority.has(selectedCharacter.index)) {\n            this.assignPriority(selectedCharacter.index, gameState);\n        }\n        const selectedCharacterState = gameState.selectedCharacterState;\n        const isFlagCarrier =\n            selectedCharacter.tileCoords\n                .equals(gameState.getEnemyFlag().tileCoords);\n        if (isFlagCarrier && !selectedCharacter.hasMoved) {\n            return this.getActionsForFlagCarrrier(selectedCharacter, gameState);\n        }\n        if (!selectedCharacter.hasMoved && !selectedCharacter.hasShot) {\n            return this.getHasntMovedNorShot(selectedCharacter, gameState);\n        }\n        if (!selectedCharacter.hasShot) {\n            const characterCenter =\n                getTileCenterCanvas(selectedCharacter.tileCoords);\n            const possibleShots =\n                this.getEnemyTargetsInDirectSight(characterCenter, gameState);\n            if (possibleShots.length > 0) {\n                return this.getShootSequence(\n                    this.getBestShot(\n                        selectedCharacter.tileCoords,\n                        gameState,\n                        possibleShots));\n            }\n        }\n\n        const canHeal =\n            this.settings.heals\n            && selectedCharacter.health < selectedCharacter.settings.maxHealth\n            && selectedCharacter.extraAbilities\n                .find((ability) => {\n                    return ability.abilityType === CharacterAbilityType.HEAL;\n                })\n            != null;\n        if (canHeal) {\n            const heal = (gameState: GameState) => {\n                const healAction: HealAction = {\n                    type: ActionType.HEAL,\n                    healAmount: (\n                        selectedCharacter.extraAbilities\n                            .find((ability) => {\n                                return ability.abilityType === CharacterAbilityType.HEAL;\n                            }) as HealAbility).healAmount,\n                }\n                return healAction;\n            };\n            return [heal];\n        }\n        const endTurn = (gameState: GameState) => {\n            const endTurnAction: EndCharacterTurnAction = {\n                type: ActionType.END_CHARACTER_TURN,\n            };\n            return endTurnAction;\n        };\n        return [endTurn];\n    }\n\n    private placeCharacter(gameState: GameState): OnGetNextAction[] {\n        const characterIndex = gameState.getActiveSquad().length;\n        this.assignPriority(characterIndex, gameState);\n        const priority = this.characterIndexToPriority.get(characterIndex)!;\n        const selectCharacterClass = (gameState: GameState) => {\n            const selectCharacterClassAction: SelectCharacterClassAction = {\n                type: ActionType.SELECT_CHARACTER_CLASS,\n                class: this.settings.characterClass,\n            };\n            return selectCharacterClassAction;\n        };\n\n        const thenSelectTile = (gameState: GameState) => {\n            let tile = gameState.selectableTiles[0];\n            let optimalTiles: Point[] = [];\n            if (priority === Priority.DEFEND) {\n                optimalTiles =\n                    this.getClosestSelectableTileToLocationWithFewestDirectHits(\n                        gameState.getActiveTeamFlag().tileCoords, gameState);\n            } else {\n                optimalTiles =\n                    this.getClosestSelectableTileToLocationWithFewestDirectHits(\n                        gameState.getEnemyFlag().tileCoords, gameState);\n            }\n            if (optimalTiles.length > 0) {\n                let selection = optimalTiles[0];\n                if (this.settings.randomizeMovement) {\n                    selection = randomElement(optimalTiles);\n                }\n                const action: SelectTileAction = {\n                    type: ActionType.SELECT_TILE,\n                    tile: selection,\n                };\n                return action;\n            }\n\n            this.log(\"AI: No optimal tiles in placement\");\n            const selectTileAction: SelectTileAction = {\n                type: ActionType.SELECT_TILE,\n                tile: gameState.selectableTiles[0],\n            };\n            return selectTileAction;\n        };\n        return [selectCharacterClass, thenSelectTile];\n    }\n\n    private getHasntMovedNorShot(character: Character, gameState: GameState):\n        OnGetNextAction[] {\n        const currentCharacterCenterCanvas =\n            getTileCenterCanvas(character.tileCoords);\n\n        const priority = this.characterIndexToPriority.get(character.index)!;\n\n\n        const possibleShots = this.getEnemyTargetsInDirectSight(\n            currentCharacterCenterCanvas, gameState);\n        if (possibleShots.length > 0) {\n            const shoot = this.getShootSequence(\n                this.getBestShot(\n                    character.tileCoords, gameState, possibleShots));\n            let characterMoveTargetTile: Point | null = null;\n            if (priority === Priority.DEFEND) {\n                characterMoveTargetTile =\n                    gameState.getActiveTeamFlag().tileCoords;\n            } else if (priority === Priority.ELIMINATE) {\n                const enemies = this.getVisibleEnemies(gameState);\n                if (enemies.length > 0) {\n                    let best: Array<{ dist: number; tile: Point; hp: number }>\n                        = [];\n                    for (const enemy of enemies) {\n                        const score = {\n                            dist: enemy.tileCoords.\n                                manhattanDistanceTo(character.tileCoords),\n                            tile: enemy.tileCoords,\n                            hp: enemy.health,\n                        };\n                        if (best.length === 0) {\n                            best.push(score);\n                        } else if (score.hp < best[0].hp || score.hp === best[0].hp && score.dist < best[0].dist) {\n                            best = [score];\n                        }\n                        else if (score.hp === best[0].hp && score.dist === best[0].dist) {\n                            best.push(score);\n                        }\n                    }\n                    characterMoveTargetTile = best[0].tile;\n                    if (this.settings.randomizeMovement) {\n                        characterMoveTargetTile = randomElement(best).tile;\n                    }\n                }\n                else {\n                    characterMoveTargetTile = gameState.enemyHasFlag()\n                        ? gameState.getActiveTeamFlag().tileCoords\n                        : gameState.getEnemyFlag().tileCoords;\n                }\n            } else {\n                characterMoveTargetTile = gameState.enemyHasFlag()\n                    ? gameState.getActiveTeamFlag().tileCoords\n                    : gameState.getEnemyFlag().tileCoords;\n            }\n            const safeMove =\n                this.getSafeMoveTowardsLocation(\n                    character, characterMoveTargetTile);\n            return shoot.concat(safeMove);\n        } else {\n            const startMoving = (gameState: GameState) => {\n                const startMovingAction: SelectCharacterStateAction = {\n                    type: ActionType.SELECT_CHARACTER_STATE,\n                    state: SelectedCharacterState.MOVING,\n                };\n                return startMovingAction;\n            };\n            const thenMove = (gameState: GameState) => {\n                const selectedCharacter = gameState.selectedCharacter!;\n                const characterIsFullyHealed =\n                    selectedCharacter.health === selectedCharacter.settings.maxHealth;\n                if (gameState.selectableTiles.length === 0) {\n                    this.log(`AI: No selectable tiles when able to move`);\n                    const endTurnAction: EndCharacterTurnAction = {\n                        type: ActionType.END_CHARACTER_TURN,\n                    };\n                    return endTurnAction;\n                }\n                const tileAndDirectHits:\n                    Array<{ tile: Point; directHits: number; }> = [];\n                for (const selectableTile of gameState.selectableTiles) {\n                    const tileCenterCanvas =\n                        getTileCenterCanvas(selectableTile);\n                    const directHitDetails =\n                        this.getEnemyTargetsInDirectSight(\n                            tileCenterCanvas, gameState);\n                    tileAndDirectHits.push({\n                        tile: selectableTile,\n                        directHits: directHitDetails.length,\n                    });\n                }\n                let optimalTiles: Point[] = [];\n                const enemies = this.getVisibleEnemies(gameState);\n                const bestTileAndHits = tileAndDirectHits\n                    .filter((tileAndHit) => {\n                        return tileAndHit.directHits === 1\n                            || (tileAndHit.directHits === 2\n                                && characterIsFullyHealed);\n                    });\n                if (bestTileAndHits.length > 0) {\n                    optimalTiles = bestTileAndHits.map(obj => obj.tile);\n                } else {\n                    let targetTile: Point | null = null;\n                    if (priority === Priority.DEFEND) {\n                        if (gameState.getActiveTeamFlag().isAtStart()) {\n                            const enemiesInSight =\n                                enemies.filter((enemy) => {\n                                    return (enemy.tileCoords\n                                        .manhattanDistanceTo(\n                                            selectedCharacter.tileCoords)\n                                        <= selectedCharacter.settings.maxSight);\n                                });\n                            if (enemies.length === 0\n                                || enemiesInSight.length === 0) {\n\n                                // Get any tile within x tiles of own team \n                                // flag to 'patrol';\n                                const x = 5;\n                                optimalTiles =\n                                    gameState.selectableTiles\n                                        .filter((tile) => {\n                                            return tile.manhattanDistanceTo(\n                                                gameState\n                                                    .getActiveTeamFlag()\n                                                    .tileCoords)\n                                                < x;\n                                        });\n                            } else {\n                                let best: Array<{ hp: number; tile: Point }> = [];\n                                for (const enemy of enemiesInSight) {\n                                    const score = {\n                                        hp: enemy.health,\n                                        tile: enemy.tileCoords,\n                                    };\n                                    if (best.length === 0) {\n                                        best.push(score);\n                                    } else if (enemy.health < best[0].hp) {\n                                        best = [score];\n                                    }\n                                    else if (enemy.health === best[0].hp) {\n                                        best.push(score);\n                                    }\n                                }\n                                targetTile = best[0].tile;\n                                if (this.settings.randomizeMovement) {\n                                    targetTile = randomElement(best).tile;\n                                }\n                            }\n                        } else {\n                            targetTile =\n                                gameState.getActiveTeamFlag().tileCoords;\n                        }\n                    } else if (priority === Priority.ELIMINATE) {\n                        if (enemies.length > 0) {\n                            let best:\n                                Array<{ dist: number; tile: Point; hp: number }>\n                                = [];\n                            for (const enemy of enemies) {\n                                const score = {\n                                    dist: enemy.tileCoords.\n                                        manhattanDistanceTo(\n                                            character.tileCoords),\n                                    tile: enemy.tileCoords,\n                                    hp: enemy.health,\n                                };\n                                if (best.length === 0) {\n                                    best.push(score);\n                                } else if (score.hp < best[0].hp\n                                    || score.hp === best[0].hp\n                                    && score.dist < best[0].dist) {\n                                    best = [score];\n                                }\n                                else if (score.hp === best[0].hp\n                                    && score.dist === best[0].dist) {\n                                    best.push(score);\n                                }\n                            }\n                            const possibleTiles = best.map((b) => b.tile);\n                            targetTile = possibleTiles[0];\n                            if (this.settings.randomizeMovement) {\n                                targetTile = randomElement(possibleTiles);\n                            }\n                        }\n                        else {\n                            targetTile = gameState.enemyHasFlag()\n                                ? gameState.getActiveTeamFlag().tileCoords\n                                : gameState.getEnemyFlag().tileCoords;\n                        }\n                    } else {\n                        targetTile = gameState.enemyHasFlag()\n                            ? gameState.getActiveTeamFlag().tileCoords\n                            : gameState.getEnemyFlag().tileCoords;\n                    }\n                    if (targetTile != null) {\n                        optimalTiles =\n                            this.getClosestSelectableTileToLocationWithFewestDirectHits(\n                                targetTile, gameState);\n                    }\n                }\n\n                let selection = optimalTiles[0];\n                if (this.settings.randomizeMovement) {\n                    selection = randomElement(optimalTiles);\n                }\n                if (selection == null) {\n                    const endTurnAction: EndCharacterTurnAction = {\n                        type: ActionType.END_CHARACTER_TURN,\n                    };\n                    return endTurnAction;\n                }\n                const selectTileAction: SelectTileAction = {\n                    type: ActionType.SELECT_TILE,\n                    tile: selection,\n                };\n                return selectTileAction;\n            };\n            return [startMoving, thenMove];\n        }\n    }\n\n    private getActionsForFlagCarrrier(\n        character: Character, gameState: GameState): OnGetNextAction[] {\n        // TODO - need to differentiate flag starting spot and flag current spot.\n        const teamFlagTile = gameState.getActiveTeamFlag().tileCoords;\n        return this.getSafeMoveTowardsLocation(character, teamFlagTile);\n    }\n\n    private getSafeMoveTowardsLocation(\n        character: Character, tileLocation: Point): OnGetNextAction[] {\n        const startMoving = (gameState: GameState) => {\n            const startMovingAction: SelectCharacterStateAction = {\n                type: ActionType.SELECT_CHARACTER_STATE,\n                state: SelectedCharacterState.MOVING,\n            };\n            return startMovingAction;\n        };\n        const thenMove = (gameState: GameState) => {\n            const bestTiles =\n                this.getClosestSelectableTileToLocationWithFewestDirectHits(\n                    tileLocation, gameState);\n            let selection = bestTiles[0];\n            if (this.settings.randomizeMovement) {\n                selection = randomElement(bestTiles);\n            }\n            if (selection == null) {\n                const endTurnAction: EndCharacterTurnAction = {\n                    type: ActionType.END_CHARACTER_TURN,\n                };\n                return endTurnAction;\n            }\n            const selectTileAction: SelectTileAction = {\n                type: ActionType.SELECT_TILE,\n                tile: selection,\n            };\n            return selectTileAction;\n        };\n        return [startMoving, thenMove];\n    }\n\n    private getClosestSelectableTileToLocationWithFewestDirectHits(\n        tileLocation: Point, gameState: GameState): Point[] {\n        let bestTile = {\n            tile: gameState.selectableTiles[0],\n            distance: 10000,\n            directHits: 100,\n        };\n        let optimalTiles: Point[] = [];\n        for (const selectableTile of gameState.selectableTiles) {\n            const pathToLocation =\n                getPathToLocation(selectableTile, tileLocation, gameState);\n            const tileCenterCanvas = getTileCenterCanvas(selectableTile)\n            const directHits = this.getEnemyTargetsInDirectSight(\n                tileCenterCanvas, gameState).length;\n            if (directHits < bestTile.directHits\n                || (directHits === bestTile.directHits\n                    && pathToLocation.length < bestTile.distance)) {\n                bestTile.tile = selectableTile;\n                bestTile.distance = pathToLocation.length;\n                bestTile.directHits = directHits;\n                optimalTiles = [bestTile.tile];\n            } else if (directHits === bestTile.directHits\n                && pathToLocation.length === bestTile.distance) {\n                optimalTiles.push(selectableTile);\n            }\n        }\n        return optimalTiles;\n    }\n\n    private getBestShot(\n        fromTile: Point, gameState: GameState, shots: ShotDetails[]):\n        ShotDetails {\n        // Best is flag carrier. \n        for (const shot of shots) {\n            if (shot.target.tile.equals(gameState.getActiveTeamFlag().tileCoords)) {\n                return shot;\n            }\n        }\n\n        // Then pick weakest, tie break by distance.\n        const enemyCharacters = gameState.getEnemyCharacters();\n        let best: { shot: ShotDetails, targetHealth: number, distance: number } | null = null;\n        for (const shot of shots) {\n            const targetCharacter = enemyCharacters\n                .find((character) => character.tileCoords.equals(shot.target.tile));\n            if (targetCharacter == null) {\n                throw new Error(\n                    `Expected a character at shot: ${JSON.stringify(shot)}`);\n            }\n            const targetHealth = targetCharacter.health;\n            const distance =\n                targetCharacter.tileCoords.manhattanDistanceTo(fromTile);\n            if ((best == null)\n                || (targetHealth < best.targetHealth)\n                || (targetHealth === best.targetHealth\n                    && distance < best.distance)) {\n                best = { shot, distance, targetHealth };\n            }\n        }\n        if (best == null) {\n            throw new Error(`Expected to find best shot in getBestShot`);\n        }\n        return best.shot;\n    }\n\n    private getShootSequence(shotDetails: ShotDetails): OnGetNextAction[] {\n        const startAiming = (gameState: GameState) => {\n            const startAimingAction: SelectCharacterStateAction = {\n                type: ActionType.SELECT_CHARACTER_STATE,\n                state: SelectedCharacterState.AIMING,\n            };\n            return startAimingAction;\n        };\n        const thenAim = (gameState: GameState) => {\n            const randomAimAdjustment =\n                Math.random()\n                * this.settings.maxAngleRandomization\n                * - this.settings.maxAngleRandomization / 2;\n            const aim =\n                shotDetails.aimAngleClockwiseRadians + randomAimAdjustment;\n            const takeAimAction: AimAction = {\n                type: ActionType.AIM,\n                aimAngleClockwiseRadians: aim,\n            };\n            return takeAimAction;\n        };\n        const thenShoot = (gameState: GameState) => {\n            const shootAction: ShootAction = {\n                type: ActionType.SHOOT,\n            };\n            return shootAction;\n        };\n        return [\n            startAiming,\n            thenAim,\n            thenShoot,\n        ];\n    }\n\n    private getEnemyTargetsInDirectSight(\n        fromCanvas: Point, gameState: GameState): ShotDetails[] {\n        const fromTile = Grid.getTileFromCanvasCoords(fromCanvas);\n        const shots: ShotDetails[] = [];\n        const visibleEnemies = this.getVisibleEnemies(gameState);\n        for (const enemy of visibleEnemies) {\n            const enemyCenter = getTileCenterCanvas(enemy.tileCoords);\n            const direction = enemyCenter.subtract(fromCanvas).normalize();\n            const aimAngleClockwiseRadians =\n                direction.getPointRotationRadians();\n            const target = getProjectileTarget({\n                ray: getRayForShot2(fromCanvas, aimAngleClockwiseRadians),\n                characters: gameState.getAliveCharacters(),\n                obstacles: gameState.obstacles,\n                fromTeamIndex: this.teamIndex,\n                startTile: fromTile,\n            });\n            if (target.tile.equals(enemy.tileCoords)) {\n                shots.push({\n                    aimAngleClockwiseRadians,\n                    target,\n                });\n            }\n        }\n        return shots;\n    }\n\n    private getVisibleEnemies(gameState: GameState): Character[] {\n        return gameState.getEnemyCharacters().filter((enemy) => {\n            if (this.settings.ignoresFogOfWar) {\n                return true;\n            }\n            return gameState.isTileVisibleByTeamIndex(\n                enemy.tileCoords, this.teamIndex);\n        });\n    }\n\n    private assignPriority(characterIndex: number, gameState: GameState): void {\n        const priority = this.getNextPriority(gameState);\n        this.log(`AI: Assigning priority: ${priority}`);\n        this.characterIndexToPriority.set(\n            characterIndex,\n            priority);\n    }\n\n    private getNextPriority(gameState: GameState): Priority {\n        const startingTeamSize =\n            gameState.settings\n                .teamIndexToSquadSize\n                .get(this.teamIndex)!;\n        const desiredDefenders = (1 / 4) * startingTeamSize;\n        const desiredSnaggers = (1 / 2) * startingTeamSize;\n        const desiredEliminators = (1 / 4) * startingTeamSize;\n        const defenders = gameState.getActiveSquad()\n            .filter((character) => {\n                const priority = this.characterIndexToPriority.get(character.index);\n                return priority != null && priority === Priority.DEFEND;\n            }).length;\n        if (defenders < desiredDefenders) {\n            return Priority.DEFEND;\n        }\n        const snaggers = gameState.getActiveSquad()\n            .filter((character) => {\n                const priority = this.characterIndexToPriority.get(character.index);\n                return priority != null && priority === Priority.SNAG;\n            }).length;\n        if (snaggers < desiredSnaggers) {\n            return Priority.SNAG;\n        }\n        return Priority.ELIMINATE;\n    }\n\n    private log(message: string) {\n        LOGGER.log(LogType.AI, message);\n    }\n}\n\nfunction getTileCenterCanvas(tile: Point): Point {\n    return Grid.getCanvasFromTileCoords(tile).add(Grid.HALF_TILE)\n}\n\nfunction getTileClosestTo(tiles: Point[], to: Point): Point {\n    let closestDistance = 10000;\n    let closestTile = tiles[0];\n    for (const tile of tiles) {\n        const distance = tile.manhattanDistanceTo(to)\n        if (distance < closestDistance) {\n            closestDistance = distance;\n            closestTile = tile;\n        }\n    }\n    return closestTile;\n}\n\nfunction getPathToLocation(\n    startTile: Point, tileLocation: Point, gameState: GameState): Point[] {\n    return gameState.getPath({\n        from: startTile,\n        to: tileLocation,\n    });\n}","import { Point } from 'src/app/math/point';\nimport { THEME } from '../theme';\nimport { Grid } from '../grid';\n\nexport class Spawner {\n\n    readonly tileCoords: Point;\n    readonly teamIndex: number;\n    readonly turnsBetweenSpawns: number;\n    private turnsSinceLastSpawn: number;\n\n    constructor(params: {\n        readonly tileCoords: Point;\n        readonly teamIndex: number;\n        readonly turnsBetweenSpawns: number;\n    }) {\n        this.tileCoords = params.tileCoords;\n        this.teamIndex = params.teamIndex;\n        this.turnsBetweenSpawns = params.turnsBetweenSpawns;\n        this.turnsSinceLastSpawn = 0;\n    }\n\n    update(elapsedMs: number): void {\n\n    }\n\n    advanceTurn(): void {\n        this.turnsSinceLastSpawn += 1;\n    }\n\n    checkAndHandleRespawn(): boolean {\n        if (this.turnsSinceLastSpawn === this.turnsBetweenSpawns) {\n            this.turnsSinceLastSpawn = 0;\n            return true;\n        }\n        return false;\n    }\n\n    render(context: CanvasRenderingContext2D): void {\n        context.strokeStyle = this.teamIndex === 0\n            ? THEME.blueCharacterReadyColor\n            : THEME.redCharacterReadyColor;\n\n        const tileCanvasCenter =\n            Grid.getCanvasFromTileCoords(this.tileCoords).add(Grid.HALF_TILE);\n        const radiansThick = Math.PI / 16;\n        const radiansOffset = Math.PI / 32;\n        let theta = 0;\n        const end = Math.PI * 2 - radiansThick;\n        const radius = Grid.TILE_SIZE * .4;\n        while (theta < end) {\n            context.beginPath();\n            context.arc(\n                tileCanvasCenter.x,\n                tileCanvasCenter.y,\n                radius,\n                theta,\n                theta + radiansThick,\n            );\n            context.stroke();\n            theta += radiansThick + radiansOffset;\n        }\n\n        // Indicate turns til next spawn.\n        const text = `${this.turnsBetweenSpawns - this.turnsSinceLastSpawn}`;\n        context.fillStyle = THEME.characterTextColor;\n        const fontSize = 12;\n        const margins = new Point(Grid.TILE_SIZE / 12, Grid.TILE_SIZE / 12);\n        context.font = `${fontSize}px fantasy`;\n        context.fillText(\n            text,\n            tileCanvasCenter.x - 3,\n            tileCanvasCenter.y + 1);\n    }\n}","import { Point } from 'src/app/math/point';\nimport { Element } from 'src/app/ui/element';\nimport { RENDER_SETTINGS } from 'src/app/render_settings';\n\n/*\n * All coordinates should be in the space [[0, 1] x [0, 1]]\n * Where (0, 0) is top left corner of canvas, and [1, 1] is bottom right.\n */\n\n/**\n * Manages a set of elements by:\n * - rendering them,\n * - checking if they are clicked/moused over\n */\nexport class UiManager {\n\n    private readonly context: CanvasRenderingContext2D;\n    private elements: Element[];\n\n    constructor(context: CanvasRenderingContext2D) {\n        this.context = context;\n        this.elements = [];\n    }\n\n    addElement(element: Element): void {\n        this.elements.push(element);\n    }\n\n    removeAll(): void {\n        this.elements = [];\n    }\n\n    removeElement(element: Element): void {\n        this.elements.splice(this.elements.indexOf(element), 1);\n    }\n\n    onMouseMove(canvasCoords: Point): void {\n        const uiCoords = this.getUiCoords(canvasCoords);\n        for (const element of this.elements) {\n            element.onMouseMove(uiCoords);\n        }\n    }\n\n    onClick(canvasCoords: Point): boolean {\n        const uiCoords = this.getUiCoords(canvasCoords);\n        for (const element of this.elements) {\n            if (element.onClick(uiCoords)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    render(): void {\n        for (const element of this.elements) {\n            element.render(this.context);\n        }\n    }\n\n    private getUiCoords(canvasCoords: Point): Point {\n        return new Point(\n            canvasCoords.x / RENDER_SETTINGS.canvasWidth,\n            canvasCoords.y / RENDER_SETTINGS.canvasHeight);\n    }\n}","import { Point } from 'src/app/math/point';\nimport { Element } from 'src/app/ui/element';\nimport { RENDER_SETTINGS } from 'src/app/render_settings';\n\n/*\n * All coordinates should be in the space [[0, 1] x [0, 1]]\n * Where (0, 0) is top left corner of canvas, and [1, 1] is bottom right.\n */\n\nexport interface TextBoxDimensions {\n    readonly topLeft: Point;\n    readonly size: Point;\n    readonly text: string;\n    readonly rows?: number;\n}\n\nexport interface TextBoxStyle {\n    readonly fontSize: number;\n    /** Hex strings. */\n    readonly color: string;\n    readonly textColor: string;\n}\n\nexport class TextBox implements Element {\n\n    /* Params */\n    private readonly topLeft: Point;\n    private readonly size: Point;\n    private readonly text: string;\n    private readonly fontSize: number;\n    /** Hex strings */\n    private readonly color: string;\n    private readonly textColor: string;\n\n    constructor({ dimensions, style }: {\n        dimensions: TextBoxDimensions;\n        style: TextBoxStyle;\n    }) {\n        this.topLeft = dimensions.topLeft;\n        this.size = dimensions.size;\n        this.text = dimensions.text;\n        this.fontSize = style.fontSize;\n        this.color = style.color;\n        this.textColor = style.textColor;\n    }\n\n    readonly render = (context: CanvasRenderingContext2D) => {\n        const topLeftCanvas = this.getCanvasCoords(this.topLeft);\n        const sizeCanvas = this.getCanvasCoords(this.size);\n        context.fillStyle = this.color\n        context.fillRect(\n            topLeftCanvas.x, topLeftCanvas.y, sizeCanvas.x, sizeCanvas.y);\n\n        context.fillStyle = this.textColor;\n        const fontSize = this.fontSize;\n        context.font = `${fontSize}px fantasy`;\n        const textWidth = context.measureText(this.text).width;\n        const boxCenterCanvas = this.getCanvasCoords(this.getBoxCenter());\n        context.fillText(\n            this.text,\n            boxCenterCanvas.x - textWidth / 2,\n            boxCenterCanvas.y + fontSize / 4);\n\n        // Border.\n        // context.strokeStyle = '#dd000a';\n        // context.strokeRect(topLeftCanvas.x, topLeftCanvas.y, \n        //     sizeCanvas.x, sizeCanvas.y);\n    };\n\n    readonly onClick = (uiCoords: Point): boolean => {\n        // No-op\n        return false;\n    };\n\n    readonly onMouseMove = (uiCoords: Point) => {\n        // No-op\n        return;\n    };\n\n    /** UI Coords. */\n    private getBoxCenter(): Point {\n        return new Point(this.topLeft.x + this.size.x / 2, this.topLeft.y + this.size.y / 2);\n    }\n\n    private getCanvasCoords(uiCoords: Point): Point {\n        return new Point(\n            uiCoords.x * RENDER_SETTINGS.canvasWidth,\n            uiCoords.y * RENDER_SETTINGS.canvasHeight);\n    }\n}","import { Point } from 'src/app/math/point';\nimport { Element } from 'src/app/ui/element';\nimport { RENDER_SETTINGS } from 'src/app/render_settings';\n\n/*\n * All coordinates should be in the space [[0, 1] x [0, 1]]\n * Where (0, 0) is top left corner of canvas, and [1, 1] is bottom right.\n */\n\nexport interface ButtonDimensions {\n    readonly topLeft: Point;\n    readonly size: Point;\n    readonly text: string;\n}\n\nexport interface ButtonStyle {\n    readonly fontSize: number;\n    /** Hex strings */\n    readonly color: string;\n    readonly hoverColor: string;\n    readonly textColor: string;\n\n    // Used for groups.\n    readonly selectedColor?: string;\n    readonly selectedBorderColor?: string;\n}\n\nexport class Button implements Element {\n\n    /* Params */\n    private readonly topLeft: Point;\n    private readonly size: Point;\n\n    private readonly text: string;\n    private readonly fontSize: number;\n\n    /** Hex strings */\n    private readonly color: string;\n    private readonly hoverColor: string;\n    private readonly textColor: string;\n\n    readonly selectedColor?: string;\n    readonly selectedBorderColor?: string;\n\n    private readonly onClickCallback: () => void;\n\n    /* State */\n    private isHovered: boolean;\n    private isSelected: boolean;\n\n    constructor({ dimensions, style, onClick }: {\n        dimensions: ButtonDimensions;\n        style: ButtonStyle;\n        onClick: () => void;\n    }) {\n        this.topLeft = dimensions.topLeft;\n        this.size = dimensions.size;\n        this.text = dimensions.text;\n        this.fontSize = style.fontSize;\n        this.color = style.color;\n        this.textColor = style.textColor;\n        this.hoverColor = style.hoverColor;\n        this.selectedColor = style.selectedColor;\n        this.selectedBorderColor = style.selectedBorderColor;\n        this.onClickCallback = onClick;\n\n        this.isHovered = false;\n        this.isSelected = false;\n    }\n\n    readonly render = (context: CanvasRenderingContext2D) => {\n        const topLeftCanvas = this.getCanvasCoords(this.topLeft);\n        const sizeCanvas = this.getCanvasCoords(this.size);\n        context.fillStyle = this.getFillColor();\n        context.fillRect(\n            topLeftCanvas.x, topLeftCanvas.y, sizeCanvas.x, sizeCanvas.y);\n\n        context.fillStyle = this.textColor;\n        const fontSize = this.fontSize;\n        context.font = `${fontSize}px fantasy`;\n        const textWidth = context.measureText(this.text).width;\n        const buttonCenterCanvas = this.getCanvasCoords(this.getButtonCenter());\n        context.fillText(\n            this.text,\n            buttonCenterCanvas.x - textWidth / 2,\n            buttonCenterCanvas.y + fontSize / 4);\n\n        if (!this.isSelected) {\n            return;\n        }\n        // Indicate selected.\n        if (this.selectedBorderColor == null) {\n            throw new Error(\n                `Selected border color should be set when button is selected`);\n        }\n        context.strokeStyle = this.selectedBorderColor;\n        context.strokeRect(\n            topLeftCanvas.x, topLeftCanvas.y, sizeCanvas.x, sizeCanvas.y);\n    };\n\n    private getFillColor(): string {\n        if (this.isSelected) {\n            return this.selectedColor!\n        }\n        return this.isHovered ? this.hoverColor : this.color;\n    }\n\n    /** For use by button group only. */\n    setIsSelected(isSelected: boolean): void {\n        this.isSelected = isSelected;\n    }\n\n    readonly onClick = (uiCoords: Point): boolean => {\n        if (this.isInButton(uiCoords)) {\n            this.onClickCallback();\n            return true;\n        }\n        return false;\n    };\n\n    readonly onMouseMove = (uiCoords: Point) => {\n        this.isHovered = this.isInButton(uiCoords);\n    };\n\n    private isInButton(uiCoords: Point): boolean {\n        const isX = uiCoords.x >= this.topLeft.x\n            && uiCoords.x <= (this.topLeft.x + this.size.x);\n        const isY = uiCoords.y >= this.topLeft.y\n            && uiCoords.y <= (this.topLeft.y + this.size.y);\n        return isX && isY;\n    }\n\n    /** UI Coords. */\n    private getButtonCenter(): Point {\n        return new Point(\n            this.topLeft.x + this.size.x / 2,\n            this.topLeft.y + this.size.y / 2);\n    }\n\n    private getCanvasCoords(uiCoords: Point): Point {\n        return new Point(\n            uiCoords.x * RENDER_SETTINGS.canvasWidth,\n            uiCoords.y * RENDER_SETTINGS.canvasHeight);\n    }\n}","import { Point } from 'src/app/math/point';\nimport { Element } from 'src/app/ui/element';\nimport { RENDER_SETTINGS } from 'src/app/render_settings';\nimport { Button, ButtonStyle, ButtonDimensions } from './button';\n\n\ninterface ButtonGroupParams {\n    readonly buttons: ButtonDimensions[];\n    readonly buttonStyle: ButtonStyle;\n\n    readonly initialSelectionIndex: number;\n    readonly onChangeCallback: (selectedIndex: number) => void;\n}\n\nexport class ButtonGroup implements Element {\n\n    private readonly buttons: Button[];\n    readonly onChangeCallback: (selectedIndex: number) => void;\n\n    /* State */\n    private currentlySelectedIndex: number;\n\n    constructor(params: ButtonGroupParams) {\n        this.buttons = [];\n        for (let index = 0; index < params.buttons.length; index++) {\n            const buttonParam = params.buttons[index];\n            this.buttons.push(new Button({\n                dimensions: {\n                    topLeft: buttonParam.topLeft,\n                    size: buttonParam.size,\n                    text: buttonParam.text,\n                },\n                style: {\n                    fontSize: params.buttonStyle.fontSize,\n                    /** Hex strings */\n                    color: params.buttonStyle.color,\n                    hoverColor: params.buttonStyle.hoverColor,\n                    textColor: params.buttonStyle.textColor,\n                    selectedColor: params.buttonStyle.selectedColor,\n                    selectedBorderColor: params.buttonStyle.selectedBorderColor,\n                },\n                onClick: () => {\n                    this.onButtonClicked(index);\n                },\n            }));\n        }\n        this.onChangeCallback = params.onChangeCallback;\n        this.currentlySelectedIndex = params.initialSelectionIndex;\n        this.buttons[this.currentlySelectedIndex].setIsSelected(true);\n    }\n\n    select(index: number): void {\n        for (const button of this.buttons) {\n            button.setIsSelected(false);\n        }\n        this.buttons[index].setIsSelected(true);\n    }\n\n    readonly render = (context: CanvasRenderingContext2D) => {\n        for (const button of this.buttons) {\n            button.render(context);\n        }\n    };\n\n    readonly onClick = (uiCoords: Point): boolean => {\n        for (const button of this.buttons) {\n            if (button.onClick(uiCoords)) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    readonly onMouseMove = (uiCoords: Point) => {\n        for (const button of this.buttons) {\n            button.onMouseMove(uiCoords);\n        }\n    };\n\n    private readonly onButtonClicked = (index: number) => {\n        if (index !== this.currentlySelectedIndex) {\n            this.buttons[this.currentlySelectedIndex].setIsSelected(false);\n            this.currentlySelectedIndex = index;\n            this.buttons[this.currentlySelectedIndex].setIsSelected(true);\n            this.onChangeCallback(this.currentlySelectedIndex);\n        }\n    };\n}","import { UiManager } from './ui/ui_manager';\nimport { Key, CONTROLS, ControlParams } from './controls';\nimport { Point } from './math/point';\nimport { TextBoxStyle, TextBox } from './ui/text_box';\nimport { ButtonStyle, ButtonDimensions, Button } from './ui/button';\nimport { THEME } from './theme';\nimport { Grid } from './grid';\nimport { ButtonGroup } from './ui/button_group';\nimport { RENDER_SETTINGS } from './render_settings';\n\nconst BG_COLOR = '#a68b8b';\n\nexport class ButtonPanel {\n\n    private readonly uiManager: UiManager;\n    private buttonGroup?: ButtonGroup;\n    private descriptionTextBoxes?: TextBox[];\n    private bottomButtons?: Button[];\n\n    private readonly borderWidth: number = 8;\n    private readonly leftEdgeCanvas = Grid.GAME_WIDTH;\n    private readonly leftUiCoord =\n        (Grid.GAME_WIDTH + this.borderWidth) / RENDER_SETTINGS.canvasWidth;\n    private readonly widthUi = 1 - this.leftUiCoord;\n    private readonly horizontalMargins = .01;\n    private readonly maxWidth = this.widthUi - (this.horizontalMargins * 2);\n    private readonly leftMargin = this.leftUiCoord + this.horizontalMargins;\n    private readonly maxWidthUi = 1 - this.leftMargin - this.horizontalMargins;\n    private readonly fontSize = 18;\n    private readonly descriptionFontSize = 16;\n    private readonly buttonOffsetY = .01;\n    private readonly buttonSize = new Point(this.maxWidth, .05);\n    private readonly headerSize = new Point(this.maxWidth, .025);\n\n    private buttonGroupBottomMargin: number;\n\n    private readonly headerStyle: TextBoxStyle = {\n        color: BG_COLOR,\n        fontSize: this.fontSize,\n        textColor: '#000000',\n    };\n    private readonly buttonStyle: ButtonStyle = {\n        fontSize: this.fontSize,\n        color: '#f7c25e',\n        hoverColor: '#deaf57',\n        selectedColor: '#db9d2a',\n        selectedBorderColor: '#000000',\n        textColor: THEME.buttonTextColor,\n    };\n\n    constructor(readonly context: CanvasRenderingContext2D) {\n        this.uiManager = new UiManager(context);\n    }\n\n    update(elapsedMs: number): void {\n\n    }\n\n    mouseMove(mouseCanvas: Point): void {\n        this.uiManager.onMouseMove(mouseCanvas);\n    }\n\n    tryClick(clickCanvas: Point): boolean {\n        return this.uiManager.onClick(clickCanvas);\n    }\n\n    render(context: CanvasRenderingContext2D): void {\n        // Background.\n        context.fillStyle = BG_COLOR;\n        context.fillRect(\n            this.leftEdgeCanvas, 0,\n            Grid.BUTTON_PANE_WIDTH, Grid.BUTTON_PANE_HEIGHT);\n\n        // Border.\n        context.fillStyle = '#000000';\n        context.fillRect(\n            this.leftEdgeCanvas, 0,\n            this.borderWidth, Grid.BUTTON_PANE_HEIGHT);\n\n        this.uiManager.render();\n    }\n\n    selectIndex(index: number): void {\n        if (this.buttonGroup === undefined) {\n            throw new Error(`No buttonGroup in selectIndex'`);\n        }\n        this.buttonGroup.select(index);\n    }\n\n    clear(): void {\n        this.buttonGroup = undefined;\n        this.clearBottomButtons();\n        this.clearDescription();\n        this.uiManager.removeAll();\n    }\n\n    configurePanel(params: {\n        headerTextLines: string[];\n        buttonInfos: ControlParams[];\n        isButtonGroup: boolean;\n    }): void {\n        const { headerTextLines, buttonInfos, isButtonGroup } = params;\n        const rows = headerTextLines.length;\n        let topMargin = .02;\n        for (let row = 0; row < rows; row++) {\n            const header = new TextBox({\n                dimensions: {\n                    size: this.headerSize,\n                    text: headerTextLines[row],\n                    topLeft: new Point(this.leftMargin, topMargin),\n                },\n                style: this.headerStyle,\n            });\n            this.uiManager.addElement(header);\n            topMargin += this.buttonOffsetY + this.headerSize.y;\n        }\n\n        const dimensions: ButtonDimensions[] = [];\n        const columnSize = 6;\n        for (let buttonIndex = 0; buttonIndex < buttonInfos.length; buttonIndex++) {\n            let row = buttonIndex % columnSize;\n            const topLeftY = topMargin + row * this.buttonOffsetY\n                + row * this.buttonSize.y;\n            const button = buttonInfos[buttonIndex];\n            dimensions.push({\n                topLeft: new Point(this.leftMargin, topLeftY),\n                size: this.buttonSize,\n                text: `${button.name} (${CONTROLS.getStringForKey(button.key)})`,\n            });\n        }\n\n        const initialSelectionIndex = 0;\n        const onChangeCallback = (index: number) => {\n            buttonInfos[index].func();\n        };\n        if (isButtonGroup) {\n            this.buttonGroup = new ButtonGroup({\n                buttons: dimensions,\n                buttonStyle: this.buttonStyle,\n                initialSelectionIndex: initialSelectionIndex,\n                onChangeCallback: onChangeCallback,\n            });\n            this.uiManager.addElement(this.buttonGroup);\n        } else {\n            for (let index = 0; index < buttonInfos.length; index++) {\n                const dimension = dimensions[index];\n                this.uiManager.addElement(new Button({\n                    dimensions: dimension,\n                    style: this.buttonStyle,\n                    onClick: buttonInfos[index].func,\n                }));\n            }\n        }\n        const lastButton = dimensions[dimensions.length - 1];\n        this.buttonGroupBottomMargin = lastButton.topLeft.y + lastButton.size.y;\n    }\n\n    setDescription(textLines: string[]): void {\n        const buttonsBottom = this.buttonGroupBottomMargin\n            + this.buttonOffsetY * 2;\n        let topMargin = buttonsBottom;\n        this.clearDescription();\n        const descriptionStyle: TextBoxStyle = {\n            fontSize: this.descriptionFontSize,\n            color: this.headerStyle.color,\n            textColor: this.headerStyle.textColor,\n        };\n        for (let row = 0; row < textLines.length; row++) {\n            const text = textLines[row];\n            this.context.font = `${this.descriptionFontSize}px fantasy`;\n            const width = this.context.measureText(text).width\n                / RENDER_SETTINGS.canvasWidth;\n            const size = new Point(width, this.headerSize.y);\n            const header = new TextBox({\n                dimensions: {\n                    size,\n                    text,\n                    topLeft: new Point(this.leftMargin, topMargin),\n                },\n                style: descriptionStyle,\n            });\n            this.descriptionTextBoxes!.push(header);\n            this.uiManager.addElement(header);\n            topMargin += this.headerSize.y - .002;\n        }\n    }\n\n    private clearDescription(): void {\n        if (this.descriptionTextBoxes == null) {\n            this.descriptionTextBoxes = [];\n            return;\n        }\n        for (const textBox of this.descriptionTextBoxes) {\n            this.uiManager.removeElement(textBox);\n        }\n        this.descriptionTextBoxes = [];\n    }\n\n    setBottomButtons(params: ControlParams[]): void {\n        this.clearBottomButtons();\n        let topY = 1 + (-this.buttonOffsetY - this.buttonSize.y) * params.length;\n        for (const param of params) {\n            const dimensions = {\n                topLeft: new Point(this.leftMargin, topY),\n                size: this.buttonSize,\n                text: `${param.name} (${CONTROLS.getStringForKey(param.key)})`,\n            };\n            const button = new Button({\n                dimensions,\n                style: this.buttonStyle,\n                onClick: param.func,\n            });\n            this.uiManager.addElement(button);\n            this.bottomButtons!.push(button);\n            topY += (this.buttonOffsetY + this.buttonSize.y);\n        }\n    }\n\n    private clearBottomButtons(): void {\n        if (this.bottomButtons != null && this.bottomButtons.length > 0) {\n            for (const button of this.bottomButtons) {\n                this.uiManager.removeElement(button);\n            }\n        }\n        this.bottomButtons = [];\n    }\n}","import { ControlMap, EventType, Key, ControlParams, numberToKey, numberToOrdinal, CONTROLS } from './controls';\nimport { ButtonPanel } from './button_panel';\nimport { Point } from './math/point';\nimport { GameState, SelectedCharacterState } from './game_state';\nimport { SelectCharacterStateAction, ActionType, Action, HealAction, AimAction, EndCharacterTurnAction, ShootAction, SelectTileAction, SelectCharacterClassAction, SelectCharacterAction } from './actions';\nimport { CharacterAbilityType, ClassType, CHARACTER_CLASSES, CharacterSettings, CharacterAbility, CharacterAbilityState } from './character_settings';\nimport { Grid } from './grid';\nimport { Gun, ProjectileDetailsType } from './shot_info';\nimport { Character } from './game_objects/character';\n\ninterface ClickHandler {\n    onClick: (tile: Point) => void;\n}\n\nconst PAUSE_KEY = Key.P;\nconst QUIT_KEY = Key.Q;\nconst RESTART_KEY = Key.R;\nconst MOVE_KEY = Key.M;\n/** Used to start and cancel shooting, but doesn't fire the shot.  */\nconst TOGGLE_AIM_KEY = Key.A;\nconst AIM_COUNTERCLOCKWISE_KEY = Key.S;\nconst AIM_CLOCKWISE_KEY = Key.D;\nconst SLOWER_AIM = Key.SHIFT;\nconst SHOOT_KEY = Key.F;\nconst HEAL_KEY = Key.H;\nconst TOGGLE_THROW_GRENADE_KEY = Key.T;\nconst END_TURN_KEY = Key.E;\n\nconst KEYS_TO_CHARACTER_CLASS_TYPE: Map<Key, ClassType> = new Map([\n    [Key.J, ClassType.SCOUT],\n    [Key.K, ClassType.ASSAULT],\n    [Key.L, ClassType.SNIPER],\n    [Key.I, ClassType.DEMOLITION],\n]);\n\ninterface GameManagerDelegate {\n    isPaused(): boolean;\n    getGameState(): GameState;\n    onAction(action: Action): void;\n    onQuit(): void;\n    onRestart(): void;\n    onTogglePause(): void;\n    setToastText(text: string): void;\n}\n\nexport class InputManager {\n\n    private controlMap: ControlMap;\n    private buttonPanel: ButtonPanel;\n    /** For arbitrary clicks on the game grid (ie not the button panel). */\n    private gameClickHandler: ClickHandler | null = null;\n\n    constructor(\n        readonly context: CanvasRenderingContext2D,\n        readonly delegate: GameManagerDelegate) {\n        this.controlMap = new ControlMap();\n        this.buttonPanel = new ButtonPanel(this.context);\n    }\n\n    clear(): void {\n        this.controlMap.clear();\n        this.buttonPanel.clear();\n        this.gameClickHandler = null;\n    }\n\n    render(): void {\n        this.buttonPanel.render(this.context);\n    }\n\n    update(elapsedMs: number): void {\n        this.controlMap.check();\n        this.buttonPanel.mouseMove(CONTROLS.getMouseCanvasCoords());\n        if (CONTROLS.hasClick()) {\n            const clickCanvas = CONTROLS.handleClick();\n            const clickedButtonPanel = this.buttonPanel.tryClick(clickCanvas);\n\n            if (!clickedButtonPanel) {\n                const mouseTileCoords =\n                    Grid.getTileFromCanvasCoords(clickCanvas);\n                if (this.gameClickHandler != null) {\n                    this.gameClickHandler.onClick(mouseTileCoords);\n                }\n            }\n        }\n    }\n\n    initDefaultControls(): void {\n        this.clear();\n        this.addDefaultControls();\n    }\n\n    initForCharacterPlacement(): void {\n        this.clear();\n        this.gameClickHandler = {\n            onClick: (tile: Point) => {\n                this.tryPlacingCharacter(tile);\n            }\n        };\n        this.addDefaultControls();\n        this.addCharacterClassControls();\n    }\n\n    initGameOverControls(): void {\n        this.clear();\n        this.addQuitAndRestartControls(true);\n        const quitKeyString = CONTROLS.getStringForKey(QUIT_KEY);\n        const restartKey = CONTROLS.getStringForKey(RESTART_KEY);\n        this.delegate.setToastText(\n            `Press ${quitKeyString} to quit, ${restartKey} to restart`);\n    }\n\n    initForSelectedCharacterState(): void {\n        this.clear();\n        const delegate = this.delegate;\n        const gameState = delegate.getGameState();\n        if (gameState.selectedCharacter == null\n            || gameState.selectedCharacterState == null) {\n            throw new Error(\n                `There needs to be a selected character ` +\n                `before calling setSelectedCharacterState`);\n        }\n        this.buttonPanel.clear();\n        this.controlMap.clear();\n        this.gameClickHandler = null;\n        this.addDefaultControls();\n        this.addSwitchSquadMemberControls();\n\n        const AIM_ANGLE_RADIANS_DELTA = Math.PI / 64;\n        const buttonInfos: ControlParams[] = [];\n        let headerTextLines: string[] = [];\n        switch (gameState.selectedCharacterState) {\n            case SelectedCharacterState.AWAITING:\n                headerTextLines = ['Available actions'];\n                if (!gameState.selectedCharacter.hasMoved) {\n                    buttonInfos.push({\n                        key: MOVE_KEY,\n                        name: 'Move',\n                        func: () => {\n                            const action: SelectCharacterStateAction = {\n                                type: ActionType.SELECT_CHARACTER_STATE,\n                                state: SelectedCharacterState.MOVING,\n                            };\n                            delegate.onAction(action);\n                        },\n                        eventType: EventType.KeyPress,\n                    });\n                }\n                if (gameState.selectedCharacter.canShoot()) {\n                    buttonInfos.push({\n                        key: TOGGLE_AIM_KEY,\n                        name: 'Aim',\n                        func: () => {\n                            const action: SelectCharacterStateAction = {\n                                type: ActionType.SELECT_CHARACTER_STATE,\n                                state: SelectedCharacterState.AIMING,\n                            };\n                            delegate.onAction(action);\n                        },\n                        eventType: EventType.KeyPress,\n                    });\n                }\n                for (const extraAbility of\n                    gameState.selectedCharacter.extraAbilities) {\n                    switch (extraAbility.abilityType) {\n                        case CharacterAbilityType.HEAL:\n                            buttonInfos.push({\n                                key: HEAL_KEY,\n                                name: 'Heal',\n                                func: () => {\n                                    const healAction: HealAction = {\n                                        type: ActionType.HEAL,\n                                        healAmount: extraAbility.healAmount,\n                                    };\n                                    delegate.onAction(healAction);\n                                },\n                                eventType: EventType.KeyPress,\n                            });\n                            break;\n                        case CharacterAbilityType.THROW_GRENADE:\n                            buttonInfos.push({\n                                key: TOGGLE_THROW_GRENADE_KEY,\n                                name: 'Throw grenade',\n                                func: () => {\n                                    const action: SelectCharacterStateAction = {\n                                        type: ActionType.SELECT_CHARACTER_STATE,\n                                        state: SelectedCharacterState.THROWING_GRENADE,\n                                    };\n                                    delegate.onAction(action);\n                                },\n                                eventType: EventType.KeyPress,\n                            });\n                            break;\n                    }\n                }\n                break;\n            case SelectedCharacterState.MOVING:\n                headerTextLines = ['Select a destination'];\n                this.gameClickHandler = {\n                    onClick: (tile: Point) => {\n                        this.tryMovingSelectedCharacter(tile);\n                    },\n                };\n                buttonInfos.push({\n                    key: MOVE_KEY,\n                    name: 'Cancel Move',\n                    func: () => {\n                        const action: SelectCharacterStateAction = {\n                            type: ActionType.SELECT_CHARACTER_STATE,\n                            state: SelectedCharacterState.AWAITING,\n                        };\n                        delegate.onAction(action);\n                    },\n                    eventType: EventType.KeyPress,\n                });\n                break;\n            case SelectedCharacterState.AIMING:\n                headerTextLines = ['Adjust aim and fire'];\n                buttonInfos.push({\n                    key: TOGGLE_AIM_KEY,\n                    name: 'Stop Aiming',\n                    func: () => {\n                        if (gameState.selectedCharacter == null) {\n                            throw new Error(\n                                `There's no selected character when canceling shooting.`);\n                        }\n                        const action: SelectCharacterStateAction = {\n                            type: ActionType.SELECT_CHARACTER_STATE,\n                            state: SelectedCharacterState.AWAITING,\n                        };\n                        delegate.onAction(action);\n                    },\n                    eventType: EventType.KeyPress,\n                });\n                buttonInfos.push({\n                    key: AIM_COUNTERCLOCKWISE_KEY,\n                    name: 'Aim CCW',\n                    func: () => {\n                        if (gameState.selectedCharacter == null) {\n                            throw new Error(\n                                `There's no selected character when aiming CCW.`);\n                        }\n                        let aimOffset = - AIM_ANGLE_RADIANS_DELTA;\n                        if (CONTROLS.isKeyDown(SLOWER_AIM)) {\n                            aimOffset += AIM_ANGLE_RADIANS_DELTA / 2;\n                        }\n                        const newAim =\n                            gameState.selectedCharacter.getAim() + aimOffset;\n                        const aimAction: AimAction = {\n                            type: ActionType.AIM,\n                            aimAngleClockwiseRadians: newAim,\n                        }\n                        delegate.onAction(aimAction);\n                    },\n                    eventType: EventType.KeyDown,\n                });\n                buttonInfos.push({\n                    key: AIM_CLOCKWISE_KEY,\n                    name: 'Aim CC',\n                    func: () => {\n                        if (gameState.selectedCharacter == null) {\n                            throw new Error(\n                                `There's no selected character when aiming CC.`);\n                        }\n                        let aimOffset = AIM_ANGLE_RADIANS_DELTA;\n                        if (CONTROLS.isKeyDown(SLOWER_AIM)) {\n                            aimOffset -= AIM_ANGLE_RADIANS_DELTA / 2;\n                        }\n                        const newAim =\n                            gameState.selectedCharacter.getAim() + aimOffset;\n                        const aimAction: AimAction = {\n                            type: ActionType.AIM,\n                            aimAngleClockwiseRadians: newAim,\n                        }\n                        delegate.onAction(aimAction);\n                    },\n                    eventType: EventType.KeyDown,\n                });\n                buttonInfos.push({\n                    key: SHOOT_KEY,\n                    name: 'Fire',\n                    func: () => {\n                        if (gameState.selectedCharacter == null) {\n                            throw new Error(\n                                `There's no selected character when canceling shooting.`);\n                        }\n                        const fireAction: ShootAction = {\n                            type: ActionType.SHOOT,\n                        };\n                        delegate.onAction(fireAction);\n                    },\n                    eventType: EventType.KeyPress,\n                });\n                break;\n            case SelectedCharacterState.THROWING_GRENADE:\n                headerTextLines = ['Select grenade target'];\n                this.gameClickHandler = {\n                    onClick: (tile: Point) => {\n                        this.tryThrowingGrenade(tile);\n                    },\n                };\n                buttonInfos.push({\n                    key: TOGGLE_THROW_GRENADE_KEY,\n                    name: 'Cancel',\n                    func: () => {\n                        const action: SelectCharacterStateAction = {\n                            type: ActionType.SELECT_CHARACTER_STATE,\n                            state: SelectedCharacterState.AWAITING,\n                        };\n                        delegate.onAction(action);\n                    },\n                    eventType: EventType.KeyPress,\n                });\n                break;\n            default:\n                throw new Error(`Unknown selected character state`);\n        }\n        buttonInfos.push({\n            key: END_TURN_KEY,\n            name: 'End character turn',\n            func: () => {\n                if (gameState.selectedCharacter == null) {\n                    throw new Error(\n                        `There's no selected character when ending turn.`);\n                }\n                const action: EndCharacterTurnAction = {\n                    type: ActionType.END_CHARACTER_TURN,\n                };\n                delegate.onAction(action);\n            },\n            eventType: EventType.KeyPress,\n        });\n        this.buttonPanel.configurePanel({\n            headerTextLines,\n            buttonInfos,\n            isButtonGroup: false,\n        });\n        this.buttonPanel\n            .setDescription(\n                getDescriptionForCharacter(gameState.selectedCharacter));\n        for (const buttonParam of buttonInfos) {\n            this.controlMap.add(buttonParam);\n        }\n    }\n\n    private tryPlacingCharacter(tileCoords: Point): void {\n        if (!this.delegate.getGameState().selectableTiles\n            .find((tile) => tile.equals(tileCoords))) {\n            this.delegate.setToastText(\n                `Can't place character here`);\n            return;\n        }\n\n        const placeCharacterAction: SelectTileAction = {\n            type: ActionType.SELECT_TILE,\n            tile: tileCoords,\n        };\n        this.delegate.onAction(placeCharacterAction);\n    }\n\n    private trySelectingCharacter(tileCoords: Point): void {\n        const squad = this.delegate.getGameState().getActiveSquad();\n        const squadMemeberAtTile =\n            squad.find((character) => character.tileCoords.equals(tileCoords));\n        if (squadMemeberAtTile && !squadMemeberAtTile.isTurnOver()) {\n            const selectCharacterAction: SelectCharacterAction = {\n                type: ActionType.SELECT_CHARACTER,\n                characterIndex: squadMemeberAtTile.index,\n            };\n            this.delegate.onAction(selectCharacterAction);\n        }\n    }\n\n    private tryMovingSelectedCharacter(tileCoords: Point): void {\n        if (!this.delegate.getGameState().selectableTiles\n            .find((tile) => tile.equals(tileCoords))) {\n            this.delegate.setToastText(`Can't move character here`);\n            return;\n        }\n\n        const selectTileAction: SelectTileAction = {\n            type: ActionType.SELECT_TILE,\n            tile: tileCoords,\n        };\n        this.delegate.onAction(selectTileAction);\n    }\n\n    private tryThrowingGrenade(tileCoords: Point): void {\n        if (!this.delegate.getGameState().selectableTiles\n            .find((tile) => tile.equals(tileCoords))) {\n            this.delegate.setToastText(`Can't throw grenade here`);\n            return;\n        }\n        const action: SelectTileAction = {\n            type: ActionType.SELECT_TILE,\n            tile: tileCoords,\n        };\n        this.delegate.onAction(action);\n    }\n\n    private addSwitchSquadMemberControls(): void {\n        const squad = this.delegate.getGameState().getActiveSquad();\n        this.gameClickHandler = {\n            onClick: (tile: Point) => {\n                this.trySelectingCharacter(tile);\n            },\n        };\n        // TODO - use tab instead of number for squad toggle controls.\n        for (const character of squad) {\n            if (character.index >= 9) {\n                continue;\n            }\n            // Use 1-based numbers for UI.\n            const characterNumber = character.index + 1;\n            const key = numberToKey.get(characterNumber);\n            if (key == null) {\n                throw new Error(`Not enough keys for all character numbers!`);\n            }\n            this.controlMap.add({\n                key,\n                name: `Select ${numberToOrdinal.get(characterNumber)} character`,\n                func: () => {\n                    const selectCharacterAction: SelectCharacterAction = {\n                        type: ActionType.SELECT_CHARACTER,\n                        characterIndex: character.index,\n                    };\n                    this.delegate.onAction(selectCharacterAction);\n                },\n                eventType: EventType.KeyPress,\n            });\n        }\n    }\n\n    private addDefaultControls(): void {\n        const params = {\n            key: PAUSE_KEY,\n            name: 'Pause',\n            func: () => { this.togglePause(); },\n            eventType: EventType.KeyPress,\n        };\n        this.controlMap.add(params);\n        this.buttonPanel.setBottomButtons([params]);\n    }\n\n    private addQuitAndRestartControls(isGameOver: boolean = false): void {\n        const params: ControlParams[] = [];\n        if (!isGameOver) {\n            params.push({\n                key: PAUSE_KEY,\n                name: 'Resume',\n                func: () => {\n                    this.togglePause();\n                    this.controlMap.remove(PAUSE_KEY);\n                    this.addDefaultControls();\n                },\n                eventType: EventType.KeyPress,\n            });\n        }\n        params.push({\n            key: RESTART_KEY,\n            name: 'Restart',\n            func: this.delegate.onRestart,\n            eventType: EventType.KeyPress,\n        },\n            {\n                key: QUIT_KEY,\n                name: 'Quit',\n                func: this.delegate.onQuit,\n                eventType: EventType.KeyPress,\n            });\n        for (const param of params) {\n            this.controlMap.add(param);\n        }\n        this.buttonPanel.setBottomButtons(params);\n    }\n\n    private addCharacterClassControls(): void {\n        const buttons: ControlParams[] = [];\n        for (const key of KEYS_TO_CHARACTER_CLASS_TYPE.keys()) {\n            const characterClassType = KEYS_TO_CHARACTER_CLASS_TYPE.get(key)!;\n            const params: ControlParams = {\n                key,\n                name: characterClassType,\n                func: () => {\n                    const selectCharacterClassAction:\n                        SelectCharacterClassAction = {\n                        type: ActionType.SELECT_CHARACTER_CLASS,\n                        class: getCharacterClassForType(characterClassType),\n                    };\n                    this.delegate.onAction(selectCharacterClassAction);\n                    const classIndex =\n                        [...KEYS_TO_CHARACTER_CLASS_TYPE.values()].findIndex(\n                            (clasz) => characterClassType === clasz)!\n                    this.buttonPanel.selectIndex(classIndex);\n                    const description =\n                        getDescriptionForClass(characterClassType);\n                    this.buttonPanel.setDescription(description);\n                },\n                eventType: EventType.KeyPress,\n            };\n            buttons.push(params);\n            this.controlMap.add(params);\n        }\n        this.buttonPanel.configurePanel({\n            headerTextLines: ['Select Character', 'Class to Place'],\n            buttonInfos: buttons,\n            isButtonGroup: true,\n        });\n        this.buttonPanel.setDescription(\n            getDescriptionForClass(CHARACTER_CLASSES[0].type));\n    }\n\n    private togglePause(): void {\n        const isNowPaused = !this.delegate.isPaused();\n        this.delegate.onTogglePause();\n        if (isNowPaused) {\n            // Re-used for 'resume' button.\n            this.controlMap.remove(PAUSE_KEY);\n            this.addQuitAndRestartControls();\n        } else {\n            this.controlMap.remove(QUIT_KEY);\n            this.controlMap.remove(RESTART_KEY);\n        }\n    }\n}\n\nfunction getCharacterClassForType(characterClassType: ClassType): CharacterSettings {\n    return CHARACTER_CLASSES.find((settings) => {\n        return settings.type === characterClassType;\n    })!\n}\n\nfunction getDescriptionForCharacter(character: Character): string[] {\n    const lines: string[] = [];\n    getCharacterClassForType(character.settings.type);\n    lines.push(\n        `HP: ${Math.round(character.health)} / ${character.settings.maxHealth}`,\n        `Moves: ${character.settings.maxMovesPerTurn}`,\n        `Sight: ${character.settings.maxSight}`,\n        ``,\n        `Gun:`,\n        ...getDescriptionForGun(character.settings.gun)\n            .map(line => '  ' + line),\n        ``,\n        'Abilities:',\n        ...getDescriptionsForExtraAbilityStates(character)\n            .map(line => '  ' + line),\n    );\n    return lines;\n}\n\nfunction getDescriptionForClass(characterClassType: ClassType): string[] {\n    const characterClass = getCharacterClassForType(characterClassType);\n    return [\n        `HP: ${characterClass.maxHealth}`,\n        `Moves: ${characterClass.maxMovesPerTurn}`,\n        `Sight: ${characterClass.maxSight}`,\n        ``,\n        `Gun:`,\n        ...getDescriptionForGun(characterClass.gun).map(line => '  ' + line),\n        ``,\n        'Abilities:',\n        ...getDescriptionsForExtraActions([...characterClass.extraActions])\n            .map(line => '  ' + line),\n    ];\n}\n\nfunction getDescriptionForGun(gun: Gun): string[] {\n    let projectileDetails: string[] = [];\n    if (gun.projectileDetails.type === ProjectileDetailsType.BULLET) {\n        const sprayDetails = gun.spray ? `(x${gun.spray.projectiles})` : ``;\n        projectileDetails = [\n            `Projectile type: bullet`,\n            `Damage: ${gun.projectileDetails.damage}` + sprayDetails,\n            `Max ricochets: ${gun.projectileDetails.numRicochets}`,\n        ];\n    } else {\n        projectileDetails = [\n            `Projectile type: explosive`,\n            `Damage: ${gun.projectileDetails.damage}`,\n            `Damage radius: ` +\n            `${gun.projectileDetails.damageManhattanDistanceRadius}`,\n            `Max ricochets: ${gun.projectileDetails.numRicochets}`,\n        ];\n    }\n    const text = [\n        ...projectileDetails,\n    ];\n    if (!gun.canFireAfterMoving) {\n        text.push(`Can't shoot after moving`);\n    }\n    return text;\n}\n\nfunction getDescriptionsForExtraActions(\n    extraAbilities: CharacterAbility[]): string[] {\n    const lines: string[] = [];\n    for (const extraAbility of extraAbilities) {\n        lines.push('');\n        lines.push(...getExtraAbilityDescription(extraAbility));\n    }\n    return lines;\n}\n\nfunction getDescriptionsForExtraAbilityStates(\n    character: Character): string[] {\n\n    const lines: string[] = [];\n    const typeToState = character.characterAbilityTypeToAbilityState;\n    for (const extraAbilityType of typeToState.keys()) {\n        const state = typeToState.get(extraAbilityType)!;\n        if (state.usesLeft == null || state.usesLeft <= 0) {\n            continue;\n        }\n        lines.push('');\n        const extraAbility = [...character.settings.extraActions]\n            .find((ability) => ability.abilityType === extraAbilityType)!;\n        const extraAbilityDescription =\n            getExtraAbilityDescription(extraAbility);\n        for (let row = 0; row < extraAbilityDescription.length; row++) {\n            const line = extraAbilityDescription[row];\n            if (line.indexOf('Max uses') > 0) {\n                extraAbilityDescription[row] = `  Uses left: ${state.usesLeft}`;\n            } else if (line.indexOf('Cooldown turns') > 0) {\n                if (state.cooldownTurnsLeft > 0) {\n                    extraAbilityDescription[row] =\n                        `  Cooling down (${state.cooldownTurnsLeft} turns til ready)`;\n                } else {\n                    extraAbilityDescription[row] = `  Ready to use`;\n                }\n            }\n        }\n        lines.push(...extraAbilityDescription);\n    }\n    return lines;\n}\n\nfunction getExtraAbilityDescription(extraAbility: CharacterAbility): string[] {\n    const lines: string[] = [];\n    if (extraAbility.abilityType === CharacterAbilityType.HEAL) {\n        lines.push(\n            `Heal`,\n            `  Heal amount: ${extraAbility.healAmount}`,\n        );\n    } else {\n        lines.push(\n            `Grenade`,\n            `  Damage: ${extraAbility.splashDamage.damage}`,\n            `  Damage radius: ${extraAbility.splashDamage.damageManhattanDistanceRadius}`,\n            `  Range: ${extraAbility.maxManhattanDistance}`);\n    }\n    lines.push(`  Max uses: ${extraAbility.maxUses}`);\n    if (extraAbility.maxUses > 1) {\n        lines.push(`  Cooldown turns: ${extraAbility.cooldownTurns}`);\n    }\n    if (extraAbility.isFree) {\n        lines.push(`  Can also shoot`);\n    } else {\n        lines.push(`  Can't use and shoot`);\n    }\n    return lines;\n}","import { RENDER_SETTINGS } from 'src/app/render_settings';\nimport { Grid, bfs, pathTo } from 'src/app/grid';\nimport { Point, pointFromSerialized, containsPoint } from 'src/app/math/point';\nimport { CONTROLS, ControlMap, ControlParams, EventType, Key, numberToKey, numberToOrdinal } from 'src/app/controls';\nimport { THEME } from 'src/app/theme';\nimport { LEVELS } from 'src/app/level';\nimport { GameSettings, MatchType, AiDifficulty } from 'src/app/game_settings';\nimport { Ray, LineSegment, detectRayLineSegmentCollision } from 'src/app/math/collision_detection';\nimport { ShotInfo, ProjectileDetailsType, Bullet, ProjectileDetails, SplashDamage } from 'src/app/shot_info';\nimport { Action, ActionType, throwBadAction, HealAction, EndCharacterTurnAction, ShootAction, SelectCharacterStateAction, AimAction, SelectTileAction, SelectCharacterAction, SelectCharacterClassAction } from 'src/app/actions';\nimport { CharacterSettings, HealAbility, ASSAULT_CHARACTER_SETTINGS, ClassType, CHARACTER_CLASSES, CharacterAbilityType } from 'src/app/character_settings';\nimport { Flag } from 'src/app/game_objects/flag';\nimport { Projectile } from 'src/app/game_objects/projectile';\nimport { ParticleSystem, ParticleShape, ParticleSystemParams } from 'src/app/game_objects/particle_system';\nimport { Hud, TextType, Duration } from 'src/app/hud';\nimport { Obstacle } from 'src/app/game_objects/obstacle';\nimport { Character } from 'src/app/game_objects/character';\nimport { Ai } from 'src/app/ai';\nimport { GamePhase, SelectedCharacterState, GameState } from 'src/app/game_state';\nimport { GameModeManager } from 'src/app/game_mode_manager';\nimport { getRayForShot, getProjectileTargetsPath, mapTilePathToTargetsPath } from 'src/app/target_finder';\nimport { Target } from 'src/app/math/target';\nimport { AnimationState } from 'src/app/animation_state';\nimport { getGrenadeSmokeParticleSystemParams, getGrenadeBurstParticleSystemParams, getBulletParticleSystemParams, getHealParticleSystemParams } from './particle_system_theme';\nimport { Spawner } from './game_objects/spawner';\nimport { InputManager } from './input_manager';\nimport { LOGGER, LogType } from './logger';\n\nconst ALLOW_ELIMINATION_VICTORY_WITH_SPAWNERS = false;\nconst DEFAULT_HUMAN_TEAM_INDEX = 0;\n\nexport class GameManager implements GameModeManager {\n\n    private readonly canvas: HTMLCanvasElement;\n    private readonly context: CanvasRenderingContext2D;\n    private readonly levelIndex: number;\n    private readonly gameSettings: GameSettings;\n    private readonly onExitGameCallback:\n        (winningTeamIndex: number) => void;\n\n    private isGameOver: boolean;\n    private isPaused: boolean;\n    private winningTeamIndex: number;\n    private hud: Hud;\n    private inputManager: InputManager;\n    private onAnimationDone: (() => void) | null = null;\n    private gameState: GameState;\n\n    private selectedCharacterSettings: CharacterSettings;\n    private projectiles: Projectile[];\n    private particleSystems: ParticleSystem[];\n\n    private teamIndexToIsAi: boolean[];\n    private ais: Ai[];\n\n    constructor(\n        canvas: HTMLCanvasElement,\n        context: CanvasRenderingContext2D,\n        params: {\n            gameSettings: GameSettings;\n            levelIndex: number;\n            onExitGameCallback: (winningTeamIndex: number) => void;\n        }) {\n\n        this.canvas = canvas;\n        this.context = context;\n        this.gameSettings = params.gameSettings;\n        this.levelIndex = params.levelIndex;\n        this.onExitGameCallback = params.onExitGameCallback;\n        this.resetGame();\n    }\n\n    isAnimating(): boolean {\n        const animatables: { animationState: AnimationState }[] = [\n            ...this.gameState.getAliveCharacters(),\n            ...this.projectiles];\n        return animatables\n            .some((animatable) => {\n                return animatable.animationState.isAnimating;\n            });\n    }\n\n    update(elapsedMs: number): void {\n        this.inputManager.update(elapsedMs);\n\n        if (this.isPaused) {\n            return;\n        }\n\n        for (const particleSystem of this.particleSystems) {\n            particleSystem.update(elapsedMs);\n        }\n        this.particleSystems = this.particleSystems\n            .filter((particleSystem) => particleSystem.isAlive);\n\n        for (const projectile of this.projectiles) {\n            this.updateProjectile(elapsedMs, projectile);\n        }\n        this.projectiles = this.projectiles\n            .filter((projectile) => {\n                return !projectile.isDead || !projectile.isTrailGone();\n            });\n        for (const character of this.gameState.getAliveCharacters()) {\n            character.update(elapsedMs);\n            if (character.animationState.isAnimating\n                && this.shouldSkipAnimation(character)) {\n                character.skipAnimation();\n            }\n        }\n        this.hud.update(elapsedMs);\n\n        if (!this.isAnimating() && this.onAnimationDone != null) {\n            this.onAnimationDone();\n            this.onAnimationDone = null;\n        }\n\n        if (this.gameState.gamePhase !== GamePhase.CHARACTER_PLACEMENT\n            && this.gameState.getActiveSquad()\n                .filter(character => {\n                    return !character.isTurnOver();\n                }).length === 0) {\n            // Should automatically skip turn with delay \n            // when team is out of characters but need update \n            // loop to run for spawners...\n            return;\n        }\n\n        if (this.isAiTurn() && !this.isAnimating()) {\n            const nextAction = this.getCurrentTurnAi()\n                .getNextAction(this.getGameState());\n            this.onAction(nextAction);\n        }\n    }\n\n    private updateProjectile(\n        elapsedMs: number, projectile: Projectile): void {\n\n        projectile.update(elapsedMs);\n        if (projectile.isDead || !projectile.isAtFinalTarget()) {\n            return;\n        }\n        const finalTarget = projectile.getCurrentTarget();\n        const hitPositionCanvas = finalTarget.canvasCoords;\n        if (projectile.projectileDetails.type === ProjectileDetailsType.SPLASH) {\n            const splashDamage = projectile.projectileDetails;\n            this.particleSystems.push(new ParticleSystem(\n                getGrenadeSmokeParticleSystemParams(hitPositionCanvas)));\n            this.particleSystems.push(new ParticleSystem(\n                getGrenadeBurstParticleSystemParams(hitPositionCanvas)));\n            const hitTiles = bfs({\n                startTile: finalTarget.tile,\n                maxDepth: splashDamage.damageManhattanDistanceRadius,\n                isAvailable: (tile: Point) => {\n                    return true;\n                },\n                canGoThrough: (tile: Point) => {\n                    return true;\n                },\n            });\n            for (const hitTile of hitTiles) {\n                const targetCharacter = this.gameState.getAliveCharacters()\n                    .find((character) => character.tileCoords.equals(hitTile));\n                if (targetCharacter) {\n                    const manhattanDistance = targetCharacter.tileCoords\n                        .manhattanDistanceTo(finalTarget.tile);\n                    const damageReduction =\n                        Math.pow(\n                            splashDamage.tilesAwayDamageReduction,\n                            manhattanDistance);\n                    const damage = splashDamage.damage * damageReduction\n                    targetCharacter.health -= damage;\n                }\n            }\n        } else {\n            const targetCharacter = this.gameState.getAliveCharacters()\n                .find((character) => {\n                    return character.tileCoords.equals(finalTarget.tile);\n                });\n            if (targetCharacter\n                && targetCharacter !== this.gameState.selectedCharacter!\n                // Avoid edge case ;) where bullet hits wall and\n                // not actually the character at the tile specified\n                && !finalTarget.isTargetGridBorder) {\n\n                // Assumes friendly fire check occurred in 'fireShot'.\n                targetCharacter.health -= projectile.projectileDetails.damage;\n            }\n            this.particleSystems.push(new ParticleSystem(\n                getBulletParticleSystemParams(hitPositionCanvas)));\n        }\n        projectile.setIsDead();\n\n        // Recalculate other projectile targets \n        // as they may have been going towards a\n        // now destroyed character or obstacle.\n        for (const otherProjectile of this.projectiles\n            .filter((otherOtherProjectile) => !otherOtherProjectile.isDead)) {\n            // const canvasCoords =\n            //     otherProjectile.animationState.currentCenterCanvas;\n            const currentRay = otherProjectile.getCurrentTarget().ray;\n            const newTargets = getProjectileTargetsPath({\n                ray: currentRay,\n                startingTileCoords:\n                    Grid.getTileFromCanvasCoords(currentRay.startPt),\n                fromTeamIndex: otherProjectile.fromTeamIndex,\n                numRicochets: otherProjectile.getNumRicochetsLeft(),\n                characters: this.gameState.getAliveCharacters(),\n                obstacles: this.gameState.obstacles,\n            });\n            otherProjectile.setNewTargets(newTargets);\n        }\n    }\n\n    private shouldSkipAnimation(character: Character): boolean {\n        if (!this.isAiTurn()) {\n            return false;\n        }\n        if (this.gameState.settings.matchType === MatchType.AI_VS_AI) {\n            return true;\n        }\n        // TODO check if ai charcter's path is completely out of sight.\n        return false;\n    }\n\n    render(): void {\n        const context = this.context;\n        context.fillStyle = THEME.gridBackgroundColor;\n        context.clearRect(\n            0, 0,\n            RENDER_SETTINGS.canvasWidth,\n            RENDER_SETTINGS.canvasHeight);\n        context.fillRect(\n            0, 0,\n            RENDER_SETTINGS.canvasWidth,\n            RENDER_SETTINGS.canvasHeight);\n\n        if (this.gameState.selectableTiles != null\n            && this.gameState.selectableTiles.length) {\n            if (!this.isAiTurn()) {\n                for (const availableTile of this.gameState.selectableTiles) {\n                    const tileCanvasTopLeft =\n                        Grid.getCanvasFromTileCoords(availableTile);\n                    context.fillStyle = THEME.availableForMovementColor;\n                    context.fillRect(\n                        tileCanvasTopLeft.x, tileCanvasTopLeft.y,\n                        Grid.TILE_SIZE, Grid.TILE_SIZE);\n                }\n            }\n            // Indicate hovered tile.\n            const mouseTileCoords =\n                Grid.getTileFromCanvasCoords(\n                    CONTROLS.getMouseCanvasCoords());\n            if (this.gameState.selectableTiles\n                .find((tile) => tile.equals(mouseTileCoords))) {\n                const tileCanvasTopLeft =\n                    Grid.getCanvasFromTileCoords(mouseTileCoords);\n                context.fillStyle = THEME.emptyCellHoverColor;\n                context.fillRect(\n                    tileCanvasTopLeft.x, tileCanvasTopLeft.y,\n                    Grid.TILE_SIZE, Grid.TILE_SIZE);\n            }\n        }\n        for (const obstacle of this.gameState.obstacles) {\n            obstacle.render(context);\n        }\n        for (const flag of this.gameState.flags) {\n            flag.render(this.context);\n        }\n        for (const character of this.gameState.getAliveCharacters()) {\n            if (this.shouldRenderCharacter(character)) {\n                character.render(this.context);\n            }\n        }\n        for (const spawner of this.gameState.spawners) {\n            spawner.render(this.context);\n        }\n        if (this.gameState.selectedCharacter != null\n            && !this.isAiTurn()) {\n            const tileCanvasTopLeft = Grid.getCanvasFromTileCoords(\n                this.gameState.selectedCharacter.tileCoords);\n            context.strokeStyle = THEME.selectedCharacterOutlineColor;\n            context.lineWidth = 2;\n            context.strokeRect(\n                tileCanvasTopLeft.x, tileCanvasTopLeft.y,\n                Grid.TILE_SIZE, Grid.TILE_SIZE);\n        }\n        for (const projectile of this.projectiles) {\n            if (this.shouldRenderObjectAtTile(projectile.tileCoords)) {\n                projectile.render();\n            }\n        }\n        for (const particleSystem of this.particleSystems) {\n            if (this.shouldRenderObjectAtTile(particleSystem.tileCoords)) {\n                particleSystem.render(this.context);\n            }\n        }\n        this.renderFogOfWar(this.context);\n        this.hud.render();\n        this.inputManager.render();\n    }\n\n    private shouldRenderCharacter(character: Character): boolean {\n        if (!this.gameState.isFogOfWarOn()) {\n            return true;\n        }\n        if (this.gameState.settings.matchType === MatchType.PLAYER_VS_PLAYER_LOCAL\n            || this.gameState.settings.matchType === MatchType.AI_VS_AI) {\n            // TODO - implement 'pass device' screen.\n            return this.gameState.isTileVisibleByTeamIndex(\n                character.tileCoords, this.gameState.currentTeamIndex);\n        }\n\n        // In player vs AI, always render from player perspective\n        if (character.teamIndex === DEFAULT_HUMAN_TEAM_INDEX) {\n            return true;\n        } else {\n            const animatingCharacterTile = Grid.getTileFromCanvasCoords(\n                character.animationState.currentCenterCanvas);\n            return this.gameState\n                .isTileVisibleByTeamIndex(animatingCharacterTile,\n                    DEFAULT_HUMAN_TEAM_INDEX);\n        }\n    }\n\n    private shouldRenderObjectAtTile(tile: Point): boolean {\n        if (!this.gameState.isFogOfWarOn()) {\n            return true;\n        }\n        if (this.gameState.settings.matchType === MatchType.PLAYER_VS_PLAYER_LOCAL\n            || this.gameState.settings.matchType === MatchType.AI_VS_AI) {\n            // TODO - implement 'pass device' screen.\n            return this.gameState.isTileVisibleByTeamIndex(\n                tile, this.gameState.currentTeamIndex);\n        }\n        // In player vs AI, always render from player perspective\n        return this.gameState.isTileVisibleByTeamIndex(\n            tile,\n            DEFAULT_HUMAN_TEAM_INDEX);\n    }\n\n    private renderFogOfWar(context: CanvasRenderingContext2D): void {\n        if (!this.gameState.isFogOfWarOn()) {\n            return;\n        }\n        let visibleTiles: Point[] = [];\n        if (this.gameState.settings.matchType === MatchType.PLAYER_VS_PLAYER_LOCAL\n            || this.gameState.settings.matchType === MatchType.AI_VS_AI) {\n            visibleTiles =\n                this.gameState.getTilesVisibleByTeamIndex(\n                    this.gameState.currentTeamIndex);\n        } else if (\n            this.gameState.settings.matchType === MatchType.PLAYER_VS_AI) {\n            visibleTiles = this.gameState\n                .getTilesVisibleByTeamIndex(DEFAULT_HUMAN_TEAM_INDEX);\n        }\n        if (this.gameState.gamePhase === GamePhase.CHARACTER_PLACEMENT\n            && !this.isAiTurn()) {\n            visibleTiles = visibleTiles\n                .concat(this.gameState.selectableTiles);\n        }\n        context.fillStyle = THEME.fogColor;\n        for (let x = 0; x < Grid.TILES_WIDE; x++) {\n            for (let y = 0; y < Grid.TILES_TALL; y++) {\n                const tile = new Point(x, y);\n                const isVisible = visibleTiles\n                    .find((visibleTile) => visibleTile.equals(tile));\n                if (isVisible) {\n                    continue;\n                }\n                const canvasTopLeft = Grid.getCanvasFromTileCoords(tile);\n                context.fillRect(\n                    canvasTopLeft.x, canvasTopLeft.y,\n                    Grid.TILE_SIZE, Grid.TILE_SIZE);\n            }\n        }\n    }\n\n    destroy(): void {\n        if (this.inputManager) this.inputManager.clear();\n    }\n\n    onAction(action: Action): void {\n        if (this.isPaused) {\n            return;\n        }\n        const activeSquad = this.gameState.getActiveSquad();\n        switch (action.type) {\n            case ActionType.SHOOT:\n                if (this.gameState.selectedCharacter == null) {\n                    throw new Error(\n                        `Selected character is null on FIRE action`);\n                }\n                const shotInfos = this.gameState.selectedCharacter.shoot();\n                for (const shotInfo of shotInfos) {\n                    this.fireShot(shotInfo);\n                    // Next turn logic runs when projectile dies.\n                    this.addOnAnimationDoneCallback(\n                        this.onProjectileAnimationOver);\n                }\n                break;\n            case ActionType.HEAL:\n                if (this.gameState.selectedCharacter == null) {\n                    throw new Error(\n                        `Selected character is null on HEAL action`);\n                }\n                this.gameState.selectedCharacter\n                    .regenHealth(action.healAmount);\n                this.gameState.selectedCharacter\n                    .useAbility(CharacterAbilityType.HEAL);\n                const characterCenter =\n                    Grid.getCanvasFromTileCoords(\n                        this.gameState.selectedCharacter.tileCoords)\n                        .add(Grid.HALF_TILE);\n                this.particleSystems.push(new ParticleSystem(\n                    getHealParticleSystemParams(characterCenter)));\n                this.checkCharacterTurnOver();\n                break;\n            case ActionType.END_CHARACTER_TURN:\n                if (this.gameState.selectedCharacter == null) {\n                    throw new Error(\n                        `Selected character is null on ` +\n                        `END_CHARACTER_TURN action`);\n                }\n                this.gameState.selectedCharacter.setTurnOver();\n                this.onCharacterTurnOver();\n                break;\n            case ActionType.AIM:\n                if (this.gameState.selectedCharacter == null) {\n                    throw new Error(\n                        `No selected character when trying to aim`);\n                }\n                this.gameState.selectedCharacter\n                    .setAim(action.aimAngleClockwiseRadians);\n                break;\n            case ActionType.SELECT_TILE:\n                if (!this.gameState.selectableTiles\n                    .find((tile) => tile.equals(action.tile))) {\n                    throw new Error(\n                        `Invalid tile selection: ${action.tile.toString()}`);\n                }\n                if (this.gameState.gamePhase === GamePhase.COMBAT) {\n                    if (this.gameState.selectedCharacter == null) {\n                        throw new Error(\n                            `Selected character is null on ` +\n                            `SELECT_TILE action in combat phase`);\n                    }\n                    this.gameState.selectableTiles = [];\n                    if (this.gameState.selectedCharacterState\n                        === SelectedCharacterState.MOVING) {\n                        this.handleCharacterMovement(action.tile);\n                    } else if (this.gameState.selectedCharacterState\n                        === SelectedCharacterState.THROWING_GRENADE) {\n                        const grenadeDetails = {\n                            splashDamage: this.gameState.selectedCharacter\n                                .getGrenadeAbility().splashDamage,\n                            tile: action.tile,\n                        };\n                        this.gameState.selectedCharacter\n                            .useAbility(CharacterAbilityType.THROW_GRENADE);\n                        this.throwGrenade(grenadeDetails);\n                    }\n                } else {\n                    const squadIndex = activeSquad.length;\n                    this.gameState.characters.push(new Character({\n                        startCoords: action.tile,\n                        teamIndex: this.gameState.currentTeamIndex,\n                        index: squadIndex,\n                        settings: this.selectedCharacterSettings,\n                        gameDelegate: this.gameDelegate,\n                    }));\n                    const teamMaxSquadSize =\n                        this.gameSettings.teamIndexToSquadSize\n                            .get(this.gameState.currentTeamIndex)!;\n                    if (activeSquad.length + 1 === teamMaxSquadSize) {\n                        // Placed all characters, end turn.\n                        this.nextTurn();\n                    } else {\n                        this.gameState.selectableTiles =\n                            this.gameState.selectableTiles\n                                .filter((availableTile) => {\n                                    return !availableTile.equals(action.tile);\n                                });\n                    }\n                }\n                break;\n            case ActionType.SELECT_CHARACTER:\n                const character = activeSquad\n                    .find((character) => {\n                        return character.index === action.characterIndex;\n                    });\n                if (character == null) {\n                    throw new Error(\n                        `Can't find character in SELECT_CHARACTER action. ` +\n                        `cur team index: ${this.gameState.currentTeamIndex}; ` +\n                        ` charIndex: ${action.characterIndex}`);\n                }\n                if (character.isTurnOver() || !character.isAlive()) {\n                    throw new Error(\n                        `Selected character is dead or turn is over.`);\n                }\n                this.gameState.selectedCharacter!.cancelAiming();\n                this.setSelectedCharacter(action.characterIndex);\n                break;\n            case ActionType.SELECT_CHARACTER_STATE:\n                this.setSelectedCharacterState(action.state);\n                break;\n            case ActionType.SELECT_CHARACTER_CLASS:\n                this.selectedCharacterSettings = action.class;\n                break;\n            default:\n                throwBadAction(action);\n        }\n    }\n\n    private gameDelegate = {\n        getCurrentAimPath: (params: {\n            ray: Ray;\n            startingTileCoords: Point;\n            fromTeamIndex: number;\n            numRicochets: number;\n        }) => {\n            const visibleEnemyCharacters =\n                this.gameState.getAliveCharacters();\n            if (this.gameState.settings.hasFogOfWar) {\n                visibleEnemyCharacters.filter((character) => {\n                    return this.gameState.isTileVisibleByTeamIndex(\n                        character.tileCoords,\n                        this.gameState.currentTeamIndex);\n                });\n            }\n            return getProjectileTargetsPath({\n                ...params,\n                characters: visibleEnemyCharacters,\n                obstacles: this.gameState.obstacles,\n            });\n        }\n    };\n\n    private checkGameOver(): void {\n        if (!ALLOW_ELIMINATION_VICTORY_WITH_SPAWNERS\n            && this.gameState.spawners.length > 0) {\n            // TODO - assumes spawners only appear for ai\n            const numHumanCharacters =\n                this.gameState.getCharactersForTeamIndex(\n                    DEFAULT_HUMAN_TEAM_INDEX)\n                    .length;\n            if (numHumanCharacters !== 0) {\n                return;\n            }\n        }\n        let winningTeam: string | null = null;\n        let winningTeamIndex = -1;\n        if (this.gameState.getEnemyCharacters().length === 0) {\n            winningTeamIndex = this.gameState.currentTeamIndex;\n            winningTeam = this.gameState.getActiveTeamName();\n        }\n        else if (this.gameState.getActiveSquad().length === 0) {\n            winningTeam = this.gameState.getEnemyTeamName();\n            winningTeamIndex =\n                (1 + this.gameState.currentTeamIndex)\n                % this.gameSettings.numTeams;\n        }\n        if (winningTeam != null) {\n            this.setGameOver(\n                winningTeamIndex,\n                `${winningTeam} has elimanted all oponents.`);\n        }\n    }\n\n    private checkCharacterTurnOver(): void {\n        if (this.gameState.selectedCharacter!.isTurnOver()) {\n            this.onCharacterTurnOver();\n        } else {\n            this.setSelectedCharacterState(\n                SelectedCharacterState.AWAITING);\n        }\n    }\n\n    /** \n     * Checks if there's another squad \n     * member still active, or advances turn if not. \n     */\n    private onCharacterTurnOver(): void {\n        const squad = this.gameState.getActiveSquad();\n        const activeSquadMember = squad.find(\n            (character: Character) => {\n                return !character.isTurnOver() && character.isAlive();\n            });\n        if (activeSquadMember) {\n            this.setSelectedCharacter(activeSquadMember.index);\n        } else {\n            this.nextTurn();\n        }\n    }\n\n    private nextTurn(): void {\n        if (this.gameState.gamePhase === GamePhase.CHARACTER_PLACEMENT) {\n            const nextTeamIndex = this.gameState.currentTeamIndex + 1;\n            if (nextTeamIndex < this.gameSettings.numTeams) {\n                this.gameState.currentTeamIndex += 1;\n                this.initCharacterPlacementTurn();\n            } else {\n                this.gameState.gamePhase = GamePhase.COMBAT;\n                this.advanceToNextCombatTurn();\n            }\n        } else {\n            this.advanceToNextCombatTurn();\n        }\n    }\n\n    private isAiTurn(): boolean {\n        if (this.isGameOver) {\n            return false;\n        }\n        return this.teamIndexToIsAi[this.gameState.currentTeamIndex];\n    }\n\n    private initCharacterPlacementTurn(): void {\n        this.gameState.selectableTiles =\n            this.getAvailableTilesForCharacterPlacement();\n        const teamName = this.gameState.getActiveTeamName();\n        const teamMaxSquadSize = this.gameSettings.teamIndexToSquadSize\n            .get(this.gameState.currentTeamIndex)!;\n        this.hud.setText(\n            `${teamName} team turn`, TextType.TITLE, Duration.LONG);\n        this.hud.setText(\n            `Place squad members (${teamMaxSquadSize} remaining) `,\n            TextType.SUBTITLE,\n            Duration.LONG);\n        if (!this.isAiTurn()) {\n            this.inputManager.initForCharacterPlacement();\n        } else {\n            this.inputManager.initDefaultControls();\n        }\n    }\n\n    private advanceToNextCombatTurn(): void {\n        const currentTeamIndex = this.gameState.currentTeamIndex;\n        // Spawn at end of turns.\n        for (const spawner of this.gameState.spawners) {\n            if (spawner.teamIndex === currentTeamIndex) {\n                spawner.advanceTurn();\n                const allEnemyCharacters = this.gameState.characters\n                    .filter((character) =>\n                        character.teamIndex === currentTeamIndex);\n                const newCharacterIndex = allEnemyCharacters.length;\n                if (spawner.checkAndHandleRespawn()) {\n                    const character = new Character({\n                        startCoords: spawner.tileCoords,\n                        teamIndex: this.gameState.currentTeamIndex,\n                        index: newCharacterIndex,\n                        settings: this.selectedCharacterSettings,\n                        gameDelegate: this.gameDelegate,\n                    });\n                    this.gameState.characters.push(character);\n                }\n            }\n        }\n\n        this.gameState.currentTeamIndex =\n            (this.gameState.currentTeamIndex + 1)\n            % this.gameSettings.numTeams;\n        const squad = this.gameState.getActiveSquad();\n        if (squad.length === 0) {\n            this.advanceToNextCombatTurn();\n            return;\n        }\n        for (const character of squad) {\n            character.resetTurnState();\n        }\n        const teamName = this.gameState.getActiveTeamName();\n        this.setSelectedCharacter(\n            this.gameState.getFirstCharacterIndex());\n        this.hud.setText(\n            `${teamName} team turn`, TextType.TITLE, Duration.LONG);\n    }\n\n    private getCurrentTurnAi(): Ai {\n        return this.ais\n            .find((ai) => {\n                return ai.teamIndex === this.gameState.currentTeamIndex;\n            })!;\n    }\n\n    private getGameState(): GameState {\n        return this.gameState;\n    }\n\n    private addOnAnimationDoneCallback(callback: () => void): void {\n        this.onAnimationDone = callback;\n        this.inputManager.initDefaultControls();\n    }\n\n    private handleCharacterMovement(toTile: Point): void {\n        const character = this.gameState.selectedCharacter!;\n        const manhattandDistanceAway =\n            character.tileCoords.manhattanDistanceTo(toTile);\n        if (manhattandDistanceAway > character.settings.maxMovesPerTurn) {\n            throw new Error(\n                `Invalid character movement location (too far): ` +\n                `start: ${character.tileCoords.toString()}, ` +\n                `end: ${toTile.toString()}`);\n        }\n        const tilePath =\n            this.gameState.getPath({\n                from: character.tileCoords,\n                to: toTile,\n            });\n        const targets: Target[] =\n            mapTilePathToTargetsPath(character.tileCoords, tilePath);\n        const enemyFlag = this.gameState.getEnemyFlag();\n        const activeTeamFlag = this.gameState.getActiveTeamFlag();\n        const characterHasEnemyFlag =\n            character.tileCoords.equals(enemyFlag.tileCoords);\n        character.moveTo(toTile, targets);\n        this.addOnAnimationDoneCallback(() => {\n            if (activeTeamFlag.isAtStart() && enemyFlag.tileCoords\n                .equals(activeTeamFlag.tileCoords)) {\n                this.setGameOver(\n                    this.gameState.currentTeamIndex,\n                    `${this.gameState.getActiveTeamName()} ` +\n                    `team has snagged the flag.`);\n                return;\n            }\n            this.checkCharacterTurnOver();\n        });\n        if (characterHasEnemyFlag) {\n            enemyFlag.setIsTaken(() => {\n                return character.animationState.currentCenterCanvas\n                    .subtract(Grid.HALF_TILE);\n            });\n            enemyFlag.tileCoords = toTile;\n\n        } else if (enemyFlag.tileCoords.equals(toTile)) {\n            this.hud.setText(\n                `${this.gameState.getActiveTeamName()} ` +\n                `team has taken the flag.`,\n                TextType.SUBTITLE,\n                Duration.SHORT);\n        }\n        if (!activeTeamFlag.isAtStart()\n            && activeTeamFlag.tileCoords.equals(toTile)) {\n            activeTeamFlag.returnToStart();\n            this.hud.setText(\n                `${this.gameState.getActiveTeamName()} ` +\n                `team has returned their flag.`,\n                TextType.SUBTITLE,\n                Duration.SHORT);\n        }\n    }\n\n    private setGameOver(\n        winningTeamIndex: number, subtitle: string): void {\n        this.inputManager.initGameOverControls();\n        this.togglePause();\n        this.isGameOver = true;\n        this.winningTeamIndex = winningTeamIndex;\n        this.hud.setText(\n            `Game over`,\n            TextType.TITLE,\n            Duration.LONG);\n        this.hud.setText(\n            `${subtitle}`,\n            TextType.SUBTITLE,\n            Duration.LONG);\n    }\n\n    private fireShot(shotInfo: ShotInfo): void {\n        const ray = getRayForShot(shotInfo);\n        const numRicochets =\n            shotInfo.projectileDetails.type === ProjectileDetailsType.BULLET\n                ? shotInfo.projectileDetails.numRicochets\n                : 0;\n        const targetsPath = getProjectileTargetsPath({\n            ray,\n            startingTileCoords: shotInfo.fromTileCoords,\n            fromTeamIndex: shotInfo.fromTeamIndex,\n            numRicochets,\n            characters: this.gameState.getAliveCharacters(),\n            obstacles: this.gameState.obstacles,\n        });\n\n        LOGGER.log(\n            LogType.TARGET_FINDING,\n            `Targets: ${JSON.stringify(targetsPath)}`);\n        this.projectiles.push(new Projectile({\n            context: this.context,\n            projectileDetails: shotInfo.projectileDetails,\n            targets: targetsPath,\n            fromTeamIndex: shotInfo.fromTeamIndex,\n        }));\n    }\n\n    private throwGrenade(details: {\n        tile: Point;\n        splashDamage: SplashDamage\n    }): void {\n        const fromTile = this.gameState.selectedCharacter!.tileCoords;\n        const fromCanvasCoords =\n            Grid.getCanvasFromTileCoords(fromTile).add(Grid.HALF_TILE);\n        const targetTile = details.tile;\n        const targetCanvasCoords =\n            Grid.getCanvasFromTileCoords(targetTile).add(Grid.HALF_TILE);\n        const direction =\n            targetCanvasCoords.subtract(fromCanvasCoords).normalize();\n        const ray = new Ray(fromCanvasCoords, direction);\n        const target: Target = {\n            canvasCoords: targetCanvasCoords,\n            ray,\n            tile: targetTile,\n            maxDistance: targetCanvasCoords.distanceTo(fromCanvasCoords),\n        };\n        const shotInfo: ShotInfo = {\n            fromTeamIndex: this.gameState.selectedCharacter!.teamIndex,\n            fromCanvasCoords,\n            fromTileCoords: fromTile,\n            aimAngleRadiansClockwise: direction.getPointRotationRadians(),\n            projectileDetails: details.splashDamage,\n        };\n        const proj = new Projectile({\n            context: this.context,\n            projectileDetails: shotInfo.projectileDetails,\n            targets: [target],\n            fromTeamIndex: shotInfo.fromTeamIndex,\n        });\n        this.projectiles.push(proj);\n        this.addOnAnimationDoneCallback(this.onProjectileAnimationOver);\n    }\n\n    private onProjectileAnimationOver = () => {\n        this.checkGameOver();\n        if (!this.isGameOver) {\n            this.checkCharacterTurnOver();\n        }\n    };\n\n    private getAvailableTilesForCharacterPlacement(): Point[] {\n        const flagCoords =\n            this.gameState.getActiveTeamFlag().tileCoords;\n        const maxDistFromFlag = this.gameSettings.maxSpawnDistanceFromFlag;\n        const availableTiles = bfs({\n            startTile: flagCoords,\n            maxDepth: maxDistFromFlag,\n            isAvailable: (tile: Point): boolean => {\n                return !this.isTileOccupied(tile)\n                    && !tile.equals(flagCoords);\n            },\n            canGoThrough: (tile: Point): boolean => {\n                // Can go through other players, just not obstacles.\n                return !this.gameState.tileHasObstacle(tile);\n            },\n        });\n        return availableTiles;\n    }\n\n    private getAvailableTilesForCharacterMovement(): Point[] {\n        if (this.gameState.selectedCharacter == null) {\n            throw new Error(\n                `No character selected in `\n                + `getAvailableTilesForCharacterMovement`);\n        }\n        const ownFlag = this.gameState.getActiveTeamFlag();\n        const ownFlagCoords =\n            this.gameState.getActiveTeamFlag().tileCoords;\n        const currentCoords =\n            this.gameState.selectedCharacter.tileCoords;\n        const maxMoves =\n            this.gameState.selectedCharacter.settings.maxMovesPerTurn;\n        const isAvailable = (tile: Point): boolean => {\n            if (!this.isTileOccupied(tile)) {\n                if (this.gameState.selectedCharacter!.tileCoords\n                    .equals(this.gameState.getEnemyFlag().tileCoords)) {\n                    return true;\n                }\n                if (ownFlag.isAtStart() && tile.equals(ownFlagCoords)) {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        };\n        const canGoThrough = (tile: Point): boolean => {\n            // Characters can go through tiles occupied by squad members.\n            // but they can't stop there.\n            return isAvailable(tile)\n                || this.gameState.isSquadMemberAtTile(tile);\n        };\n        const availableTiles = bfs({\n            startTile: currentCoords,\n            maxDepth: maxMoves,\n            isAvailable,\n            canGoThrough,\n        });\n        return availableTiles;\n    }\n\n    private getAvailableTilesForThrowingGrenade(): Point[] {\n        if (this.gameState.selectedCharacter == null) {\n            throw new Error(\n                `No character selected in ` +\n                `getAvailableTilesForThrowingGrenade`);\n        }\n        const ownFlagCoords = this.gameState.getActiveTeamFlag();\n        const currentCoords = this.gameState.selectedCharacter.tileCoords;\n        const maxDist = this.gameState.selectedCharacter.\n            getGrenadeAbility().maxManhattanDistance;\n        const isAvailable = (tile: Point): boolean => {\n            return !this.gameState.tileHasObstacle(tile)\n                && !tile.equals(currentCoords)\n                && !this.gameState.isSquadMemberAtTile(tile);\n        };\n        const canGoThrough = (tile: Point): boolean => {\n            // Grenades can go over any tile.\n            return Grid.inbounds(tile);\n        };\n        const availableTiles = bfs({\n            startTile: currentCoords,\n            maxDepth: maxDist,\n            isAvailable,\n            canGoThrough,\n        });\n        return availableTiles;\n    }\n\n    private setSelectedCharacter(index: number): void {\n        const character = this.gameState.getActiveSquad()\n            .find((character) => character.index === index)!;\n        if (character.isTurnOver()) {\n            this.hud.setText(\n                `Unit ${index + 1}'s turn is over.`,\n                TextType.TOAST, Duration.SHORT);\n            return;\n        }\n        this.gameState.selectedCharacter = character;\n        this.setSelectedCharacterState(\n            SelectedCharacterState.AWAITING);\n    }\n\n    private setSelectedCharacterState(state: SelectedCharacterState) {\n        if (this.gameState.selectedCharacter == null) {\n            throw new Error(\n                `There needs to be a selected character ` +\n                `before calling setSelectedCharacterState`);\n        }\n        this.gameState.selectedCharacterState = state;\n\n        switch (state) {\n            case SelectedCharacterState.AWAITING:\n                this.gameState.selectableTiles = [];\n                this.gameState.selectedCharacter.cancelAiming();\n                break;\n            case SelectedCharacterState.MOVING:\n                this.gameState.selectableTiles =\n                    this.getAvailableTilesForCharacterMovement();\n                break;\n            case SelectedCharacterState.AIMING:\n                this.gameState.selectedCharacter.startAiming();\n                break;\n            case SelectedCharacterState.THROWING_GRENADE:\n                this.gameState.selectableTiles =\n                    this.getAvailableTilesForThrowingGrenade();\n                break;\n            default:\n                throw new Error(`Unknown selected character state`);\n        }\n\n        if (this.isAiTurn()) {\n            this.inputManager.initDefaultControls();\n        } else {\n            this.inputManager.initForSelectedCharacterState();\n        }\n    }\n\n    /** \n     * Whether a tile contains an obstacle or character. \n     * Tiles with flags are NOT considered occupied. \n     */\n    private isTileOccupied(tileCoords: Point): boolean {\n        const potentialObstacle = this.gameState.obstacles.find(\n            (obstacle: Obstacle) => {\n                return obstacle.tileCoords.equals(tileCoords);\n            });\n        const potentialCharacter =\n            this.gameState.getAliveCharacters()\n                .find((character) => {\n                    return character.isAlive()\n                        && character.tileCoords.equals(tileCoords);\n                });\n        const potentialSpawner = this.gameState.spawners\n            .find((spawner) => spawner.tileCoords.equals(tileCoords));\n        return potentialObstacle != null\n            || potentialCharacter != null\n            || potentialSpawner != null;\n    }\n\n    private resetGame = (): void => {\n        this.destroy();\n        this.gameState = new GameState(this.gameSettings);\n        this.loadLevel();\n        this.isGameOver = false;\n        this.isPaused = false;\n        this.onAnimationDone = null;\n        this.winningTeamIndex = -1;\n        this.gameState.gamePhase = GamePhase.CHARACTER_PLACEMENT;\n        this.selectedCharacterSettings = CHARACTER_CLASSES[0];\n        this.gameState.characters = [];\n        this.projectiles = [];\n        this.particleSystems = [];\n        this.ais = [];\n        this.teamIndexToIsAi = [];\n        const matchType = this.gameSettings.matchType;\n        for (let i = 0; i < this.gameSettings.numTeams; i++) {\n            let isAi = i !== 0;\n            if (matchType === MatchType.AI_VS_AI) {\n                isAi = true;\n            } else if (matchType === MatchType.PLAYER_VS_PLAYER_LOCAL) {\n                isAi = false;\n            }\n            this.teamIndexToIsAi.push(isAi);\n            if (isAi) {\n                this.ais.push(new Ai({\n                    teamIndex: i,\n                    difficulty: this.gameState.settings.aiDifficulty,\n                }));\n            }\n        }\n        this.hud = new Hud(this.context);\n        this.inputManager = new InputManager(this.context, {\n            isPaused: () => this.isPaused,\n            getGameState: () => this.getGameState(),\n            onAction: (action: Action) => { this.onAction(action); },\n            onRestart: () => { this.resetGame(); },\n            onQuit: () => {\n                this.onExitGameCallback(this.winningTeamIndex);\n            },\n            onTogglePause: () => { this.togglePause(); },\n            setToastText: (text: string) => {\n                this.hud.setText(text, TextType.TOAST, Duration.SHORT);\n            },\n        });\n\n        // 0th team goes first...\n        this.gameState.currentTeamIndex = -1;\n        this.nextTurn();\n    }\n\n    private loadLevel(): void {\n        const level = LEVELS[this.levelIndex];\n        const blueFlag = new Flag({\n            tileCoords: pointFromSerialized(level.data.blueFlag),\n            teamIndex: 0,\n        });\n        const redFlag = new Flag({\n            tileCoords: pointFromSerialized(level.data.redFlag),\n            teamIndex: 1,\n        });\n        this.gameState.flags = [blueFlag, redFlag];\n        this.gameState.obstacles =\n            level.data.obstacles.map((serializedPt) => {\n                return new Obstacle(\n                    pointFromSerialized(serializedPt));\n            });\n        this.gameState.spawners = [];\n        if (this.gameState.settings.hasSpawners) {\n            const aiDifficultyToSpawnDelays = new Map([\n                [AiDifficulty.WEAK, 8],\n                [AiDifficulty.MEDIUM, 6],\n                [AiDifficulty.STRONG, 5],\n            ]);\n            const params = {\n                tileCoords: pointFromSerialized(level.aiSpawner),\n                teamIndex: 1,\n                turnsBetweenSpawns: aiDifficultyToSpawnDelays\n                    .get(this.gameState.settings.aiDifficulty)!,\n            };\n            this.gameState.spawners.push(new Spawner(params));\n        }\n    }\n\n    private togglePause(): void {\n        this.isPaused = !this.isPaused;\n        if (this.isPaused) {\n            this.hud.setText(\n                'PAUSED',\n                TextType.TITLE,\n                Duration.SHORT\n            );\n        } else {\n            this.hud.clearText(TextType.TITLE);\n            this.hud.clearText(TextType.TOAST);\n        }\n    }\n}","import { LevelData } from 'src/app/level';\nimport { Grid } from 'src/app/grid';\nimport { Point } from 'src/app/math/point';\nimport { Obstacle } from 'src/app/game_objects/obstacle';\nimport { Flag } from 'src/app/game_objects/flag';\nimport { RENDER_SETTINGS } from 'src/app/render_settings';\nimport { CONTROLS, ControlMap, EventType, Key } from 'src/app/controls';\nimport { THEME } from 'src/app/theme';\nimport { hexStringToColor, colorToString } from 'src/app/color';\n\nenum PlacementMode {\n    BLUE_FLAG,\n    RED_FLAG,\n    OBSTACLE,\n    ERASE,\n}\n\nexport class LevelCreator {\n    private readonly canvas: HTMLCanvasElement;\n    private readonly context: CanvasRenderingContext2D;\n    private readonly onExitGameCallback: () => void;\n\n    private placementMode: PlacementMode;\n    private obstacles: Obstacle[];\n    private blueFlag?: Flag;\n    private redFlag?: Flag;\n    private controlMap: ControlMap;\n\n    constructor(\n        canvas: HTMLCanvasElement,\n        context: CanvasRenderingContext2D,\n        onExitGameCallback: () => void) {\n\n        this.canvas = canvas;\n        this.context = context;\n        this.onExitGameCallback = onExitGameCallback;\n        this.resetGame();\n    }\n\n    update(elapsedMs: number): void {\n        this.controlMap.check();\n        if (!CONTROLS.hasClick()) {\n            return;\n        }\n        const clickCoords = CONTROLS.handleClick();\n        const mouseTileCoords = Grid.getTileFromCanvasCoords(clickCoords);\n        if (!this.isTileOccupied(mouseTileCoords)) {\n            switch (this.placementMode) {\n                case PlacementMode.BLUE_FLAG:\n                    this.blueFlag = new Flag({\n                        tileCoords: mouseTileCoords,\n                        teamIndex: 0,\n                    });\n                    break;\n                case PlacementMode.RED_FLAG:\n                    this.redFlag = new Flag({\n                        tileCoords: mouseTileCoords,\n                        teamIndex: 1,\n                    });\n                    break;\n                case PlacementMode.OBSTACLE:\n                    const obstacle = new Obstacle(mouseTileCoords);\n                    this.obstacles.push(obstacle);\n                    break;\n            }\n        } else if (this.placementMode === PlacementMode.ERASE) {\n            this.removeObjectInTile(mouseTileCoords);\n        }\n    }\n\n    private isTileOccupied(tileCoords: Point): boolean {\n        if (this.redFlag != null\n            && this.redFlag.tileCoords.equals(tileCoords)) {\n            return true;\n        }\n        if (this.blueFlag != null\n            && this.blueFlag.tileCoords.equals(tileCoords)) {\n            return true;\n        }\n        const obstacle = this.obstacles\n            .find((obstacle: Obstacle) => obstacle.tileCoords.equals(tileCoords));\n        return obstacle != null;\n    }\n\n    private removeObjectInTile(tileCoords: Point): void {\n        if (this.redFlag != null\n            && this.redFlag.tileCoords.equals(tileCoords)) {\n            this.redFlag = undefined;\n        }\n        if (this.blueFlag != null\n            && this.blueFlag.tileCoords.equals(tileCoords)) {\n            this.blueFlag = undefined;\n        }\n        this.obstacles =\n            this.obstacles\n                .filter((obstacle: Obstacle) => !obstacle.tileCoords.equals(tileCoords));\n    }\n\n    render(): void {\n        const context = this.context;\n        const width = Grid.GAME_WIDTH;\n        const height = Grid.GAME_HEIGHT;\n        context.fillStyle = THEME.gridBackgroundColor;\n        context.clearRect(0, 0,\n            width, height);\n        context.fillRect(0, 0,\n            width, height);\n\n        // Draw grid lines.\n        for (let i = 0; i < Grid.TILES_WIDE; i++) {\n            const startX = i * Grid.TILE_SIZE;\n            const endX = startX;\n            const startY = 0;\n            const endY = height;\n\n            context.beginPath();\n            context.strokeStyle = THEME.gridLineColor;\n            context.moveTo(startX, startY);\n            context.lineTo(endX, endY);\n            context.stroke();\n        }\n        for (let i = 0; i < Grid.TILES_TALL; i++) {\n            const startX = 0;\n            const endX = width;\n            const startY = i * Grid.TILE_SIZE;\n            const endY = startY;\n\n            context.beginPath();\n            context.strokeStyle = THEME.gridLineColor;\n            context.moveTo(startX, startY);\n            context.lineTo(endX, endY);\n            context.stroke();\n        }\n\n        const mouseTileCoords =\n            Grid.getTileFromCanvasCoords(CONTROLS.getMouseCanvasCoords());\n        const tileCanvasTopLeft =\n            Grid.getCanvasFromTileCoords(mouseTileCoords);\n        if (Grid.inbounds(mouseTileCoords)\n            && this.placementMode !== PlacementMode.ERASE\n            && !this.isTileOccupied(mouseTileCoords)) {\n            // Indicate hovered tile.\n            const tileCanvasTopLeft =\n                Grid.getCanvasFromTileCoords(mouseTileCoords);\n            let hoverColor = THEME.obstacleColor;\n            if (this.placementMode === PlacementMode.RED_FLAG) {\n                hoverColor = THEME.redFlagColor;\n            } else if (this.placementMode === PlacementMode.BLUE_FLAG) {\n                hoverColor = THEME.blueFlagColor;\n            }\n            const hoverAlpha = .7;\n            const fillColor = hexStringToColor(hoverColor);\n            fillColor.a = hoverAlpha;\n            context.fillStyle = colorToString(fillColor);\n            context.fillRect(\n                tileCanvasTopLeft.x, tileCanvasTopLeft.y,\n                Grid.TILE_SIZE, Grid.TILE_SIZE);\n        }\n\n        for (const obstacle of this.obstacles) {\n            obstacle.render(context);\n        }\n        if (this.redFlag != null) {\n            this.redFlag.render(this.context);\n        }\n        if (this.blueFlag != null) {\n            this.blueFlag.render(this.context);\n        }\n\n        if (this.placementMode === PlacementMode.ERASE\n            && this.isTileOccupied(mouseTileCoords)) {\n            context.fillStyle = '#000000';\n            context.fillRect(\n                tileCanvasTopLeft.x, tileCanvasTopLeft.y,\n                Grid.TILE_SIZE, Grid.TILE_SIZE);\n        }\n\n        this.renderControls();\n    }\n\n    private renderControls(): void {\n        const context = this.context;\n        context.fillStyle = THEME.hudTextColor;\n        const fontSize = 18;\n        context.font = `${fontSize}px fantasy`;\n\n        let renderTop = new Point(\n            RENDER_SETTINGS.canvasWidth / 64,\n            RENDER_SETTINGS.canvasHeight / 32);\n        for (const key of this.controlMap.assignedControls.keys()) {\n            const action = CONTROLS.getAssignedControlMap().get(key);\n            context.fillText(\n                `${CONTROLS.getStringForKey(key)} - ${action}`,\n                renderTop.x,\n                renderTop.y);\n\n            renderTop = renderTop.add(new Point(0, fontSize + 4));\n        }\n    }\n\n    destroy(): void {\n        if (this.controlMap) {\n            this.controlMap.clear();\n        }\n    }\n\n    private readonly saveLevel = (): void => {\n        // TODO - ensure there's a path from flag to flag.\n        if (this.blueFlag == null || this.redFlag == null) {\n            // TODO - toast failure?\n            throw new Error('Need to add both flags!');\n        }\n        const level: LevelData = {\n            redFlag: this.redFlag.tileCoords,\n            blueFlag: this.blueFlag.tileCoords,\n            obstacles: this.obstacles.map((obstacle) => obstacle.tileCoords),\n        };\n        console.log(JSON.stringify(level));\n        // TODO - toast success?\n    };\n\n    private resetGame = (): void => {\n        this.destroy();\n        this.placementMode = PlacementMode.OBSTACLE;\n        this.obstacles = [];\n        this.redFlag = undefined;\n        this.blueFlag = undefined;\n        this.controlMap = new ControlMap();\n        this.controlMap.add({\n            key: Key.Q,\n            name: 'Quit',\n            func: this.onExitGameCallback,\n            eventType: EventType.KeyPress,\n        });\n        this.controlMap.add({\n            key: Key.R,\n            name: 'Reset',\n            func: this.resetGame,\n            eventType: EventType.KeyPress,\n        });\n        this.controlMap.add({\n            key: Key.S,\n            name: 'Save',\n            func: this.saveLevel,\n            eventType: EventType.KeyPress,\n        });\n        this.controlMap.add({\n            key: Key.O,\n            name: 'Place Obstacles',\n            func: () => { this.setPlacementMode(PlacementMode.OBSTACLE) },\n            eventType: EventType.KeyPress,\n        });\n        this.controlMap.add({\n            key: Key.B,\n            name: 'Place Blue Flag',\n            func: () => { this.setPlacementMode(PlacementMode.BLUE_FLAG) },\n            eventType: EventType.KeyPress,\n        });\n        this.controlMap.add({\n            key: Key.V,\n            name: 'Place Red Flag',\n            func: () => { this.setPlacementMode(PlacementMode.RED_FLAG) },\n            eventType: EventType.KeyPress,\n        });\n        this.controlMap.add({\n            key: Key.E,\n            name: 'Erase',\n            func: () => { this.setPlacementMode(PlacementMode.ERASE) },\n            eventType: EventType.KeyPress,\n        });\n    }\n\n    private setPlacementMode(mode: PlacementMode): void {\n        this.placementMode = mode;\n    }\n}\n","import { Point } from './math/point';\nimport { ParticleSystemParams, ParticleShape } from 'src/app/game_objects/particle_system';\nimport { Grid } from './grid';\n\nexport function getBulletParticleSystemParams(startPositionCanvas: Point):\n    ParticleSystemParams {\n    return {\n        startPositionCanvas,\n        particleCount: 60,\n        colorA: '#a83232',\n        colorB: '#cc7606',\n        shape: ParticleShape.LINE,\n        minParticleSpeed: .003 * Grid.TILE_SIZE,\n        maxParticleSpeed: .005 * Grid.TILE_SIZE,\n        minLifetimeMs: 100,\n        maxLifetimeMs: 200,\n        minRadius: .035 * Grid.TILE_SIZE,\n        maxRadius: .065 * Grid.TILE_SIZE,\n    };\n};\n\nexport function getGrenadeSmokeParticleSystemParams(startPositionCanvas: Point):\n    ParticleSystemParams {\n    return {\n        startPositionCanvas,\n        particleCount: 160,\n        colorA: '#a1a1a1',\n        colorB: '#403f3f',\n        shape: ParticleShape.CIRCLE,\n        minParticleSpeed: .0005 * Grid.TILE_SIZE,\n        maxParticleSpeed: .001 * Grid.TILE_SIZE,\n        minLifetimeMs: 800,\n        maxLifetimeMs: 100,\n        minRadius: .055 * Grid.TILE_SIZE,\n        maxRadius: .085 * Grid.TILE_SIZE,\n    };\n};\n\nexport function getGrenadeBurstParticleSystemParams(startPositionCanvas: Point):\n    ParticleSystemParams {\n    return {\n        startPositionCanvas,\n        particleCount: 100,\n        colorA: '#e3a14f',\n        colorB: '#6e6151',\n        shape: ParticleShape.ELLIPSE,\n        minParticleSpeed: .0015 * Grid.TILE_SIZE,\n        maxParticleSpeed: .0025 * Grid.TILE_SIZE,\n        minLifetimeMs: 500,\n        maxLifetimeMs: 600,\n        minRadius: .035 * Grid.TILE_SIZE,\n        maxRadius: .055 * Grid.TILE_SIZE,\n    };\n};\n\nexport function getHealParticleSystemParams(startPositionCanvas: Point):\n    ParticleSystemParams {\n    return {\n        startPositionCanvas,\n        particleCount: 12,\n        colorA: '#1bd133',\n        colorB: '#07ad1d',\n        shape: ParticleShape.PLUS,\n        minParticleSpeed: .001 * Grid.TILE_SIZE,\n        maxParticleSpeed: .002 * Grid.TILE_SIZE,\n        minLifetimeMs: 600,\n        maxLifetimeMs: 800,\n        minRadius: .07 * Grid.TILE_SIZE,\n        maxRadius: .12 * Grid.TILE_SIZE,\n    }\n};","import { AiDifficulty } from './game_settings';\n\n\ninterface CampaignLevel {\n    readonly levelIndex: number;\n    readonly levelName: string;\n    readonly teamIndexToSquadSize: Map<number, number>;\n    isUnlocked: boolean;\n    readonly aiDifficulty: AiDifficulty;\n}\n\nconst UNLOCK_ALL = false;\n\nexport const CAMPAIGN_LEVELS: CampaignLevel[] = [\n    // Level 1\n    {\n        levelIndex: 0,\n        levelName: 'Starting grounds',\n        teamIndexToSquadSize: new Map([[0, 4], [1, 4]]),\n        isUnlocked: true,\n        aiDifficulty: AiDifficulty.WEAK,\n    },\n    // Level 2\n    {\n        levelIndex: 1,\n        levelName: 'Getting tougher',\n        teamIndexToSquadSize: new Map([[0, 3], [1, 5]]),\n        isUnlocked: UNLOCK_ALL,\n        aiDifficulty: AiDifficulty.WEAK,\n    },\n    // Level 3\n    {\n        levelIndex: 7,\n        levelName: 'Protect it',\n        teamIndexToSquadSize: new Map([[0, 4], [1, 8]]),\n        isUnlocked: UNLOCK_ALL,\n        aiDifficulty: AiDifficulty.WEAK,\n    },\n    // Level 4\n    {\n        levelIndex: 3,\n        levelName: 'Snag it',\n        teamIndexToSquadSize: new Map([[0, 4], [1, 8]]),\n        isUnlocked: UNLOCK_ALL,\n        aiDifficulty: AiDifficulty.WEAK,\n    },\n    // Level 5\n    {\n        levelIndex: 8,\n        levelName: 'Familiar',\n        teamIndexToSquadSize: new Map([[0, 4], [1, 8]]),\n        isUnlocked: UNLOCK_ALL,\n        aiDifficulty: AiDifficulty.MEDIUM,\n    },\n\n    // Level 6\n    {\n        levelIndex: 9,\n        levelName: 'Snarls',\n        teamIndexToSquadSize: new Map([[0, 4], [1, 8]]),\n        isUnlocked: UNLOCK_ALL,\n        aiDifficulty: AiDifficulty.MEDIUM,\n    },\n    // Level 7\n    {\n        levelIndex: 6,\n        levelName: 'To snag...',\n        teamIndexToSquadSize: new Map([[0, 4], [1, 8]]),\n        isUnlocked: UNLOCK_ALL,\n        aiDifficulty: AiDifficulty.MEDIUM,\n    },\n    // Level 8\n    {\n        levelIndex: 2,\n        levelName: 'Or be snagged...',\n        teamIndexToSquadSize: new Map([[0, 4], [1, 8]]),\n        isUnlocked: UNLOCK_ALL,\n        aiDifficulty: AiDifficulty.MEDIUM,\n    },\n    // Level 9\n    {\n        levelIndex: 4,\n        levelName: 'Snag and tag',\n        teamIndexToSquadSize: new Map([[0, 6], [1, 16]]),\n        isUnlocked: UNLOCK_ALL,\n        aiDifficulty: AiDifficulty.STRONG,\n    },\n    // Level 10\n    {\n        levelIndex: 5,\n        levelName: 'Flag of snag',\n        teamIndexToSquadSize: new Map([[0, 8], [1, 24]]),\n        isUnlocked: UNLOCK_ALL,\n        aiDifficulty: AiDifficulty.STRONG,\n    },\n    // Level 11\n    {\n        levelIndex: 10,\n        levelName: 'Frag and flag',\n        teamIndexToSquadSize: new Map([[0, 8], [1, 24]]),\n        isUnlocked: UNLOCK_ALL,\n        aiDifficulty: AiDifficulty.STRONG,\n    },\n    // Level 12\n    {\n        levelIndex: 11,\n        levelName: 'Final snag',\n        teamIndexToSquadSize: new Map([[0, 6], [1, 16]]),\n        isUnlocked: UNLOCK_ALL,\n        aiDifficulty: AiDifficulty.STRONG,\n    },\n];\n\nconst lastUnlockedCampaignLevelIndexStorageKey =\n    'SnagTheFlag_Campgain_LastUnlockedCampaignLevelIndex' as const;\n\nconst checkUnlocked = () => {\n    const lastUnlockedCampaignLevelIndex = getLastUnlocked();\n    for (let levelIndex = 0; levelIndex < CAMPAIGN_LEVELS.length; levelIndex++) {\n        const level = CAMPAIGN_LEVELS[levelIndex];\n        if (lastUnlockedCampaignLevelIndex >= levelIndex) {\n            level.isUnlocked = true;\n        }\n    }\n};\ncheckUnlocked();\n\nexport function tryUnlockingAndSavingProgress(nextCampaignLevelIndex: number):\n    void {\n    const lastUnlockedCampaignLevelIndex = getLastUnlocked();\n    if (nextCampaignLevelIndex < CAMPAIGN_LEVELS.length\n        && nextCampaignLevelIndex > lastUnlockedCampaignLevelIndex) {\n        CAMPAIGN_LEVELS[nextCampaignLevelIndex].isUnlocked = true;\n        window.localStorage.setItem(\n            lastUnlockedCampaignLevelIndexStorageKey,\n            `${nextCampaignLevelIndex}`);\n    }\n}\n\nfunction getLastUnlocked(): number {\n    const storedValue = window.localStorage.getItem(\n        lastUnlockedCampaignLevelIndexStorageKey);\n    return storedValue != null\n        ? Number.parseInt(storedValue)\n        : -1;\n}","import { UiManager } from 'src/app/ui/ui_manager';\nimport { Button, ButtonDimensions, ButtonStyle } from 'src/app/ui/button';\nimport { Point } from 'src/app/math/point';\nimport { RENDER_SETTINGS } from 'src/app/render_settings';\nimport { CONTROLS } from 'src/app/controls';\nimport { GameModeManager } from 'src/app/game_mode_manager';\nimport { THEME } from 'src/app/theme';\nimport { LEVELS } from 'src/app/level';\nimport { ButtonGroup } from 'src/app/ui/button_group';\nimport { GameSettings, MatchType, DEFAULT_GAME_SETTINGS, AiDifficulty } from 'src/app/game_settings';\nimport { TextBox, TextBoxStyle, TextBoxDimensions } from 'src/app/ui/text_box';\nimport { Element } from '../ui/element';\n\ninterface ButtonMetadata {\n    text: string;\n    callback: () => void;\n}\n\nexport class FreePlayMenu implements GameModeManager {\n    private readonly canvas: HTMLCanvasElement;\n    private readonly context: CanvasRenderingContext2D;\n    private readonly onSelectLevel:\n        (levelIndex: number, gameSettings: GameSettings) => void;\n    private readonly onBack: () => void;\n    private readonly uiManager: UiManager;\n    private selectedLevelIndex: number;\n    private selectedMatchType: MatchType;\n    private selectedTeamSizeMap: Map<number, number>;\n    private selectedAiDifficulty: AiDifficulty;\n    private isFogOfWarOn: boolean;\n    private hasSpawners: boolean;\n\n    constructor(\n        canvas: HTMLCanvasElement,\n        context: CanvasRenderingContext2D,\n        callbacks: {\n            readonly onSelectLevel:\n            (levelIndex: number, gameSettings: GameSettings) => void;\n            onBack: () => void;\n        }) {\n\n        this.canvas = canvas;\n        this.context = context;\n        this.onSelectLevel = callbacks.onSelectLevel;\n        this.onBack = callbacks.onBack;\n\n        this.uiManager = new UiManager(context);\n        const settingsLeftMargin = .04;\n        const levelMenuLeft = .5 + settingsLeftMargin;\n        this.initSettingsElements(settingsLeftMargin);\n        this.initLevelElements(levelMenuLeft);\n        this.initButtons(.1);\n    }\n\n    update(elapsedTime: number): void {\n        this.uiManager.onMouseMove(CONTROLS.getMouseCanvasCoords());\n        if (CONTROLS.hasClick()) {\n            const clickCanvasCoords = CONTROLS.handleClick();\n            this.uiManager.onClick(clickCanvasCoords);\n        }\n    }\n\n    render(): void {\n        this.context.fillStyle = THEME.uiBackgroundColor;\n        this.context.clearRect(\n            0, 0, RENDER_SETTINGS.canvasWidth, RENDER_SETTINGS.canvasHeight);\n        this.context.fillRect(\n            0, 0, RENDER_SETTINGS.canvasWidth, RENDER_SETTINGS.canvasHeight);\n        this.renderTitleText();\n        this.uiManager.render();\n    }\n\n    destroy(): void {\n        // no-op\n    }\n\n    private initButtons(backButtonLeft: number): void {\n        const topMargin = .9;\n        const buttonSize = new Point(.18, .08);\n\n        // Back button.\n        const backButton = new Button({\n            dimensions: {\n                size: buttonSize,\n                topLeft: new Point(backButtonLeft, topMargin),\n                text: 'Back',\n            },\n            style: {\n                fontSize: 22,\n                color: '#d9c8a3',\n                hoverColor: '#e6dbc3',\n                textColor: THEME.buttonTextColor,\n            },\n            onClick: this.onBack,\n        });\n        this.uiManager.addElement(backButton);\n\n        // Start button.\n        const startButtonLeft = backButtonLeft + buttonSize.x + .04;\n        const startButton = new Button({\n            dimensions: {\n                size: buttonSize,\n                text: 'Start',\n                topLeft: new Point(startButtonLeft, topMargin),\n            },\n            style: {\n                color: '#66d15a',\n                hoverColor: '#7aed6d',\n                fontSize: 28,\n                textColor: THEME.buttonTextColor,\n            },\n            onClick: () => {\n                const maxSpawnDistanceFromFlag =\n                    this.selectedTeamSizeMap.get(1)! > 16\n                        ? 16\n                        : DEFAULT_GAME_SETTINGS.maxSpawnDistanceFromFlag;\n                const settings: GameSettings = {\n                    matchType: this.selectedMatchType,\n                    teamIndexToSquadSize: this.selectedTeamSizeMap,\n                    maxSpawnDistanceFromFlag,\n                    numTeams: DEFAULT_GAME_SETTINGS.numTeams,\n                    hasFogOfWar: this.isFogOfWarOn,\n                    aiDifficulty: this.selectedAiDifficulty,\n                    hasSpawners: this.hasSpawners,\n                }\n                this.onSelectLevel(this.selectedLevelIndex, settings);\n            }\n        });\n        this.uiManager.addElement(startButton);\n    }\n\n    private initSettingsElements(leftMargin: number): void {\n        const headerTopMargin = .18;\n        const buttonOffsetX = .04;\n        const buttonGroupOffsetY = .04;\n        const buttonSize = new Point(.09, .06);\n        const headerSize = new Point(.18, .08);\n        const rowLength = 3;\n        const rowOffset = buttonGroupOffsetY / 2;\n        const settingsTopMargin =\n            headerTopMargin + buttonGroupOffsetY / 2 + headerSize.y;\n        const fontSize = 22;\n        const headerStyle: TextBoxStyle = {\n            color: '#dddddd',\n            fontSize,\n            textColor: '#000000',\n        };\n        const labelStyle: TextBoxStyle = {\n            color: THEME.uiBackgroundColor,\n            fontSize: fontSize - 2,\n            textColor: '#000000',\n        };\n        const buttonStyle: ButtonStyle = {\n            fontSize: fontSize - 2,\n            color: '#f7c25e',\n            hoverColor: '#deaf57',\n            selectedColor: '#db9d2a',\n            selectedBorderColor: '#000000',\n            textColor: THEME.buttonTextColor,\n        };\n\n        const settingsHeader = new TextBox({\n            dimensions: {\n                size: headerSize,\n                text: 'Settings',\n                topLeft: new Point(.25 - headerSize.x / 2, headerTopMargin),\n            },\n            style: headerStyle,\n        });\n        this.uiManager.addElement(settingsHeader);\n\n        const createSettingRowElements = (params: {\n            topY: number;\n            headerText: string;\n            buttonTexts: string[];\n            initialButtonIndex: number;\n            rows: number;\n            onButtonChangeCallback: (selectedIndex: number) => void;\n        }): Element[] => {\n            const labelSize = new Point(.14, .06);\n            const labelLeftMargin = leftMargin;\n            const header = new TextBox({\n                dimensions: {\n                    size: labelSize,\n                    text: params.headerText,\n                    topLeft: new Point(labelLeftMargin, params.topY),\n                },\n                style: labelStyle,\n            });\n\n            const buttonLeftMargin = labelLeftMargin + labelSize.x + .02;\n            const dimensions: ButtonDimensions[] = [];\n            for (let index = 0; index < params.buttonTexts.length; index++) {\n                const column = index % rowLength;\n                const row = Math.floor(index / rowLength);\n                let topLeftX = buttonLeftMargin + column * (buttonOffsetX +\n                    buttonSize.y);\n                let topLeftY = params.topY + row * (rowOffset + buttonSize.y)\n                dimensions.push({\n                    topLeft: new Point(topLeftX, topLeftY),\n                    size: buttonSize,\n                    text: params.buttonTexts[index],\n                });\n            }\n            params.onButtonChangeCallback(params.initialButtonIndex);\n            const buttonGroup = new ButtonGroup({\n                buttons: dimensions,\n                buttonStyle,\n                initialSelectionIndex: params.initialButtonIndex,\n                onChangeCallback: params.onButtonChangeCallback,\n            });\n            return [header, buttonGroup];\n        };\n\n        // Team size type buttons.\n        const teamSizeIndexToTeamSizeMap: Array<Map<number, number>> = [\n            new Map([[0, 2], [1, 2]]),\n            new Map([[0, 4], [1, 4]]),\n            new Map([[0, 8], [1, 8]]),\n            new Map([[0, 12], [1, 12]]),\n            new Map([[0, 8], [1, 24]]),\n        ];\n        const teamSizeIndexToString: string[] = teamSizeIndexToTeamSizeMap\n            .map((map) => {\n                return `${map.get(0)!}x${map.get(1)!}`;\n            });\n        const onTeamSizeChangeCallback = (index: number) => {\n            this.selectedTeamSizeMap = teamSizeIndexToTeamSizeMap[index];\n        };\n        const teamSizeTopY = settingsTopMargin;\n        const matchTypeTopY = teamSizeTopY + buttonSize.y * 2\n            + rowOffset + buttonGroupOffsetY;\n        const aiDifficultyTopY = matchTypeTopY + buttonSize.y\n            + buttonGroupOffsetY;\n        const fogOfWarTopY = aiDifficultyTopY + buttonSize.y\n            + buttonGroupOffsetY;\n        const spawnersTopY = fogOfWarTopY + buttonSize.y + buttonGroupOffsetY;\n        const teamSizeElements = createSettingRowElements({\n            topY: teamSizeTopY,\n            rows: 2,\n            headerText: 'Team size',\n            buttonTexts: teamSizeIndexToString,\n            initialButtonIndex: 0,\n            onButtonChangeCallback: onTeamSizeChangeCallback,\n        });\n        this.uiManager.addElement(teamSizeElements[0]);\n        this.uiManager.addElement(teamSizeElements[1]);\n\n        // AI difficulty buttons.\n        const difficulties: AiDifficulty[] = [\n            AiDifficulty.WEAK,\n            AiDifficulty.MEDIUM,\n            AiDifficulty.STRONG,\n        ];\n        const difficultyStrings = [\n            'Easy',\n            'Medium',\n            'Hard',\n        ];\n        const onAiChangeCallback = (index: number) => {\n            this.selectedAiDifficulty = difficulties[index];\n        };\n        const aiDifficultyElements = createSettingRowElements({\n            topY: aiDifficultyTopY,\n            rows: 1,\n            headerText: 'Difficulty',\n            buttonTexts: difficultyStrings,\n            initialButtonIndex: 0,\n            onButtonChangeCallback: onAiChangeCallback,\n        });\n        this.uiManager.addElement(aiDifficultyElements[0]);\n        this.uiManager.addElement(aiDifficultyElements[1]);\n\n        // Match type buttons.\n        const matchTypes: MatchType[] = [\n            MatchType.PLAYER_VS_PLAYER_LOCAL,\n            MatchType.PLAYER_VS_AI,\n            MatchType.AI_VS_AI,\n        ];\n        const matchTypeStrings = [\n            'PvP',\n            'PvAI',\n            'AIvAI',\n        ];\n        const onChangeCallback = (index: number) => {\n            const previousMatchType = this.selectedMatchType;\n            this.selectedMatchType = matchTypes[index];\n            if (this.selectedMatchType === MatchType.PLAYER_VS_PLAYER_LOCAL &&\n                previousMatchType !== MatchType.PLAYER_VS_PLAYER_LOCAL) {\n                this.uiManager.removeElement(aiDifficultyElements[0]);\n                this.uiManager.removeElement(aiDifficultyElements[1]);\n            } else if (\n                this.selectedMatchType !== MatchType.PLAYER_VS_PLAYER_LOCAL\n                && previousMatchType === MatchType.PLAYER_VS_PLAYER_LOCAL) {\n                this.uiManager.addElement(aiDifficultyElements[0]);\n                this.uiManager.addElement(aiDifficultyElements[1]);\n            }\n        };\n        const matchTypeElements = createSettingRowElements({\n            topY: matchTypeTopY,\n            rows: 1,\n            headerText: 'Match type',\n            buttonTexts: matchTypeStrings,\n            initialButtonIndex: 1,\n            onButtonChangeCallback: onChangeCallback,\n        });\n        this.uiManager.addElement(matchTypeElements[0]);\n        this.uiManager.addElement(matchTypeElements[1]);\n\n        // Fog of war.\n        const fogOfWarOptions: boolean[] = [\n            true,\n            false,\n        ];\n        const fogOfWarOptionStrings = [\n            'On',\n            'Off',\n        ];\n        const onFogOfWarChangeCallback = (index: number) => {\n            this.isFogOfWarOn = fogOfWarOptions[index];\n        };\n        const fogOfWarElements = createSettingRowElements({\n            topY: fogOfWarTopY,\n            rows: 1,\n            headerText: 'Fog of war',\n            buttonTexts: fogOfWarOptionStrings,\n            initialButtonIndex: 1,\n            onButtonChangeCallback: onFogOfWarChangeCallback,\n        });\n        this.uiManager.addElement(fogOfWarElements[0]);\n        this.uiManager.addElement(fogOfWarElements[1]);\n\n        // Spawners.\n        const spawnersOptions: boolean[] = [\n            true,\n            false,\n        ];\n        const spawnersOptionStrings = [\n            'On',\n            'Off',\n        ];\n        const onSpawnersChangeCallback = (index: number) => {\n            this.hasSpawners = spawnersOptions[index];\n        };\n        const spawnerElements = createSettingRowElements({\n            topY: spawnersTopY,\n            rows: 1,\n            headerText: 'Spawners',\n            buttonTexts: spawnersOptionStrings,\n            initialButtonIndex: 1,\n            onButtonChangeCallback: onSpawnersChangeCallback,\n        });\n        this.uiManager.addElement(spawnerElements[0]);\n        this.uiManager.addElement(spawnerElements[1]);\n    }\n\n    private initLevelElements(leftMargin: number): void {\n        const fontSize = 22;\n        const headerTopMargin = .18;\n        const buttonOffsetY = .02;\n        const levelElementSize = new Point(.18, .08);\n        const buttonTopMargin =\n            headerTopMargin + buttonOffsetY + levelElementSize.y;\n\n        const headerStyle: TextBoxStyle = {\n            color: '#dddddd',\n            fontSize,\n            textColor: '#000000',\n        };\n        const buttonStyle: ButtonStyle = {\n            fontSize,\n            color: '#f7c25e',\n            hoverColor: '#deaf57',\n            selectedColor: '#db9d2a',\n            selectedBorderColor: '#000000',\n            textColor: THEME.buttonTextColor,\n        };\n\n        // Level buttons.\n        const levelButtonsLeftMargin = leftMargin;\n        const levelHeaderLeftMargin =\n            levelButtonsLeftMargin + levelElementSize.x / 2 + .04 / 2;\n        const levelHeader = new TextBox({\n            dimensions: {\n                size: levelElementSize,\n                text: 'Level',\n                topLeft: new Point(levelHeaderLeftMargin, headerTopMargin),\n            },\n            style: headerStyle,\n        });\n        this.uiManager.addElement(levelHeader);\n\n        const levelDimensions: ButtonDimensions[] = [];\n        const columnSize = 6;\n        for (let buttonIndex = 0; buttonIndex < LEVELS.length; buttonIndex++) {\n            let row = buttonIndex % columnSize;\n            let column = Math.floor(buttonIndex / columnSize);\n            let leftMargin = levelButtonsLeftMargin;\n            if (column === 1) {\n                leftMargin = leftMargin + levelElementSize.x + .04;\n            }\n            const topLeftY = buttonTopMargin + row * buttonOffsetY\n                + row * levelElementSize.y;\n            const level = LEVELS[buttonIndex];\n\n            levelDimensions.push({\n                topLeft: new Point(leftMargin, topLeftY),\n                size: levelElementSize,\n                text: level.name,\n            });\n        }\n\n        const initialLevelSelectionIndex = 0;\n        const onLevelChangeCallback = (index: number) => {\n            this.selectedLevelIndex = index;\n        };\n        onLevelChangeCallback(initialLevelSelectionIndex);\n        this.uiManager.addElement(new ButtonGroup({\n            buttons: levelDimensions,\n            buttonStyle,\n            initialSelectionIndex: initialLevelSelectionIndex,\n            onChangeCallback: onLevelChangeCallback,\n        }));\n    }\n\n    private renderTitleText(): void {\n        this.context.fillStyle = THEME.buttonTextColor;\n        const fontSize = 72;\n        this.context.font = `${fontSize}px fantasy`;\n        const text = 'Free Play'\n        const textWidth = this.context.measureText(text).width;\n        const textCanvasPosition = new Point(\n            RENDER_SETTINGS.canvasWidth / 2,\n            RENDER_SETTINGS.canvasHeight / 6);\n        this.context.fillText(\n            text,\n            textCanvasPosition.x - textWidth / 2,\n            textCanvasPosition.y - fontSize / 2);\n    }\n}","import { RENDER_SETTINGS } from 'src/app/render_settings';\nimport { CONTROLS } from 'src/app/controls';\nimport { GameModeManager } from 'src/app/game_mode_manager';\nimport { GameManager } from 'src/app/game_manager';\nimport { LevelCreator } from 'src/app/level_creator';\nimport { GameSettings } from 'src/app/game_settings';\nimport { CAMPAIGN_LEVELS, tryUnlockingAndSavingProgress } from 'src/app/campaign_level';\nimport { FreePlayMenu } from 'src/app/menus/free_play_menu';\nimport { CampaignMenu } from 'src/app/menus/campaign_menu';\nimport { StartMenu } from 'src/app/menus/start_menu';\n\n\nconst BACKGROUND_COLOR = '#959aa3';\nconst GRID_COLOR = '#1560e8';\nconst HOVERED_TILE_COLOR = '#f7c25e';\n\nenum GameState {\n  START_MENU,\n  FREE_PLAY_MENU,\n  CAMPAIGN_MENU,\n  GAME,\n  LEVEL_CREATOR,\n}\n\nexport class Main {\n\n  private readonly canvas: HTMLCanvasElement;\n  private readonly context: CanvasRenderingContext2D;\n  private lastRenderTime = 0;\n\n  private gameState: GameState = GameState.START_MENU;\n  private gameStateManager: GameModeManager;\n\n  constructor() {\n    this.canvas = document.createElement('canvas');\n    document.body.appendChild(this.canvas);\n    document.body.style.backgroundColor = '#000000';\n    this.canvas.setAttribute('height', `${RENDER_SETTINGS.canvasHeight}px`);\n    this.canvas.setAttribute('width', `${RENDER_SETTINGS.canvasWidth}px`);\n    this.context = this.canvas.getContext('2d')!;\n    CONTROLS.initMouseControls(this.canvas);\n    this.initStartMenu();\n    window.requestAnimationFrame((timestamp: number) => {\n      this.lastRenderTime = timestamp;\n      this.gameLoop(timestamp);\n    });\n  }\n\n  gameLoop(timestamp: number): void {\n    const elapsedMs = timestamp - this.lastRenderTime;\n    if (elapsedMs > RENDER_SETTINGS.msBetweenRenders) {\n      this.lastRenderTime = timestamp;\n      this.gameStateManager.update(elapsedMs);\n      this.gameStateManager.render();\n    }\n    window.requestAnimationFrame((timestamp: number) => {\n      this.gameLoop(timestamp);\n    });\n  }\n\n  private initStartMenu(): void {\n    this.gameState = GameState.START_MENU;\n    this.gameStateManager = new StartMenu(\n      this.canvas,\n      this.context,\n      {\n        onFreePlay: () => {\n          this.tearDownCurrentGameState();\n          this.initFreePlayMenu();\n        },\n        onCampaign: () => {\n          this.tearDownCurrentGameState();\n          this.initCampaignMenu();\n        },\n        onCreateLevel: () => {\n          this.tearDownCurrentGameState();\n          this.initLevelCreator();\n        },\n      });\n  }\n\n  private initGame(\n    levelIndex: number,\n    gameSettings: GameSettings,\n    onExitGameCallback: (winningTeamIndex: number) => void): void {\n\n    this.gameState = GameState.GAME;\n    this.gameStateManager = new GameManager(\n      this.canvas,\n      this.context,\n      {\n        gameSettings,\n        levelIndex,\n        onExitGameCallback,\n      });\n  }\n\n  private initFreePlayMenu(): void {\n    this.gameState = GameState.FREE_PLAY_MENU;\n    this.gameStateManager = new FreePlayMenu(this.canvas, this.context, {\n      onSelectLevel: this.onSelectFreePlayLevel,\n      onBack: this.onBack,\n    });\n  }\n\n  private initCampaignMenu(): void {\n    this.gameState = GameState.CAMPAIGN_MENU;\n    this.gameStateManager = new CampaignMenu(this.canvas, this.context, {\n      onSelectLevel: this.onSelectCampaignLevel,\n      onBack: this.onBack,\n    });\n  }\n\n  private initLevelCreator(): void {\n    this.gameState = GameState.LEVEL_CREATOR;\n    this.gameStateManager = new LevelCreator(\n      this.canvas,\n      this.context,\n      () => {\n        this.tearDownCurrentGameState();\n        this.initStartMenu();\n      });\n  }\n\n  private tearDownCurrentGameState(): void {\n    this.gameStateManager.destroy();\n  }\n\n  private readonly onSelectFreePlayLevel =\n    (levelIndex: number, gameSettings: GameSettings) => {\n      this.initGame(levelIndex, gameSettings, (winningTeamIndex: number) => {\n        this.tearDownCurrentGameState();\n        this.initFreePlayMenu();\n      });\n    };\n\n  private readonly onSelectCampaignLevel =\n    (campaignLevelIndex: number,\n      levelIndex: number,\n      gameSettings: GameSettings) => {\n      this.initGame(levelIndex, gameSettings, (winningTeamIndex: number) => {\n        if (winningTeamIndex === 0) {\n          tryUnlockingAndSavingProgress(campaignLevelIndex + 1)\n        }\n        this.tearDownCurrentGameState();\n        this.initCampaignMenu();\n      });\n    };\n\n  private readonly onBack = () => {\n    this.tearDownCurrentGameState();\n    this.initStartMenu();\n  };\n}\n\nlet isInitialized = false;\ndocument.onreadystatechange = () => {\n  if (document.readyState === 'complete' && !isInitialized) {\n    new Main();\n    isInitialized = true;\n  }\n}","import { UiManager } from 'src/app/ui/ui_manager';\nimport { Button, ButtonDimensions, ButtonStyle } from 'src/app/ui/button';\nimport { Point } from 'src/app/math/point';\nimport { RENDER_SETTINGS } from 'src/app/render_settings';\nimport { CONTROLS } from 'src/app/controls';\nimport { GameModeManager } from 'src/app/game_mode_manager';\nimport { THEME } from 'src/app/theme';\nimport { LEVELS } from 'src/app/level';\nimport { GameSettings, MatchType, DEFAULT_GAME_SETTINGS } from 'src/app/game_settings';\nimport { TextBox, TextBoxStyle } from 'src/app/ui/text_box';\nimport { CAMPAIGN_LEVELS } from 'src/app/campaign_level';\n\ninterface ButtonMetadata {\n    text: string;\n    callback: () => void;\n}\n\nexport class CampaignMenu implements GameModeManager {\n    private readonly canvas: HTMLCanvasElement;\n    private readonly context: CanvasRenderingContext2D;\n    private readonly onSelectLevel:\n        (campaignLevelIndex: number,\n            levelIndex: number,\n            gameSettings: GameSettings) => void;\n    private readonly onBack: () => void;\n    private readonly uiManager: UiManager;\n\n    constructor(\n        canvas: HTMLCanvasElement,\n        context: CanvasRenderingContext2D,\n        callbacks: {\n            readonly onSelectLevel:\n            (campaignLevelIndex: number,\n                levelIndex: number,\n                gameSettings: GameSettings) => void;\n            onBack: () => void;\n        }) {\n\n        this.canvas = canvas;\n        this.context = context;\n        this.onSelectLevel = callbacks.onSelectLevel;\n        this.onBack = callbacks.onBack;\n\n        this.uiManager = new UiManager(context);\n        this.initLevelMenu();\n    }\n\n    update(elapsedTime: number): void {\n        this.uiManager.onMouseMove(CONTROLS.getMouseCanvasCoords());\n        if (CONTROLS.hasClick()) {\n            const clickCanvasCoords = CONTROLS.handleClick();\n            this.uiManager.onClick(clickCanvasCoords);\n        }\n    }\n\n    render(): void {\n        this.context.fillStyle = THEME.uiBackgroundColor;\n        this.context.clearRect(\n            0, 0, RENDER_SETTINGS.canvasWidth, RENDER_SETTINGS.canvasHeight);\n        this.context.fillRect(\n            0, 0, RENDER_SETTINGS.canvasWidth, RENDER_SETTINGS.canvasHeight);\n        this.renderTitleText();\n        this.uiManager.render();\n    }\n\n    destroy(): void {\n        // no-op\n    }\n\n    private initLevelMenu(): void {\n\n        const buttonOffsetY = .04;\n        const elementSize = new Point(.24, .08);\n        const buttonTopMargin = .2 + buttonOffsetY + elementSize.y;\n        const fontSize = 24;\n\n        const buttonStyle: ButtonStyle = {\n            fontSize,\n            color: '#f7c25e',\n            hoverColor: '#fcd281',\n            selectedColor: '#db9d2a',\n            selectedBorderColor: '#000000',\n            textColor: THEME.buttonTextColor,\n        };\n\n        const lockedTextBoxStyle: TextBoxStyle = {\n            fontSize,\n            color: '#bd7e00',\n            textColor: THEME.buttonTextColor,\n        };\n\n        const middleColumnLeftMargin = .5 - elementSize.x / 2;\n        const leftColumnLeftMargin =\n            middleColumnLeftMargin - elementSize.x - .1;\n        const rightColumnLeftMargin =\n            middleColumnLeftMargin + elementSize.x + .1;\n\n        const columns = 3;\n        const columnSize = CAMPAIGN_LEVELS.length / columns;\n        for (let campaignLevelIndex = 0;\n            campaignLevelIndex < CAMPAIGN_LEVELS.length;\n            campaignLevelIndex++) {\n\n            const column = Math.floor(campaignLevelIndex / columnSize);\n            const row = campaignLevelIndex % columnSize;\n            const topLeftY = buttonTopMargin + row * buttonOffsetY\n                + row * elementSize.y;\n            const campaignLevel = CAMPAIGN_LEVELS[campaignLevelIndex];\n            let leftMargin = leftColumnLeftMargin;\n            if (column === 1) {\n                leftMargin = middleColumnLeftMargin;\n            } else if (column === 2) {\n                leftMargin = rightColumnLeftMargin;\n            }\n            const dimensions = {\n                topLeft: new Point(leftMargin, topLeftY),\n                size: elementSize,\n                text: campaignLevel.isUnlocked\n                    ? campaignLevel.levelName\n                    : 'Locked',\n            };\n            if (campaignLevel.isUnlocked) {\n                this.uiManager.addElement(new Button({\n                    dimensions,\n                    style: buttonStyle,\n                    onClick: () => {\n                        const settings: GameSettings = {\n                            matchType: MatchType.PLAYER_VS_AI,\n                            teamIndexToSquadSize:\n                                campaignLevel.teamIndexToSquadSize,\n                            numTeams: DEFAULT_GAME_SETTINGS.numTeams,\n                            maxSpawnDistanceFromFlag:\n                                DEFAULT_GAME_SETTINGS.maxSpawnDistanceFromFlag,\n                            hasFogOfWar: true,\n                            hasSpawners: true,\n                            aiDifficulty: campaignLevel.aiDifficulty,\n                        };\n                        this.onSelectLevel(\n                            campaignLevelIndex,\n                            campaignLevel.levelIndex,\n                            settings);\n                    },\n                }));\n            } else {\n                this.uiManager.addElement(new TextBox({\n                    dimensions,\n                    style: lockedTextBoxStyle,\n                }));\n            }\n        }\n\n        const backButton = new Button({\n            dimensions: {\n                size: elementSize,\n                topLeft: new Point(.08, .86),\n                text: 'Back',\n            },\n            style: {\n                fontSize,\n                color: '#d9c8a3',\n                hoverColor: '#e6dbc3',\n                textColor: THEME.buttonTextColor,\n            },\n            onClick: this.onBack,\n        });\n        this.uiManager.addElement(backButton);\n    }\n\n    private renderTitleText(): void {\n        this.context.fillStyle = THEME.buttonTextColor;\n        const fontSize = 72;\n        this.context.font = `${fontSize}px fantasy`;\n        const text = 'Single Player Campaign'\n        const textWidth = this.context.measureText(text).width;\n        const textCanvasPosition = new Point(\n            RENDER_SETTINGS.canvasWidth / 2,\n            RENDER_SETTINGS.canvasHeight / 6);\n        this.context.fillText(\n            text,\n            textCanvasPosition.x - textWidth / 2,\n            textCanvasPosition.y - fontSize / 2);\n    }\n}","import { UiManager } from 'src/app/ui/ui_manager';\nimport { Button } from 'src/app/ui/button';\nimport { Point } from 'src/app/math/point';\nimport { RENDER_SETTINGS } from 'src/app/render_settings';\nimport { CONTROLS } from 'src/app/controls';\nimport { GameModeManager } from 'src/app/game_mode_manager';\nimport { THEME } from 'src/app/theme';\n\ninterface ButtonMetadata {\n    text: string;\n    callback: () => void;\n}\n\nexport class StartMenu implements GameModeManager {\n    private readonly canvas: HTMLCanvasElement;\n    private readonly context: CanvasRenderingContext2D;\n    private readonly onFreePlay: () => void;\n    private readonly onCampaign: () => void;\n    private readonly onCreateLevel: () => void;\n    private readonly uiManager: UiManager;\n\n    constructor(\n        canvas: HTMLCanvasElement,\n        context: CanvasRenderingContext2D,\n        callbacks: {\n            onFreePlay: () => void;\n            onCampaign: () => void;\n            onCreateLevel: () => void;\n        }) {\n\n        this.canvas = canvas;\n        this.context = context;\n        this.onFreePlay = callbacks.onFreePlay;\n        this.onCampaign = callbacks.onCampaign;\n        this.onCreateLevel = callbacks.onCreateLevel;\n\n        this.uiManager = new UiManager(context);\n        this.initMenu();\n    }\n\n    update(elapsedTime: number): void {\n        this.uiManager.onMouseMove(CONTROLS.getMouseCanvasCoords());\n        if (CONTROLS.hasClick()) {\n            const clickCanvasCoords = CONTROLS.handleClick();\n            this.uiManager.onClick(clickCanvasCoords);\n        }\n    }\n\n    render(): void {\n        this.context.fillStyle = THEME.uiBackgroundColor;\n        this.context.clearRect(\n            0, 0, RENDER_SETTINGS.canvasWidth, RENDER_SETTINGS.canvasHeight);\n        this.context.fillRect(\n            0, 0, RENDER_SETTINGS.canvasWidth, RENDER_SETTINGS.canvasHeight);\n        this.renderTitleText();\n        this.uiManager.render();\n    }\n\n    destroy(): void {\n        // no-op\n    }\n\n    private initMenu(): void {\n        const topMargin = .3;\n        const buttonOffsetY = .08;\n        const buttonSize = new Point(.26, .1);\n        const leftMargin = .5 - buttonSize.x / 2;\n        const buttonColor = '#f7c25e';\n        const buttonHoverColor = '#fcd281';\n        const fontSize = 24;\n        const buttonMetadatas: ButtonMetadata[] = [\n            { text: 'Campaign mode', callback: this.onCampaign },\n            { text: 'Free play', callback: this.onFreePlay },\n            { text: 'Create Level', callback: this.onCreateLevel },\n        ];\n        for (let buttonIndex = 0;\n            buttonIndex < buttonMetadatas.length;\n            buttonIndex++) {\n\n            const topLeftY = topMargin + buttonIndex * buttonOffsetY\n                + buttonIndex * buttonSize.y;\n            const buttonMetadata = buttonMetadatas[buttonIndex];\n            const button = new Button({\n                dimensions: {\n                    topLeft: new Point(leftMargin, topLeftY),\n                    size: buttonSize,\n                    text: buttonMetadata.text,\n                },\n                style: {\n                    fontSize,\n                    color: buttonColor,\n                    hoverColor: buttonHoverColor,\n                    textColor: THEME.buttonTextColor,\n                },\n                onClick: buttonMetadata.callback,\n            });\n            this.uiManager.addElement(button);\n        }\n    }\n\n    private renderTitleText(): void {\n        this.context.fillStyle = THEME.buttonTextColor;\n        const fontSize = 72;\n        this.context.font = `${fontSize}px fantasy`;\n        const text = 'Snag the Flag'\n        const textWidth = this.context.measureText(text).width;\n        const textCanvasPosition = new Point(\n            RENDER_SETTINGS.canvasWidth / 2,\n            RENDER_SETTINGS.canvasHeight / 4);\n        this.context.fillText(\n            text,\n            textCanvasPosition.x - textWidth / 2,\n            textCanvasPosition.y - fontSize / 2);\n    }\n}"],"sourceRoot":""}